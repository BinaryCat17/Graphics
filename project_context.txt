PROJECT STRUCTURE (Respecting .gitignore):
==========================================

[.vscode]
  â”œâ”€â”€ settings.json

[ROOT]
  â”œâ”€â”€ CMakeCache.txt
  â”œâ”€â”€ CMakeLists.txt
  â”œâ”€â”€ CMakePresets.json

[assets/ui]
  â”œâ”€â”€ default_graph.yaml

[assets/ui/layouts]
  â”œâ”€â”€ editor_layout.yaml

[assets/ui]
  â”œâ”€â”€ manifest.yaml
  â”œâ”€â”€ palette_config.yaml

[assets/ui/templates]
  â”œâ”€â”€ inspector_default.yaml
  â”œâ”€â”€ inspector_field.yaml
  â”œâ”€â”€ inspector_title.yaml

[assets/ui/templates/math]
  â”œâ”€â”€ add.yaml
  â”œâ”€â”€ mul.yaml
  â”œâ”€â”€ sin.yaml
  â”œâ”€â”€ sub.yaml
  â”œâ”€â”€ uv.yaml
  â”œâ”€â”€ value.yaml
  â”œâ”€â”€ wire.yaml

[assets/ui/templates]
  â”œâ”€â”€ node.yaml
  â”œâ”€â”€ palette_item.yaml
  â”œâ”€â”€ port.yaml
  â”œâ”€â”€ sidebar.yaml
  â”œâ”€â”€ value_row.yaml

[docs]
  â”œâ”€â”€ architecture.md
  â”œâ”€â”€ roadmap.md

[src/app]
  â”œâ”€â”€ main.c

[src/engine/assets]
  â”œâ”€â”€ assets.c
  â”œâ”€â”€ assets.h

[src/engine/assets/internal]
  â”œâ”€â”€ assets_internal.h

[src/engine/core]
  â”œâ”€â”€ engine.c
  â”œâ”€â”€ engine.h

[src/engine/graphics/internal]
  â”œâ”€â”€ render_frame_packet.h
  â”œâ”€â”€ renderer_backend.c
  â”œâ”€â”€ renderer_backend.h

[src/engine/graphics/internal/vulkan]
  â”œâ”€â”€ vk_context.c
  â”œâ”€â”€ vk_context.h
  â”œâ”€â”€ vk_pipeline.c
  â”œâ”€â”€ vk_pipeline.h
  â”œâ”€â”€ vk_resources.c
  â”œâ”€â”€ vk_resources.h
  â”œâ”€â”€ vk_swapchain.c
  â”œâ”€â”€ vk_swapchain.h
  â”œâ”€â”€ vk_types.h
  â”œâ”€â”€ vk_utils.c
  â”œâ”€â”€ vk_utils.h
  â”œâ”€â”€ vulkan_renderer.c
  â”œâ”€â”€ vulkan_renderer.h

[src/engine/graphics]
  â”œâ”€â”€ layer_constants.h
  â”œâ”€â”€ primitives.h
  â”œâ”€â”€ render_system.c
  â”œâ”€â”€ render_system.h

[src/engine/input]
  â”œâ”€â”€ input.c
  â”œâ”€â”€ input.h

[src/engine/input/internal]
  â”œâ”€â”€ input_internal.h

[src/engine/scene/internal]
  â”œâ”€â”€ render_packet_internal.h
  â”œâ”€â”€ scene_graph.c
  â”œâ”€â”€ scene_graph.h
  â”œâ”€â”€ scene_loader.c
  â”œâ”€â”€ scene_loader.h
  â”œâ”€â”€ scene_tree_internal.h

[src/engine/scene]
  â”œâ”€â”€ render_packet.h
  â”œâ”€â”€ scene.c
  â”œâ”€â”€ scene.h
  â”œâ”€â”€ scene_asset.c
  â”œâ”€â”€ scene_asset.h

[src/engine/text]
  â”œâ”€â”€ font.c
  â”œâ”€â”€ font.h

[src/engine/text/internal]
  â”œâ”€â”€ font_internal.h
  â”œâ”€â”€ stb_impl.c

[src/engine/text]
  â”œâ”€â”€ text_renderer.c
  â”œâ”€â”€ text_renderer.h

[src/engine/ui/internal]
  â”œâ”€â”€ ui_binding.c
  â”œâ”€â”€ ui_binding.h
  â”œâ”€â”€ ui_command_system.c
  â”œâ”€â”€ ui_command_system.h
  â”œâ”€â”€ ui_input.c
  â”œâ”€â”€ ui_input.h
  â”œâ”€â”€ ui_internal.h
  â”œâ”€â”€ ui_layout.c
  â”œâ”€â”€ ui_layout.h
  â”œâ”€â”€ ui_renderer.c
  â”œâ”€â”€ ui_renderer.h

[src/engine/ui]
  â”œâ”€â”€ ui_core.c
  â”œâ”€â”€ ui_core.h
  â”œâ”€â”€ ui_input.h
  â”œâ”€â”€ ui_renderer.h

[src/features/math_engine/internal/emitters]
  â”œâ”€â”€ glsl_emitter.c
  â”œâ”€â”€ glsl_emitter.h

[src/features/math_engine/internal]
  â”œâ”€â”€ math_editor_internal.h
  â”œâ”€â”€ math_editor_view.c
  â”œâ”€â”€ math_editor_view.h
  â”œâ”€â”€ math_graph_internal.h
  â”œâ”€â”€ shader_ir.h
  â”œâ”€â”€ transpiler.c
  â”œâ”€â”€ transpiler.h

[src/features/math_engine]
  â”œâ”€â”€ math_editor.c
  â”œâ”€â”€ math_editor.h
  â”œâ”€â”€ math_graph.c
  â”œâ”€â”€ math_graph.h

[src/foundation/config]
  â”œâ”€â”€ config_system.c
  â”œâ”€â”€ config_system.h
  â”œâ”€â”€ config_types.c
  â”œâ”€â”€ config_types.h
  â”œâ”€â”€ simple_yaml.c
  â”œâ”€â”€ simple_yaml.h

[src/foundation/image]
  â”œâ”€â”€ image.c
  â”œâ”€â”€ image.h

[src/foundation/logger]
  â”œâ”€â”€ logger.c
  â”œâ”€â”€ logger.h

[src/foundation/math]
  â”œâ”€â”€ coordinate_systems.c
  â”œâ”€â”€ coordinate_systems.h
  â”œâ”€â”€ math_types.c
  â”œâ”€â”€ math_types.h

[src/foundation/memory]
  â”œâ”€â”€ arena.c
  â”œâ”€â”€ arena.h
  â”œâ”€â”€ pool.c
  â”œâ”€â”€ pool.h

[src/foundation/meta]
  â”œâ”€â”€ reflection.c
  â”œâ”€â”€ reflection.h

[src/foundation/platform]
  â”œâ”€â”€ fs.c
  â”œâ”€â”€ fs.h
  â”œâ”€â”€ glfw_platform.c
  â”œâ”€â”€ platform.h

[src/foundation/string]
  â”œâ”€â”€ string_id.c
  â”œâ”€â”€ string_id.h

[src/foundation/thread]
  â”œâ”€â”€ thread.c
  â”œâ”€â”€ thread.h

[tests]
  â”œâ”€â”€ config_tests.c
  â”œâ”€â”€ memory_tests.c
  â”œâ”€â”€ string_tests.c
  â”œâ”€â”€ test_framework.h
  â”œâ”€â”€ transform_tests.c
  â”œâ”€â”€ transpiler_tests.c
  â”œâ”€â”€ ui_tests.c

[tools]
  â”œâ”€â”€ build_shaders.py
  â”œâ”€â”€ codegen.py
  â”œâ”€â”€ smart_packer.py

[ROOT]
  â”œâ”€â”€ vcpkg-configuration.json
  â”œâ”€â”€ vcpkg.json


FILE CONTENTS:
==========================================


==================================================
FILE START: tools/smart_packer.py
==================================================
ï»¿import os
import subprocess

# ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ¸
OUTPUT_FILE = "project_context.txt"
# ĞÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹, Ğ¿Ğ¾Ğ»ĞµĞ·Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ·Ğ° ĞºĞ¾Ğ´Ğ°
ALLOWED_EXTENSIONS = {
    '.c', '.h', '.cpp', '.hpp', '.cc',          # C/C++
    '.py', '.sh', '.bat', 'Makefile', 'CMakeLists.txt',  # Ğ¡ĞºÑ€Ğ¸Ğ¿Ñ‚Ñ‹ ÑĞ±Ğ¾Ñ€ĞºĞ¸
    '.md', '.txt', '.json', '.xml', '.yaml', '.yml'      # Ğ”Ğ¾ĞºĞ¸ Ğ¸ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³Ğ¸
}

def get_git_files():
    """ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµÑ‚ ÑĞ¿Ğ¸ÑĞ¾Ğº Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ñ ÑƒÑ‡ĞµÑ‚Ğ¾Ğ¼ .gitignore Ñ‡ĞµÑ€ĞµĞ· ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ git"""
    try:
        # --cached: Ğ¸Ğ½Ğ´ĞµĞºÑĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹
        # --others: Ğ½Ğ¾Ğ²Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ (untracked)
        # --exclude-standard: Ğ¿Ñ€Ğ¸Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ° .gitignore
        result = subprocess.run(
            ['git', 'ls-files', '--cached', '--others', '--exclude-standard'],
            capture_output=True, text=True, encoding='utf-8'
        )
        if result.returncode != 0:
            print("Ğ’Ğ½Ğ¸Ğ¼Ğ°Ğ½Ğ¸Ğµ: Ğ­Ñ‚Ğ¾ Ğ½Ğµ git-Ñ€ĞµĞ¿Ğ¾Ğ·Ğ¸Ñ‚Ğ¾Ñ€Ğ¸Ğ¹ Ğ¸Ğ»Ğ¸ git Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½. Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒÑ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ Ğ¾Ğ±Ñ…Ğ¾Ğ´.")
            return None
        
        files = result.stdout.splitlines()
        # Ğ¤Ğ¸Ğ»ÑŒÑ‚Ñ€ÑƒĞµĞ¼ Ğ¿Ğ¾ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ¸ÑĞ¼
        return [f for f in files if any(f.endswith(ext) or f.split('/')[-1] in ALLOWED_EXTENSIONS for ext in ALLOWED_EXTENSIONS)]
    except Exception as e:
        print(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ¿Ñ€Ğ¸ Ğ²Ñ‹Ğ·Ğ¾Ğ²Ğµ git: {e}")
        return None

def fallback_walk():
    """Ğ—Ğ°Ğ¿Ğ°ÑĞ½Ğ¾Ğ¹ Ğ²Ğ°Ñ€Ğ¸Ğ°Ğ½Ñ‚, ĞµÑĞ»Ğ¸ git Ğ½Ğµ ÑÑ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ»"""
    file_list = []
    for root, dirs, files in os.walk("."):
        if '.git' in dirs: dirs.remove('.git') # Ğ˜Ğ³Ğ½Ğ¾Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ğ¿Ğ°Ğ¿ĞºÑƒ .git
        
        for file in files:
            if any(file.endswith(ext) or file in ALLOWED_EXTENSIONS for ext in ALLOWED_EXTENSIONS):
                full_path = os.path.join(root, file)
                # Ğ£Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ ./ Ğ² Ğ½Ğ°Ñ‡Ğ°Ğ»Ğµ Ğ´Ğ»Ñ ĞºÑ€Ğ°ÑĞ¾Ñ‚Ñ‹
                file_list.append(os.path.relpath(full_path, ".").replace("\\", "/"))
    return file_list

def generate_tree_string(file_list):
    """Ğ¡Ñ‚Ñ€Ğ¾Ğ¸Ñ‚ Ğ²Ğ¸Ğ·ÑƒĞ°Ğ»ÑŒĞ½Ğ¾Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ¸Ğ· ÑĞ¿Ğ¸ÑĞºĞ° Ğ¿ÑƒÑ‚ĞµĞ¹"""
    tree_str = "PROJECT STRUCTURE (Respecting .gitignore):\n==========================================\n"
    # ĞŸÑ€Ğ¾ÑÑ‚Ğ¾ ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ½ÑÑ‚Ğ½Ğ¾ÑÑ‚Ğ¸, Ğ¿Ğ¾Ğ»Ğ½Ğ¾Ñ†ĞµĞ½Ğ½Ğ¾Ğµ Ğ´ĞµÑ€ĞµĞ²Ğ¾ Ñ€Ğ¸ÑĞ¾Ğ²Ğ°Ñ‚ÑŒ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼ ÑĞ»Ğ¾Ğ¶Ğ½Ğ¾ Ğ±ĞµĞ· Ğ²Ğ»Ğ¾Ğ¶ĞµĞ½Ğ½Ñ‹Ñ… Ñ†Ğ¸ĞºĞ»Ğ¾Ğ²,
    # Ğ½Ğ¾ Ğ¾Ñ‚ÑĞ¾Ñ€Ñ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¿ÑƒÑ‚ĞµĞ¹ Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾ Ñ‡Ğ¸Ñ‚Ğ°ĞµÑ‚ÑÑ Ğ¼Ğ¾Ğ´ĞµĞ»ÑŒÑ.
    last_dir = ""
    for filepath in sorted(file_list):
        current_dir = os.path.dirname(filepath)
        if current_dir != last_dir:
            tree_str += f"\n[{current_dir if current_dir else 'ROOT'}]\n"
            last_dir = current_dir
        filename = os.path.basename(filepath)
        tree_str += f"  â”œâ”€â”€ {filename}\n"
    return tree_str

def create_dump():
    print("Ğ¡Ğ±Ğ¾Ñ€ ÑĞ¿Ğ¸ÑĞºĞ° Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ñ ÑƒÑ‡ĞµÑ‚Ğ¾Ğ¼ .gitignore...")
    files = get_git_files()
    
    if files is None:
        files = fallback_walk()
        
    print(f"ĞĞ°Ğ¹Ğ´ĞµĞ½Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²: {len(files)}")
    
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as outfile:
        # 1. Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñƒ
        outfile.write(generate_tree_string(files))
        outfile.write("\n\nFILE CONTENTS:\n==========================================\n")
        
        # 2. Ğ—Ğ°Ğ¿Ğ¸ÑÑ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ
        for filepath in files:
            if not os.path.exists(filepath): continue
            
            # Ğ—Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº Ğ´Ğ»Ñ ĞºĞ°Ğ¶Ğ´Ğ¾Ğ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ°, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ñ (Gemini) Ñ‡ĞµÑ‚ĞºĞ¾ Ğ²Ğ¸Ğ´ĞµĞ» Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹
            header = f"\n\n{'='*50}\nFILE START: {filepath}\n{'='*50}\n"
            outfile.write(header)
            
            try:
                with open(filepath, 'r', encoding='utf-8', errors='replace') as f:
                    content = f.read()
                    if not content.strip():
                        outfile.write("(File is empty)")
                    else:
                        outfile.write(content)
            except Exception as e:
                outfile.write(f"Error reading file: {e}")

    print(f"Ğ“Ğ¾Ñ‚Ğ¾Ğ²Ğ¾! Ğ¤Ğ°Ğ¹Ğ» ÑĞ¾Ğ·Ğ´Ğ°Ğ½: {OUTPUT_FILE}")
    print("Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ¿ĞµÑ€ĞµÑ‚Ğ°Ñ‰Ğ¸Ñ‚Ğµ ÑÑ‚Ğ¾Ñ‚ Ñ„Ğ°Ğ¹Ğ» Ğ² Ñ‡Ğ°Ñ‚.")

if __name__ == "__main__":
    create_dump()

==================================================
FILE START: .vscode/settings.json
==================================================
{
    "cmake.debugConfig": {
        "args": [
            "--scene", "../../../assets/scenes/gear_reducer.yaml",
            "--assets", "../../../assets",
            "--ui", "../../../assets/ui/config/layout/ui.yaml"
        ]
    }
}

==================================================
FILE START: CMakeCache.txt
==================================================
# This is the CMakeCache file.
# For build in directory: /mnt/c/Users/smirn/source/repos/Graphics
# It was generated by CMake: /usr/bin/cmake
# You can edit this file to change values found and used by cmake.
# If you do not want to change any of the values, simply exit the editor.
# If you do want to change a value, simply edit, save, and exit the editor.
# The syntax for the file is as follows:
# KEY:TYPE=VALUE
# KEY is the name of a variable in the cache.
# TYPE is a hint to GUIs for the type of VALUE, DO NOT EDIT TYPE!.
# VALUE is the current value for the KEY.

########################
# EXTERNAL cache entries
########################

//Path to a program.
CMAKE_ADDR2LINE:FILEPATH=/usr/bin/addr2line

//Path to a program.
CMAKE_AR:FILEPATH=/usr/bin/ar

//Choose the type of build, options are: None Debug Release RelWithDebInfo
// MinSizeRel ...
CMAKE_BUILD_TYPE:STRING=

//Enable/Disable color output during build.
CMAKE_COLOR_MAKEFILE:BOOL=ON

//CXX compiler
CMAKE_CXX_COMPILER:FILEPATH=/usr/bin/c++

//A wrapper around 'ar' adding the appropriate '--plugin' option
// for the GCC compiler
CMAKE_CXX_COMPILER_AR:FILEPATH=/usr/bin/gcc-ar-9

//A wrapper around 'ranlib' adding the appropriate '--plugin' option
// for the GCC compiler
CMAKE_CXX_COMPILER_RANLIB:FILEPATH=/usr/bin/gcc-ranlib-9

//Flags used by the CXX compiler during all build types.
CMAKE_CXX_FLAGS:STRING=

//Flags used by the CXX compiler during DEBUG builds.
CMAKE_CXX_FLAGS_DEBUG:STRING=-g

//Flags used by the CXX compiler during MINSIZEREL builds.
CMAKE_CXX_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG

//Flags used by the CXX compiler during RELEASE builds.
CMAKE_CXX_FLAGS_RELEASE:STRING=-O3 -DNDEBUG

//Flags used by the CXX compiler during RELWITHDEBINFO builds.
CMAKE_CXX_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG

//C compiler
CMAKE_C_COMPILER:FILEPATH=/usr/bin/cc

//A wrapper around 'ar' adding the appropriate '--plugin' option
// for the GCC compiler
CMAKE_C_COMPILER_AR:FILEPATH=/usr/bin/gcc-ar-9

//A wrapper around 'ranlib' adding the appropriate '--plugin' option
// for the GCC compiler
CMAKE_C_COMPILER_RANLIB:FILEPATH=/usr/bin/gcc-ranlib-9

//Flags used by the C compiler during all build types.
CMAKE_C_FLAGS:STRING=

//Flags used by the C compiler during DEBUG builds.
CMAKE_C_FLAGS_DEBUG:STRING=-g

//Flags used by the C compiler during MINSIZEREL builds.
CMAKE_C_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG

//Flags used by the C compiler during RELEASE builds.
CMAKE_C_FLAGS_RELEASE:STRING=-O3 -DNDEBUG

//Flags used by the C compiler during RELWITHDEBINFO builds.
CMAKE_C_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG

//Path to a program.
CMAKE_DLLTOOL:FILEPATH=CMAKE_DLLTOOL-NOTFOUND

//Flags used by the linker during all build types.
CMAKE_EXE_LINKER_FLAGS:STRING=

//Flags used by the linker during DEBUG builds.
CMAKE_EXE_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during MINSIZEREL builds.
CMAKE_EXE_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during RELEASE builds.
CMAKE_EXE_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during RELWITHDEBINFO builds.
CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//Enable/Disable output of compile commands during generation.
CMAKE_EXPORT_COMPILE_COMMANDS:BOOL=OFF

//Install path prefix, prepended onto install directories.
CMAKE_INSTALL_PREFIX:PATH=/usr/local

//Path to a program.
CMAKE_LINKER:FILEPATH=/usr/bin/ld

//Path to a program.
CMAKE_MAKE_PROGRAM:FILEPATH=/usr/bin/make

//Flags used by the linker during the creation of modules during
// all build types.
CMAKE_MODULE_LINKER_FLAGS:STRING=

//Flags used by the linker during the creation of modules during
// DEBUG builds.
CMAKE_MODULE_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during the creation of modules during
// MINSIZEREL builds.
CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during the creation of modules during
// RELEASE builds.
CMAKE_MODULE_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during the creation of modules during
// RELWITHDEBINFO builds.
CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//Path to a program.
CMAKE_NM:FILEPATH=/usr/bin/nm

//Path to a program.
CMAKE_OBJCOPY:FILEPATH=/usr/bin/objcopy

//Path to a program.
CMAKE_OBJDUMP:FILEPATH=/usr/bin/objdump

//Value Computed by CMake
CMAKE_PROJECT_DESCRIPTION:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_HOMEPAGE_URL:STATIC=

//Value Computed by CMake
CMAKE_PROJECT_NAME:STATIC=Graphics

//Path to a program.
CMAKE_RANLIB:FILEPATH=/usr/bin/ranlib

//Path to a program.
CMAKE_READELF:FILEPATH=/usr/bin/readelf

//Flags used by the linker during the creation of shared libraries
// during all build types.
CMAKE_SHARED_LINKER_FLAGS:STRING=

//Flags used by the linker during the creation of shared libraries
// during DEBUG builds.
CMAKE_SHARED_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during the creation of shared libraries
// during MINSIZEREL builds.
CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during the creation of shared libraries
// during RELEASE builds.
CMAKE_SHARED_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during the creation of shared libraries
// during RELWITHDEBINFO builds.
CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//If set, runtime paths are not added when installing shared libraries,
// but are added when building.
CMAKE_SKIP_INSTALL_RPATH:BOOL=NO

//If set, runtime paths are not added when using shared libraries.
CMAKE_SKIP_RPATH:BOOL=NO

//Flags used by the linker during the creation of static libraries
// during all build types.
CMAKE_STATIC_LINKER_FLAGS:STRING=

//Flags used by the linker during the creation of static libraries
// during DEBUG builds.
CMAKE_STATIC_LINKER_FLAGS_DEBUG:STRING=

//Flags used by the linker during the creation of static libraries
// during MINSIZEREL builds.
CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL:STRING=

//Flags used by the linker during the creation of static libraries
// during RELEASE builds.
CMAKE_STATIC_LINKER_FLAGS_RELEASE:STRING=

//Flags used by the linker during the creation of static libraries
// during RELWITHDEBINFO builds.
CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO:STRING=

//Path to a program.
CMAKE_STRIP:FILEPATH=/usr/bin/strip

//If this value is on, makefiles will be generated without the
// .SILENT directive, and all commands will be echoed to the console
// during the make.  This is useful for debugging only. With Visual
// Studio IDE projects all commands are done without /nologo.
CMAKE_VERBOSE_MAKEFILE:BOOL=FALSE

//Value Computed by CMake
Graphics_BINARY_DIR:STATIC=/mnt/c/Users/smirn/source/repos/Graphics

//Value Computed by CMake
Graphics_SOURCE_DIR:STATIC=/mnt/c/Users/smirn/source/repos/Graphics

//The directory containing a CMake configuration file for Stb.
Stb_DIR:PATH=Stb_DIR-NOTFOUND


########################
# INTERNAL cache entries
########################

//ADVANCED property for variable: CMAKE_ADDR2LINE
CMAKE_ADDR2LINE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_AR
CMAKE_AR-ADVANCED:INTERNAL=1
//This is the directory where this CMakeCache.txt was created
CMAKE_CACHEFILE_DIR:INTERNAL=/mnt/c/Users/smirn/source/repos/Graphics
//Major version of cmake used to create the current loaded cache
CMAKE_CACHE_MAJOR_VERSION:INTERNAL=3
//Minor version of cmake used to create the current loaded cache
CMAKE_CACHE_MINOR_VERSION:INTERNAL=16
//Patch version of cmake used to create the current loaded cache
CMAKE_CACHE_PATCH_VERSION:INTERNAL=3
//ADVANCED property for variable: CMAKE_COLOR_MAKEFILE
CMAKE_COLOR_MAKEFILE-ADVANCED:INTERNAL=1
//Path to CMake executable.
CMAKE_COMMAND:INTERNAL=/usr/bin/cmake
//Path to cpack program executable.
CMAKE_CPACK_COMMAND:INTERNAL=/usr/bin/cpack
//Path to ctest program executable.
CMAKE_CTEST_COMMAND:INTERNAL=/usr/bin/ctest
//ADVANCED property for variable: CMAKE_CXX_COMPILER
CMAKE_CXX_COMPILER-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_COMPILER_AR
CMAKE_CXX_COMPILER_AR-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_COMPILER_RANLIB
CMAKE_CXX_COMPILER_RANLIB-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS
CMAKE_CXX_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_DEBUG
CMAKE_CXX_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_MINSIZEREL
CMAKE_CXX_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_RELEASE
CMAKE_CXX_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_CXX_FLAGS_RELWITHDEBINFO
CMAKE_CXX_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_COMPILER
CMAKE_C_COMPILER-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_COMPILER_AR
CMAKE_C_COMPILER_AR-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_COMPILER_RANLIB
CMAKE_C_COMPILER_RANLIB-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS
CMAKE_C_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_DEBUG
CMAKE_C_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_MINSIZEREL
CMAKE_C_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_RELEASE
CMAKE_C_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_C_FLAGS_RELWITHDEBINFO
CMAKE_C_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_DLLTOOL
CMAKE_DLLTOOL-ADVANCED:INTERNAL=1
//Executable file format
CMAKE_EXECUTABLE_FORMAT:INTERNAL=ELF
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS
CMAKE_EXE_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_DEBUG
CMAKE_EXE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_MINSIZEREL
CMAKE_EXE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELEASE
CMAKE_EXE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_EXPORT_COMPILE_COMMANDS
CMAKE_EXPORT_COMPILE_COMMANDS-ADVANCED:INTERNAL=1
//Name of external makefile project generator.
CMAKE_EXTRA_GENERATOR:INTERNAL=
//Name of generator.
CMAKE_GENERATOR:INTERNAL=Unix Makefiles
//Generator instance identifier.
CMAKE_GENERATOR_INSTANCE:INTERNAL=
//Name of generator platform.
CMAKE_GENERATOR_PLATFORM:INTERNAL=
//Name of generator toolset.
CMAKE_GENERATOR_TOOLSET:INTERNAL=
//Test CMAKE_HAVE_LIBC_PTHREAD
CMAKE_HAVE_LIBC_PTHREAD:INTERNAL=
//Have library pthreads
CMAKE_HAVE_PTHREADS_CREATE:INTERNAL=
//Have library pthread
CMAKE_HAVE_PTHREAD_CREATE:INTERNAL=1
//Have include pthread.h
CMAKE_HAVE_PTHREAD_H:INTERNAL=1
//Source directory with the top level CMakeLists.txt file for this
// project
CMAKE_HOME_DIRECTORY:INTERNAL=/mnt/c/Users/smirn/source/repos/Graphics
//Install .so files without execute permission.
CMAKE_INSTALL_SO_NO_EXE:INTERNAL=1
//ADVANCED property for variable: CMAKE_LINKER
CMAKE_LINKER-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MAKE_PROGRAM
CMAKE_MAKE_PROGRAM-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS
CMAKE_MODULE_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_DEBUG
CMAKE_MODULE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL
CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELEASE
CMAKE_MODULE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_NM
CMAKE_NM-ADVANCED:INTERNAL=1
//number of local generators
CMAKE_NUMBER_OF_MAKEFILES:INTERNAL=1
//ADVANCED property for variable: CMAKE_OBJCOPY
CMAKE_OBJCOPY-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_OBJDUMP
CMAKE_OBJDUMP-ADVANCED:INTERNAL=1
//Platform information initialized
CMAKE_PLATFORM_INFO_INITIALIZED:INTERNAL=1
//ADVANCED property for variable: CMAKE_RANLIB
CMAKE_RANLIB-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_READELF
CMAKE_READELF-ADVANCED:INTERNAL=1
//Path to CMake installation.
CMAKE_ROOT:INTERNAL=/usr/share/cmake-3.16
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS
CMAKE_SHARED_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_DEBUG
CMAKE_SHARED_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL
CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELEASE
CMAKE_SHARED_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SKIP_INSTALL_RPATH
CMAKE_SKIP_INSTALL_RPATH-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_SKIP_RPATH
CMAKE_SKIP_RPATH-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS
CMAKE_STATIC_LINKER_FLAGS-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_DEBUG
CMAKE_STATIC_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL
CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELEASE
CMAKE_STATIC_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO
CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
//ADVANCED property for variable: CMAKE_STRIP
CMAKE_STRIP-ADVANCED:INTERNAL=1
//uname command
CMAKE_UNAME:INTERNAL=/usr/bin/uname
//ADVANCED property for variable: CMAKE_VERBOSE_MAKEFILE
CMAKE_VERBOSE_MAKEFILE-ADVANCED:INTERNAL=1
//Details about finding Threads
FIND_PACKAGE_MESSAGE_DETAILS_Threads:INTERNAL=[TRUE][v()]



==================================================
FILE START: CMakeLists.txt
==================================================
cmake_minimum_required (VERSION 3.10)

project ("Graphics" LANGUAGES C)

# --- Options & Output ---

find_program(CLANG_TIDY "clang-tidy")
if(CLANG_TIDY)
    message(STATUS "Clang-tidy found: ${CLANG_TIDY}")
    set(CMAKE_C_CLANG_TIDY "${CLANG_TIDY}")
else()
    message(STATUS "Clang-tidy not found")
endif()

if (MSVC)
    add_compile_options(/utf-8 /W4 /WX)
else()
    add_compile_options(-Wall -Wextra -Wpedantic -Werror)
endif()

enable_testing()

set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)

# --- Dependencies ---

find_package(Threads REQUIRED)
find_package(Stb REQUIRED)
find_package(glfw3 CONFIG REQUIRED)
find_package(Vulkan REQUIRED)

# --- Shaders ---

find_package(Python3 REQUIRED)

add_custom_target(Shaders
    COMMAND ${Python3_EXECUTABLE} "${CMAKE_CURRENT_SOURCE_DIR}/tools/build_shaders.py"
    WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
    COMMENT "Building Shaders..."
)

# --- CODE GENERATION ---

find_package(Python3 REQUIRED)
set(GENERATED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/src/generated")
set(REFLECTION_REGISTRY "${GENERATED_DIR}/reflection_registry.c")

add_custom_target(Codegen
    COMMAND ${Python3_EXECUTABLE} "${CMAKE_CURRENT_SOURCE_DIR}/tools/codegen.py"
    WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
    COMMENT "Running reflection codegen..."
    BYPRODUCTS ${REFLECTION_REGISTRY}
)
set_source_files_properties(${REFLECTION_REGISTRY} PROPERTIES GENERATED TRUE)

# --- FOUNDATION LAYER ---

# Thread
add_library(foundation_thread STATIC "src/foundation/thread/thread.c")
target_include_directories(foundation_thread PUBLIC "src/")
target_link_libraries(foundation_thread PUBLIC Threads::Threads)

# Logger
add_library(foundation_logger STATIC "src/foundation/logger/logger.c")
target_include_directories(foundation_logger PUBLIC "src/")
target_link_libraries(foundation_logger PUBLIC foundation_thread)

# String
add_library(foundation_string STATIC "src/foundation/string/string_id.c")
target_include_directories(foundation_string PUBLIC "src/")

# Meta (Reflection)
set(FOUNDATION_META_SOURCES
    "src/foundation/meta/reflection.c"
    ${REFLECTION_REGISTRY}
)
add_library(foundation_meta STATIC ${FOUNDATION_META_SOURCES})
target_include_directories(foundation_meta PUBLIC "src/")
target_link_libraries(foundation_meta PUBLIC foundation_logger foundation_string)
add_dependencies(foundation_meta Codegen)

# Platform
set(FOUNDATION_PLATFORM_SOURCES
    "src/foundation/platform/glfw_platform.c"
    "src/foundation/platform/fs.c")
add_library(foundation_platform STATIC ${FOUNDATION_PLATFORM_SOURCES})
target_include_directories(foundation_platform PUBLIC "src/")
target_link_libraries(foundation_platform PUBLIC glfw Vulkan::Vulkan foundation_logger foundation_string)

# Math
set(FOUNDATION_MATH_SOURCES
    "src/foundation/math/math_types.c"
    "src/foundation/math/coordinate_systems.c")
add_library(foundation_math STATIC ${FOUNDATION_MATH_SOURCES})
target_include_directories(foundation_math PUBLIC "src/")
if(UNIX)
    target_link_libraries(foundation_math PUBLIC m)
endif()

# Memory
set(FOUNDATION_MEMORY_SOURCES 
    "src/foundation/memory/arena.c"
    "src/foundation/memory/pool.c"
)
add_library(foundation_memory STATIC ${FOUNDATION_MEMORY_SOURCES})
target_include_directories(foundation_memory PUBLIC "src/")
target_link_libraries(foundation_memory PUBLIC foundation_logger)

# Image
add_library(foundation_image STATIC "src/foundation/image/image.c")
target_include_directories(foundation_image PUBLIC "src/" ${Stb_INCLUDE_DIR})
target_link_libraries(foundation_image PUBLIC foundation_logger)

# Config
set(FOUNDATION_CONFIG_SOURCES
    "src/foundation/config/simple_yaml.c"
    "src/foundation/config/config_types.c"
    "src/foundation/config/config_system.c")
add_library(foundation_config STATIC ${FOUNDATION_CONFIG_SOURCES})
target_include_directories(foundation_config PUBLIC "src/")
target_link_libraries(foundation_config PUBLIC foundation_platform foundation_logger)

# --- ENGINE LAYER ---

# Scene
add_library(engine_scene STATIC 
    "src/engine/scene/scene.c"
    "src/engine/scene/scene_asset.c"
    "src/engine/scene/internal/scene_graph.c"
    "src/engine/scene/internal/scene_loader.c"
)
target_include_directories(engine_scene PUBLIC "src/")
target_link_libraries(engine_scene PUBLIC foundation_math foundation_memory foundation_string foundation_meta foundation_config)

# Input
add_library(engine_input STATIC "src/engine/input/input.c")
target_include_directories(engine_input PUBLIC "src/")
target_link_libraries(engine_input PUBLIC foundation_platform foundation_logger)

# Text
set(ENGINE_TEXT_SOURCES
    "src/engine/text/text_renderer.c"
    "src/engine/text/font.c"
    "src/engine/text/internal/stb_impl.c"
)
add_library(engine_text STATIC ${ENGINE_TEXT_SOURCES})
target_include_directories(engine_text PUBLIC "src/" ${Stb_INCLUDE_DIR})
target_link_libraries(engine_text PUBLIC foundation_platform foundation_logger engine_scene)

# Assets
set(ENGINE_ASSETS_SOURCES "src/engine/assets/assets.c")
add_library(engine_assets STATIC ${ENGINE_ASSETS_SOURCES})
target_include_directories(engine_assets PUBLIC "src/")
target_link_libraries(engine_assets PUBLIC foundation_platform foundation_config engine_scene)

# Graphics (Renderer + Vulkan)
set(ENGINE_GRAPHICS_SOURCES
    "src/engine/graphics/internal/renderer_backend.c"
    "src/engine/graphics/internal/vulkan/vulkan_renderer.c"
    "src/engine/graphics/internal/vulkan/vk_utils.c"
    "src/engine/graphics/internal/vulkan/vk_context.c"
    "src/engine/graphics/internal/vulkan/vk_swapchain.c"
    "src/engine/graphics/internal/vulkan/vk_pipeline.c"
    "src/engine/graphics/internal/vulkan/vk_resources.c"
    "src/engine/graphics/render_system.c"
)
add_library(engine_graphics STATIC ${ENGINE_GRAPHICS_SOURCES})
target_include_directories(engine_graphics PUBLIC "src/" ${Stb_INCLUDE_DIR})
target_link_libraries(engine_graphics PUBLIC 
    foundation_platform foundation_math foundation_memory foundation_image
    Vulkan::Vulkan glfw Threads::Threads 
    foundation_config engine_assets engine_scene
)

# UI
set(ENGINE_UI_SOURCES
    src/engine/ui/ui_core.c
    src/engine/ui/internal/ui_input.c
    src/engine/ui/internal/ui_layout.c
    src/engine/ui/internal/ui_renderer.c
    src/engine/ui/internal/ui_command_system.c
    src/engine/ui/internal/ui_binding.c)
add_library(engine_ui STATIC ${ENGINE_UI_SOURCES})
target_include_directories(engine_ui PUBLIC "src/" ${Stb_INCLUDE_DIR})
target_link_libraries(engine_ui PUBLIC 
    foundation_config engine_assets foundation_meta foundation_math 
    engine_scene engine_text engine_input
)

# --- FEATURES LAYER ---

# Math Engine (Feature)
set(FEATURE_MATH_ENGINE_SOURCES
    "src/features/math_engine/math_graph.c"
    "src/features/math_engine/math_editor.c"
    "src/features/math_engine/internal/math_editor_view.c"
    "src/features/math_engine/internal/transpiler.c"
    "src/features/math_engine/internal/emitters/glsl_emitter.c")
add_library(feature_math_engine STATIC ${FEATURE_MATH_ENGINE_SOURCES})
target_include_directories(feature_math_engine PUBLIC "src/")
target_link_libraries(feature_math_engine PUBLIC foundation_math foundation_memory)
target_link_libraries(feature_math_engine PRIVATE 
    engine_graphics engine_ui engine_scene engine_text
    foundation_platform foundation_config foundation_logger foundation_meta
)
if(UNIX)
    target_link_libraries(feature_math_engine PUBLIC m)
endif()

# Engine Core
set(ENGINE_CORE_SOURCES
    "src/engine/core/engine.c"
)
add_library(engine_core STATIC ${ENGINE_CORE_SOURCES})
target_include_directories(engine_core PUBLIC "src/")
target_link_libraries(engine_core PUBLIC 
    engine_graphics engine_ui engine_assets engine_text feature_math_engine 
    foundation_meta foundation_logger engine_input
)

# --- APP ---

add_executable(Graphics "src/app/main.c")
target_include_directories(Graphics PRIVATE "src/" ${Vulkan_INCLUDE_DIRS} ${Stb_INCLUDE_DIR})
target_link_libraries(Graphics PRIVATE
    engine_core
    feature_math_engine
    engine_graphics
    engine_ui
    engine_assets
    engine_scene
    engine_text
    foundation_config
    foundation_platform
    foundation_meta
    foundation_math
    foundation_memory
    glfw
    Vulkan::Vulkan
    Threads::Threads)
add_dependencies(Graphics Shaders)


# --- Tests ---

function(add_graphics_test TEST_NAME SOURCE_FILE)
    add_executable(${TEST_NAME} ${SOURCE_FILE})
    target_include_directories(${TEST_NAME} PRIVATE src ${Stb_INCLUDE_DIR})
    target_link_libraries(${TEST_NAME} PRIVATE ${ARGN} foundation_math foundation_memory) # Link common base
    add_test(NAME ${TEST_NAME} COMMAND ${TEST_NAME})
endfunction()

# Update test paths and libs
add_graphics_test(transform_tests tests/transform_tests.c foundation_math engine_scene)
add_graphics_test(transpiler_tests tests/transpiler_tests.c feature_math_engine)
add_graphics_test(ui_tests tests/ui_tests.c engine_ui foundation_logger feature_math_engine)
add_graphics_test(memory_tests tests/memory_tests.c foundation_memory)
add_graphics_test(string_tests tests/string_tests.c foundation_string)

# Config Tests (Manual definition to include reflection.c source)
add_executable(config_tests tests/config_tests.c src/foundation/meta/reflection.c)
target_include_directories(config_tests PRIVATE src ${Stb_INCLUDE_DIR})
target_link_libraries(config_tests PRIVATE foundation_config foundation_string foundation_logger foundation_math foundation_memory)
add_test(NAME config_tests COMMAND config_tests)

==================================================
FILE START: CMakePresets.json
==================================================
{
    "version": 8,
    "configurePresets": [
        {
            "name": "x64-debug-win",
            "displayName": "Custom win preset",
            "generator": "Visual Studio 18 2026",
            "binaryDir": "${sourceDir}/out/build/${presetName}",
            "architecture": "x64",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug",
                "VCPKG_TARGET_TRIPLET": "x64-windows",
                "CMAKE_INSTALL_PREFIX": "${sourceDir}/out/install/${presetName}",
                "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake"
            }
        },
                {
            "name": "x64-debug-linux",
            "displayName": "Custom linux preset",
            "generator": "Ninja",
            "binaryDir": "${sourceDir}/out/build/${presetName}",
            "cacheVariables": {
                "CMAKE_BUILD_TYPE": "Debug",
                "VCPKG_TARGET_TRIPLET": "x64-linux",
                "CMAKE_INSTALL_PREFIX": "${sourceDir}/out/install/${presetName}",
                "CMAKE_TOOLCHAIN_FILE": "$env{VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake",
                "CMAKE_MESSAGE_LOG_LEVEL": "WARNING"
            }
        }
    ]
}

==================================================
FILE START: assets/ui/default_graph.yaml
==================================================
nodes:
  - logic:
      type: MATH_NODE_UV
    layout:
      x: 50
      y: 100
      name: "UV.x"
  - logic:
      type: MATH_NODE_VALUE
      value: 20.0
    layout:
      x: 50
      y: 250
      name: "Frequency"
  - logic:
      type: MATH_NODE_MUL
      input_0: 0
      input_1: 1
    layout:
      x: 250
      y: 175
      name: "Multiply"
  - logic:
      type: MATH_NODE_SIN
      input_0: 2
    layout:
      x: 450
      y: 175
      name: "Sin"

==================================================
FILE START: assets/ui/layouts/editor_layout.yaml
==================================================
type: container
id: root
layout:
  type: split_h
  width: -1
  height: -1
  spacing: 10
  padding: 10
  split_ratio: 0.2
style:
  color: "#1A1A1E"

children:
  # Left Panel (Editor)
  - type: instance
    instance: "EditorSidebar"

  # Right Area (Canvas)
  - type: container
    id: canvas_area
    layout:
      type: canvas
      width: -1 # Fill rest
      height: -1
    style:
      color: "#00000000"
    
    children:
        # Wires (Back)
        - type: container 
          id: wires_layer
          layout:
            type: canvas
            width: 100%
            height: 100%
          style:
            color: "#00000000"
          collection: "view.wires"
          item_template: "GraphWire"

        # Nodes (Front)
        - type: container 
          id: nodes_layer
          layout:
            type: canvas
            width: 100%
            height: 100%
          style:
            color: "#00000000"
          collection: "view.node_views"
          item_template: "GraphNode"

        - type: text
          text: "Canvas Area (Drag nodes here)"
          layout:
            x: 20
            y: 20
            height: 30
          style:
            color: "#888888"

==================================================
FILE START: assets/ui/manifest.yaml
==================================================
templates:
  # Core Templates
  ValueRow:
    import: "assets/ui/templates/value_row.yaml"
  GraphPort:
    import: "assets/ui/templates/port.yaml"
  GraphNode:
    import: "assets/ui/templates/node.yaml"
  GraphWire:
    import: "assets/ui/templates/math/wire.yaml"
  InspectorTitle:
    import: "assets/ui/templates/inspector_title.yaml"
  InspectorField:
    import: "assets/ui/templates/inspector_field.yaml"
  
  # Default Inspector (Fallback)
  DefaultNodeInspector:
    import: "assets/ui/templates/inspector_default.yaml"

  # Math Node Inspectors
  MATH_NODE_VALUE:
    import: "assets/ui/templates/math/value.yaml"
  MATH_NODE_ADD:
    import: "assets/ui/templates/math/add.yaml"
  MATH_NODE_SUB:
    import: "assets/ui/templates/math/sub.yaml"
  MATH_NODE_MUL:
    import: "assets/ui/templates/math/mul.yaml"
  MATH_NODE_SIN:
    import: "assets/ui/templates/math/sin.yaml"
  MATH_NODE_UV:
    import: "assets/ui/templates/math/uv.yaml"

  # Layouts
  PaletteItem:
    import: "assets/ui/templates/palette_item.yaml"
  EditorSidebar:
    import: "assets/ui/templates/sidebar.yaml"

import: "assets/ui/layouts/editor_layout.yaml"

==================================================
FILE START: assets/ui/palette_config.yaml
==================================================
items:
  - label: "Number"
    type: "MATH_NODE_VALUE"

  - label: "Add"
    type: "MATH_NODE_ADD"

  - label: "Subtract"
    type: "MATH_NODE_SUB"

  - label: "Multiply"
    type: "MATH_NODE_MUL"

  - label: "Sine Wave"
    type: "MATH_NODE_SIN"

  - label: "UV Coords"
    type: "MATH_NODE_UV"

  - label: "Time"
    type: "MATH_NODE_TIME"


==================================================
FILE START: assets/ui/templates/inspector_default.yaml
==================================================
type: container
layout:
  type: flex_column
style:
  color: "#26262B"
children:
  - type: instance
    instance: InspectorTitle
  - type: text
    text: "Select a node"
    style:
      color: "#666666"


==================================================
FILE START: assets/ui/templates/inspector_field.yaml
==================================================
type: container
layout:
  type: row
  height: 25
children:
  - type: text
    text: "Value:"
    layout:
      width: 60
    style:
      color: "#AAAAAA"
  - type: text
    bindings:
      - target: "text"
        source: "value"
    style:
      color: "#00FF00"
    on_change: "Graph.Recompile"

==================================================
FILE START: assets/ui/templates/inspector_title.yaml
==================================================
type: text
bindings:
  - target: "text"
    source: "name"
layout:
  height: 30
style:
  color: "#FFFFFF"
  hover_color: "#00FFFF"
  animation_speed: 10
flags: "clickable"

==================================================
FILE START: assets/ui/templates/math/add.yaml
==================================================
type: container
layout:
  type: flex_column
  spacing: 5
children:
  - type: instance
    instance: InspectorTitle
  - type: text
    bindings:
      - target: "text"
        source: "cached_output"
    style:
      color: "#888888"


==================================================
FILE START: assets/ui/templates/math/mul.yaml
==================================================
type: container
layout:
  type: flex_column
  spacing: 5
children:
  - type: instance
    instance: InspectorTitle
  - type: text
    bindings:
      - target: "text"
        source: "cached_output"
    style:
      color: "#888888"


==================================================
FILE START: assets/ui/templates/math/sin.yaml
==================================================
type: container
layout:
  type: flex_column
  spacing: 5
children:
  - type: instance
    instance: InspectorTitle
  - type: text
    bindings:
      - target: "text"
        source: "cached_output"
    style:
      color: "#888888"


==================================================
FILE START: assets/ui/templates/math/sub.yaml
==================================================
type: container
layout:
  type: flex_column
  spacing: 5
children:
  - type: instance
    instance: InspectorTitle
  - type: text
    bindings:
      - target: "text"
        source: "cached_output"
    style:
      color: "#888888"


==================================================
FILE START: assets/ui/templates/math/uv.yaml
==================================================
type: container
layout:
  type: flex_column
  spacing: 5
children:
  - type: instance
    instance: InspectorTitle
  - type: text
    text: "UV Coordinates"
    style:
      color: "#888888"


==================================================
FILE START: assets/ui/templates/math/value.yaml
==================================================
type: container
layout:
  type: flex_column
  spacing: 5
children:
  - type: instance
    instance: InspectorTitle
  - type: instance
    instance: InspectorField


==================================================
FILE START: assets/ui/templates/math/wire.yaml
==================================================
kind: Container
layout:
  type: Canvas
  layer: Normal
  width: 100
  height: 100
style:
  render_mode: Bezier
  color: "0xFF888888"
flags: [ Clickable ]

==================================================
FILE START: assets/ui/templates/node.yaml
==================================================
type: container
layout:
  type: row
  width: -1 # Auto width? implied? Layout struct has default? C parser sets -1 defaults.
  # The original file didn't have width/height, relying on defaults.
flags: "clickable | draggable"
# Bindings stay at root
bindings:
  - target: "layout.x"
    source: "x"
  - target: "layout.y"
    source: "y"
style:
  color: "#00000000" # Transparent wrapper

children:
  # Input Ports (Left)
  - type: container
    layout:
      type: column
      width: 10
      y: 32 # Header offset (Migrated from padding-top)
    collection: "input_ports"
    item_template: "GraphPort"

  # Main Body
  - type: container
    layout:
      type: column
      width: 150
      padding: 5
    style:
      color: "#333333"
    
    children:
      - type: container
        layout:
          height: 25
          padding: 5
        style:
          render_mode: box
          color: "#444444"
        
        children:
          - type: text
            bindings:
              - target: "text"
                source: "name"
            style:
              color: "#FFFFFF"
      - type: instance
        instance: "ValueRow"

  # Output Ports (Right)
  - type: container
    layout:
      type: column
      width: 10
      y: 32 # Header offset
    collection: "output_ports"
    item_template: "GraphPort"


==================================================
FILE START: assets/ui/templates/palette_item.yaml
==================================================
type: container
flags: clickable | focusable
id: palette_item
layout:
  width: -1
  height: 30
  padding: 4
style:
  color: "#5A5A66"
  hover_color: "#6D6D7F"
  corner_radius: 6
on_click: "Graph.AddNode"
children:
  - type: text
    bindings:
      - target: "text"
        source: "label"
    style:
      color: "#FFFFFF"


==================================================
FILE START: assets/ui/templates/port.yaml
==================================================
type: container
layout:
  width: 10
  height: 25
children:
  - type: container
    layout:
      width: 10
      height: 10
      y: 7.5
    style:
      render_mode: box
      corner_radius: 5
      color: "#888888"

==================================================
FILE START: assets/ui/templates/sidebar.yaml
==================================================
type: container
id: left_panel
layout:
  type: flex_column
  width: 250
  height: -1
  padding: 10
  spacing: 5
style:
  color: "#333338"

children:
  - type: text
    text: "Graph Editor"
    layout:
      height: 30
    style:
      color: "#FFFFFF"

  - type: container
    layout:
      type: flex_column
      height: 300
      spacing: 5
      padding: 5
    flags: scrollable
    collection: "palette_items"
    item_template: "PaletteItem"

  - type: container
    layout:
      type: flex_row
      height: 40
      spacing: 5
    children:
        - type: container
          flags: clickable | focusable
          text: "Clear"
          layout:
            padding: 15
            height: 30
          style:
            corner_radius: 8
            color: "#663333"
          on_click: "Graph.Clear"

  - type: text
    text: "Properties"
    layout:
      height: 20
    style:
      color: "#CCCCCC"
    
  - type: container
    layout:
      type: flex_column
      height: -1
      padding: 20
    bindings:
      - target: "visible"
        source: "view.no_selection"
    style:
      color: "#26262B"
    children:
      - type: text
        text: "Select a node to"
        style:
          color: "#666666"
      - type: text
        text: "edit properties"
        style:
          color: "#666666"

  - type: container
    id: inspector_area
    layout:
      type: flex_column
      height: -1 # Fill rest
      padding: 5
    style:
      corner_radius: 4
      color: "#26262B"
    bindings:
      - target: "visible"
        source: "view.has_selection"
    collection: "view.selected_nodes"
    template_selector: "type"
    item_template: "DefaultNodeInspector"


==================================================
FILE START: assets/ui/templates/value_row.yaml
==================================================
type: text
bindings:
  - target: "text"
    source: "value"
layout:
  height: 20
style:
  color: "#CCCCCC"

==================================================
FILE START: docs/architecture.md
==================================================
# The Architecture Guide

**Version:** 0.7.1 (Standardized)
**Date:** December 20, 2025

This document explains **how** the system is built and **why** it is built that way.

---

## 1. The "Layered Cake" Philosophy

The codebase is organized into four strict layers. Dependencies flow **downwards only**.

```mermaid
graph TD
    App[App (src/app)] --> Features[Features (src/features)]
    Features --> Engine[Engine (src/engine)]
    Engine --> Foundation[Foundation (src/foundation)]
```

### ğŸ§± Foundation (`src/foundation/`)
**"The Bedrock"**
Zero-dependency utilities: Memory, Platform, Math, Logger, Config, Reflection.

### âš™ï¸ Engine (`src/engine/`)
**"The Machine"**
Systems for interactive applications: Core, Graphics, Scene, Text, Scene System (UI), Assets.

### ğŸ§© Features (`src/features/`)
**"The Logic"**
Reusable domain-specific modules (e.g., Math Graph Editor).

### ğŸš€ App (`src/app/`)
**"The Glue"**
Entry point (`main.c`). Orchestrates layers.

---

## 2. Interface Standards (The "Public/Internal" Split)

To maintain long-term maintainability and prevent "spaghetti code," we rigidly separate the **Public API** from the **Internal Implementation** using a standardized directory structure.

### ğŸ“‚ Directory Structure Pattern

Every major module (e.g., `src/engine/scene_system`) must follow this exact layout:

```text
src/engine/scene_system/
â”œâ”€â”€ ui_core.h          # [PUBLIC] A public contract. External modules may include this.
â”œâ”€â”€ ui_core.c          # [PRIVATE] Implementation of the public API.
â””â”€â”€ internal/          # [PRIVATE] Hidden from the rest of the codebase.
    â”œâ”€â”€ ui_state.h     # [INTERNAL] Full struct definitions (hidden from public).
    â”œâ”€â”€ ui_layout.h    # [INTERNAL] Internal subsystem interfaces.
    â”œâ”€â”€ ui_layout.c    # [INTERNAL] Internal subsystem implementation.
    â””â”€â”€ ui_renderer.c  # [INTERNAL] Internal subsystem implementation.
```

### ğŸ“ The Golden Rules

#### 0. Language Standard (C11)
The project strictly enforces **C11 (ISO/IEC 9899:2011)**.
*   **Why?** Allows `typedef` redefinition, enabling cleaner opaque pointer APIs without "God Headers".
*   **Pattern:**
    *   **Public API:** Use `typedef struct Name Name;` in headers.
    *   **Function Signatures:** Use `Name*` (not `struct Name*`).
    *   **Forward Declarations:** Repeat `typedef struct Name Name;` in consuming headers (allowed in C11) to avoid `#include` dependencies.

#### 2. Header Guards
*   **Standard:** Strictly use traditional `#ifndef MODULE_NAME_H` / `#define MODULE_NAME_H` guards.
*   **Prohibited:** Do not use `#pragma once` (non-standard).

#### 3. Public Headers (The Module Root)
*   **Purpose:** Defines *what* the module does, not *how*.
*   **Location:** Any `.h` file in the module's root directory (e.g., `src/engine/scene_system/*.h`).
*   **Content:**
    *   **Opaque Handles:** Use `typedef struct MySystem MySystem;` instead of defining the struct. This prevents users from accessing internal state directly.
    *   **Enums/Flags:** Only those required for API arguments.
    *   **API Functions:** High-level functions like `system_create()`, `system_update()`.
*   **Rule:** External modules may include **ANY** header from the module root.

#### 4. The Internal Directory (`internal/`)
*   **Purpose:** Defines *how* the module works.
*   **Content:**
    *   **Full Struct Definitions:** The actual layout of `MySystem`.
    *   **Helper Functions:** Utilities used only within the module.
    *   **Sub-modules:** Complex logic split into smaller files (e.g., `layout`, `parser`).
*   **Access:**
    *   **Strictly Private:** Files in this directory must **NEVER** be included by code outside the module.
    *   **Exception:** White-box tests in `tests/` are allowed to include internal headers to verify complex logic.

#### 3. Include Graph
*   `src/app/main.c` -> `#include "engine/scene_system/ui_core.h"` (âœ… OK)
*   `src/app/main.c` -> `#include "engine/scene_system/internal/ui_layout.h"` (âŒ **VIOLATION**)
*   `src/engine/scene_system/ui_core.c` -> `#include "internal/ui_layout.h"` (âœ… OK)

---

## 3. Core Principles

### ğŸ§  Data-Driven Design
Behavior is defined in data (`manifest.yaml`), not code. The engine essentially acts as an interpreter for this data.

### ğŸª Reflection & Data Binding
*   **Code Generation:** A pre-build step (`tools/codegen.py`) parses C headers and generates `reflection_registry.c`.
*   **Runtime Binding:** UI Elements bind directly to C struct fields by name (e.g., `bind: "value"`).
*   **No Manual Glue:** The UI system reads values via reflection, eliminating the need for manual ViewModel classes.

### ğŸ›¡ Memory Safety
**Zero** `malloc`/`free` in the hot loop.
*   **Arenas:** Linear allocators for frame data.
*   **Pools:** Fixed-block allocators for game objects.

### ğŸ”— Strict Decoupling
Systems communicate via **IDs** (integers) or **Commands**, never raw pointers. This allows systems to be destroyed or reloaded without crashing dependent modules.

### ğŸ‘‘ System Ownership (Singleton Initialization)
The `Engine` core (`src/engine/core`) is the **sole owner** of all subsystems (Renderer, UI, Input).
*   **Rule:** Features (e.g., `src/features/`) must **NEVER** call lifecycle functions like `_init()` or `_shutdown()`.
*   **Registration:** Features may only *register* resources (e.g., UI Commands) or *consume* APIs.
*   **Order:** Initialization occurs strictly in `engine_create()` to guarantee dependency resolution.

---

## 4. Key Architectural Patterns

### ğŸ–¼ Render Packet (Double Buffering)
To decouple Logic from Rendering, the engine uses a **Packet-based Architecture**.
1.  **Logic Step:** The Game/UI constructs a `Scene` (Frame N).
2.  **Submit:** The `Scene` is wrapped in a `RenderFramePacket` and submitted to the RenderSystem.
3.  **Swap:** The RenderSystem swaps the Front/Back buffers.
4.  **Render Step:** The Backend draws the previous frame (Frame N-1) while Logic builds the next one (Frame N+1).
*   *Benefit:* Allows the Logic and Render threads (future) to run in parallel without locking.

### ğŸ§µ Concurrency Model
*   **Main Thread:** Runs the Event Loop, Physics, UI Logic, and builds the Scene.
*   **Render Thread (Virtual):** Currently runs on the Main Thread but is architecturally isolated via the Packet System.
*   **Worker Threads:** Used for heavy I/O operations (e.g., Saving Screenshots, Async Shader Compilation).
*   **Sync:** Systems communicate via Message Queues or Atomic Flags, avoiding complex mutex locking in the hot path.

### ğŸŒ The Unified Scene Strategy
Unlike traditional engines that maintain separate render pipelines for UI (2D) and World (3D), this project employs a **Unified Scene** architecture.
*   **Concept:** Everything is a `SceneObject`. A UI button is just a Quad with a specific shader mode (`SCENE_MODE_SDF_BOX`). A text character is a Quad with a texture (`SCENE_MODE_TEXTURED`).
*   **Data Structure:** All objects reside in a single linear `MemoryArena`.
*   **Rendering:** The `RenderSystem` iterates this single array. This simplifies depth sorting (e.g., 3D objects inside UI frames), reduces draw call overhead, and unifies resource management.

---

## 5. Subsystems Deep Dive

### ğŸ¨ Graphics
*   **Abstractions:** The `RenderSystem` is a high-level manager that consumes `RenderFramePacket`s. It delegates actual API calls to a `RendererBackend` (V-Table).
*   **Vulkan Implementation:**
    *   **Stateless Rendering:** The backend clears and rebuilds command buffers every frame.
    *   **Pipeline Management:** Uses a simplified pipeline cache. Switch between 3D/UI/Compute pipelines based on `SceneObject` state.
    *   **Compute:** Supports runtime SPIR-V creation for procedural geometry visualization.

### ğŸ“¦ Assets
*   **Storage:** Centralized `MemoryArena` for all loaded strings and raw data.
*   **Identity:** Assets are looked up via string paths but hashed to `StringId` for fast comparisons.
*   **Lifecycle:** Currently load-only. Hot-reloading is planned (Phase 6.5).

### ğŸ¬ Scene
*   **Role:** The "Frame Packet". It is a transient snapshot of the world state for a specific frame.
*   **Allocation:** Uses a **Linear Allocator** that is effectively `reset()` at the start of every frame. This eliminates fragmentation and makes object destruction free (O(1)).
*   **Data Layout:** `SceneObject` utilizes **Anonymous Unions** to multiplex memory. A `SceneObject` can hold UI layout data OR PBR material data, keeping the struct size compact (~128 bytes) and cache-friendly.

### ğŸ® Input
*   **Architecture:** Decoupled from windowing events (GLFW).
*   **State:** Maintains `InputState` (current keys) and `InputEventQueue` (buffered actions).
*   **Mapping:** Supports Action Mapping (e.g., "Jump" -> Spacebar) to abstract physical keys from logical actions.

### ğŸ“ Text
*   **Backend:** `stb_truetype` for font parsing and rasterization.
*   **Atlas:** Generates a single texture atlas (R8) for all active glyphs.
*   **Rendering:** Does **not** issue draw calls. Instead, it generates `SceneObject`s (Quads) and pushes them into the active `Scene`.

### ğŸ–¥ï¸ UI
*   **Layout Engine:** A recursive, single-pass solver inspired by Flexbox. Supports `Column`, `Row`, `Canvas`, and `Split` layouts.
*   **Input Handling:** Implements **Event Bubbling**. Input events (click, drag) start at the root and drill down to leaf nodes (hit testing), then bubble up for handling.
*   **Rendering:** Generates `SceneObject`s with specific modes (9-Slice, SDF, Textured). Supports explicit `UiRenderMode` (e.g., `BEZIER`) for custom visualization.
*   **Template-Instance Model:**
    *   **Spec (`UiNodeSpec`):** Immutable "DNA" loaded from YAML. Lives in `UiAsset`.
    *   **Element (`UiElement`):** Live runtime object created from a Spec. Lives in `UiInstance`.
    *   **Usage:** Logic calls `ui_element_create(instance, spec)` to spawn dynamic UI (like Graph Nodes) from static templates.
*   **Data Binding & Collections:**
    *   UI Containers can bind to array collections (e.g., `collection: "wires"`).
    *   This is used to render Graph connections as interactive UI elements (Bezier curves) rather than raw immediate-mode geometry.
*   **Orthogonal Typing:**
    *   **Primitives:** Only `Container` (Rect) and `Text` exist as fundamental Kinds.
    *   **Behavior:** Defined via Flags (`Clickable`, `Editable`, `Draggable`).
    *   *Example:* A "Button" is a `Container` + `UI_FLAG_CLICKABLE`. A "TextField" is `Text` + `UI_FLAG_EDITABLE`.
*   **Hybrid Update Strategy:**
    *   **Retained Structure:** The tree persists across frames (unlike ImGui).
    *   **Partial Rebuilds:** Structural changes (e.g., selecting a new object) trigger `ui_element_rebuild_children` for specific sub-trees.
    *   **Data Binding:** Property changes (text, color) are synced every frame via reflection.

### ğŸ§® Math Engine
*   **Core:** A node-based visual programming language.
*   **Pipeline:**
    1.  **Graph:** Nodes and connections (Logic Model).
    2.  **IR:** Flattened to a linear Bytecode (ShaderIR).
    3.  **Transpiler:** Converts IR to GLSL/SPIR-V.
    4.  **Execution:** Compiles to a Vulkan Compute Pipeline for GPU execution.
*   **Isolation:** Fully decoupled from the main engine. Can be used headless.


==================================================
FILE START: docs/roadmap.md
==================================================
# Project Roadmap

**Current Focus:** Phase 7 - 3D Visualization & Compute
**Date:** December 20, 2025

## ğŸ Current State 0.7.1 (Standardized)

Structural standardization (Phase 6) is largely complete, but critical limitations in the UI module were identified during the Phase 7 kickoff.

### Phase 3: Compositional Scene Architecture (Architectural Pivot)
**Objective:** Transition from a UI-centric generic node to a specialized component-based Scene Graph. This is critical for the "Math Engine" goal to support complex physical simulations and 3D hierarchies without polluting the UI logic.

**3.0. YAML Migration (IMMEDIATE NEXT STEP) - DONE âœ…**
*   [x] **Migrate YAML Assets:** The C code now expects nested components (`layout`, `style`), but YAML files are still flat.
    *   Action: Update all files in `assets/ui/**/*.yaml`.
    *   Example: Move `width: 100` -> `layout: { width: 100 }`, `color: ...` -> `style: { color: ... }`.
    *   Target files: `templates/node.yaml`, `layouts/editor_layout.yaml`, etc.

**3.1. Data Structuring (Refactoring `UiNodeSpec`) - DONE âœ…**
*   [x] **Component Decomposition:** Break the flat `UiNodeSpec` struct into semantic sub-structs:
    *   `SceneTransformSpec` (pos, rot, scale)
    *   `UiLayoutSpec` (width, padding, flex props)
    *   `UiStyleSpec` (colors, borders, effects)
*   [x] **Codebase Migration:** Update `ui_parser.c`, `ui_layout.c`, and `ui_renderer.c` to access data via these sub-structs.
*   [x] **Reflection Update:** `tools/codegen.py` and `ui_parser.c` now handle nested `META_TYPE_STRUCT` recursively.

**3.2. The Unified Scene Graph (Runtime) - DONE âœ…**
*   [x] **Transform System:** Introduce `Mat4 local_matrix` and `Mat4 world_matrix` to the runtime node (formerly `UiElement`).
*   [x] **Scene Node Rename:** (Gradual) Alias `UiElement` to `SceneNode`. *Refactoring completed: struct renamed to SceneNode globally.*
*   [x] **Matrix Propagation:** Implement a pass to update World Matrices (`Parent * Local`) before layout/rendering.
*   [x] **Layout Integration:** Modify the UI Layout solver to output results into the `SceneTransformSpec` or `local_matrix`, bridging the gap between Flexbox (2D) and Scene (3D). *(Implemented in update loop)*

**3.3. 3D Capability Expansion & Renaming**
*   [x] **Refactor: Symbol Renaming:** Align terminology with the new architecture.
    *   `UiAsset` -> `SceneAsset` (Container for SceneSpecs)
    *   `UiInstance` -> `SceneTree` (Runtime container for SceneNodes)
    *   `ui_element_*` -> `scene_node_*`
    *   `ui_renderer_build_scene` -> `scene_builder_build`
*   [x] **Refactor: Module Renaming:** Move `src/engine/ui` -> `src/engine/scene_system`.
*   [x] **Mesh Component:** Add `SceneMeshSpec` (mesh asset id, material params) to the Node Spec.
*   [x] **Renderer Adaptation:** Update `ui_renderer_build_scene` (rename to `scene_builder_build`) to check for `MeshSpec`. If present, emit 3D `SceneObject`s instead of UI Quads.
*   [x] **Binding V2 (Deep Cleanup):** Refactor the Data Binding system to support dot-notation/paths (e.g., `target: "transform.position.x"`).
    *   **Objective:** Remove legacy hardcoded binding fields (`bind_x`, `bind_y`, `bind_w`, `bind_h`, `bind_text`, `bind_visible`) from the root `SceneNodeSpec`.
    *   **Implementation:** The binding system should resolve targets recursively within components (`spec->layout.width`) rather than expecting them at the root.

**3.4. The Great Refactoring: Scene vs. UI Separation (New) - DONE âœ…**
*   [x] **Analysis:** Determine exact ownership of `SceneNode` data. Split "Graph Structure" from "UI Behavior".
*   [x] **Refactor: Scene Core:** Move `SceneNode`, `Transform`, `SceneTree`, and Hierarchy logic into `src/engine/scene`. Make `src/engine/scene` the "Owner of the World".
*   [x] **Refactor: UI Resurrection:** Re-create `src/engine/ui` as a System that operates *on* `SceneNode`s. It handles Layout, Styling, and Input Bubbling.
*   [x] **Cleanup:** Dissolve `src/engine/scene_system`, distributing its contents between `scene` (core) and `ui` (system).

### Phase 3.5: The Great Merge (Scene & UI Unification)
**Objective:** Finalize the decoupling of the Scene System from the UI Module, moving core functionality (Parsing, Bindings) into the Scene Engine.
- [x] **Refactor: Move Parser:** Migrate `ui_parser.c` from `src/engine/ui` to `src/engine/scene/loader`. The Scene Core must be able to load itself without UI dependencies.
- [x] **Refactor: Unify Bindings:** Rename `UiBinding` (runtime) to `SceneBinding` and move it to `src/engine/scene`. Allow any SceneNode property to be bound, not just UI fields.
- [x] **Refactor: Flag Consolidation:** Review `UiFlags` vs `SceneNodeFlags`. Ensure `SceneNode` has a unified flag system where UI-specific flags use reserved bits or a dedicated subsystem mask.
- [x] **Cleanup:** Remove legacy `UiAsset` stubs if they are fully replaced by `SceneAsset`.

### Phase 3.6: Architecture Hardening (Cleanup)
**Objective:** Solidify the foundation after the "Great Merge" of UI and Scene systems. Remove "construction debris" and ensure the engine is truly 3D-ready, not just a UI engine wrapper.
- [x] **Refactor: Loader Decoupling:** Remove UI-specific hardcoding from `scene_loader.c`.
    *   [x] Remove legacy bindings support (`bind_x`, `bind_y`) in favor of the generic `bindings` array.
    *   [x] Remove `parse_flags_smart` and enforce strict reflection-based flag parsing.
    *   [x] Unify structure parsing logic (`parse_struct_fields`) with recursive loader to eliminate duplication.
- [x] **Optimization: Asset Caching:** Implement a global `SceneAssetCache` (Path -> Asset*) to prevent re-parsing the same YAML templates (e.g., ports, nodes) multiple times.

### Phase 3.7: Interaction Architecture (New)
**Objective:** Replace the primitive 2D input system with a robust 3D-aware event architecture. Eliminate "stringly-typed" logic limitations.
- [ ] **3.7.1: Ray-Cast Input System:**
    *   Replace `point_in_rect` with a `SceneRaycaster`.
    *   Implement OBB (Oriented Bounding Box) intersection using `world_matrix` inverse.
    *   Support Layer masking (Block input to World when UI is hovered).
- [ ] **3.7.2: Typed Event Payloads:**
    *   Refactor `UiEvent` to support generic payloads (Variant/Union) instead of just String IDs.
    *   Allow passing data directly from UI to Logic (e.g., `Graph.AddNode(type=ADD, pos={100,100})`).
- [ ] **3.7.3: Focus & Modal Manager:**
    *   Implement a `FocusStack` to handle overlapping windows and popups.
    *   Handle "Click Outside" events automatically for closing modals.
- [ ] **3.7.4: Signal-Slot Data Flow:**
    *   Formalize the observer pattern between `MathGraph` (Logic) and `MathGraphView` (UI).
    *   Eliminate ad-hoc polling in `update()` loops.

### Phase 3.8: Modular Consistency & Hygiene (New) - DONE âœ…
**Objective:** Clean up the file structure to strictly separate Public API (root) from Implementation (internal). Eliminate "dangling" source files in module roots.
- [x] **3.8.1: Scene Module Hygiene:**
    *   [x] Create `scene_system.c` as the root Facade.
    *   [x] Move `scene_tree.c` -> `internal/scene_graph.c` (Tree & Node Logic).
    *   [x] Move `scene.c` (Lifecycle) -> `internal/scene_lifecycle.c`.
    *   [x] Extract Drawing Helpers -> `internal/scene_builder.c` (Included in scene_lifecycle).
- [x] **3.8.2: UI Module Hygiene:**
    *   [x] Refactor `ui_core.c` to be a pure coordinator.
    *   [x] Move `ui_layout.c`, `ui_renderer.c`, `ui_input.c` deeply into `internal/` (already partially done, but needs strict enforcement).
- [x] **3.8.3: Header/Source Parity:**
    *   [x] Enforce rule: Root directory contains ONLY public headers and the main module implementation file.
    *   [x] Verify that including `module.h` does not leak internal symbols.

**4. 3D Interaction & Logic (New)**
*   [ ] **Camera Component:** Implement `SceneCameraSpec` (FOV, type: Ortho/Perspective) to define viewports dynamically within the Scene Graph.
*   [ ] **Input Raycasting:** Extend `ui_input.c` to support Ray-AABB/Ray-Sphere intersection for clicking 3D objects (replacing pure 2D `point_in_rect` for 3D nodes).
*   [ ] **Layout/Transform Arbitration:** Define explicit rules: does Layout write to Transform? Does Transform override Layout? Implement flags (e.g., `SCENE_FLAG_IGNORE_LAYOUT`) to mix UI and 3D freely.

### Phase 4.5: Code Hygiene & Refactoring (Follow-up)
**Objective:** Address technical debt identified during the Viewport implementation to ensure the editor is maintainable and scalable.
- [x] **Refactor: Explicit UI Render Modes:** Replace implicit rendering logic (Text/Texture/SDF guessing) with explicit `UiRenderMode` enum (`Box`, `Text`, `Image`, `Bezier`) in `UiNodeSpec`.
- [x] **Refactor: Split MathEditor:** Decompose `math_editor.c` into `math_editor.c` (Lifecycle/Commands) and `internal/math_editor_view.c` (Rendering/UI Sync).
- [ ] **Refactor: Extract Input Logic:** Move event processing and state machine (Idle, Dragging) into `internal/math_editor_input.c` to clean up the main update loop.
- [ ] **Refactor: Data-Driven Style:** Extract hardcoded layout constants (node width, colors, spacing) into a `MathEditorConfig` struct loaded from YAML.
- [ ] **Refactor: Input State Machine:** Replace ad-hoc boolean flags with a formal FSM (`IDLE`, `DRAGGING_NODE`, `DRAGGING_WIRE`) for robust input handling.
- [ ] **Refactor: Coordinate System:** Implement `GraphViewTransform` to abstract Screen-to-World conversions and prepare for Zoom/Pan, removing manual offset math.
- [ ] **Refactor: Iterative Graph Evaluation:** Replace recursive CPU graph evaluation with a flat topological sort loop.
- [ ] **Test: Math Graph Suite:** Implement unit tests for graph logic (connection, evaluation, cycle detection).

### Phase 5: Stability & Validation (Refinement)
**Objective:** Resolve data-binding warnings and schema inconsistencies found during enhanced logging.
- [ ] **Optimization: Event-Based Evaluation:** Optimize `math_editor_update` to evaluate the graph only when dirty.
- [ ] **Refactor: String Memory Strategy:** Replace temporary leak fixes with Arena-based allocation.
- [ ] **Fix: Sidebar Overflow:** Resolve layout overlap where the "Clear" button covers palette items.
- [ ] **Fix: Dangling Wire Artifact:** Investigate stray wire curve rendering artifacts.
- [ ] **Refactor: Inspector Style:** Style the white placeholder rectangle in Properties.
- [ ] **Feature: UI Z-Order:** Implement Z-indexing logic for nodes.
- [ ] **Refactor: Wire ID Logic:** Replace bit-shifting ID generation with a safer hash-based system.

### Phase 6: Structural Standardization (Refinement)
**Objective:** Address architectural limitations in the UI system to support complex editors.
- [ ] **Optimization:** Optimize Graph CPU evaluation to only recalculate dirty nodes.
- [ ] **Stability:** Implement Graph Cycle Detection to prevent stack overflow crashes on recursive evaluation.
- [ ] **Refactor:** Optimize Input System to use `StringId` instead of `strcmp` in the update loop.
- [ ] **UI Layout:** Implement Flexbox-style properties (`flex-grow`, `justify-content`) for robust responsive layouts.
- [ ] **Dynamic Node Inputs:** Remove `MATH_NODE_MAX_INPUTS` (4) limit. Implement dynamic array support for node inputs to allow variadic nodes (e.g., Sum(A, B, C, D, E)).
- [ ] **Asset Hot-Reloading:** Watch asset files for changes and reload graph/UI automatically without restarting.
- [ ] **Frame Allocator:** Introduce a per-frame temporary memory arena to avoid persistent memory leaks during hot-reloading or temporary parsing.
- [ ] **UI Text Input:** Implement proper UTF-8 support for text fields to handle Cyrillic and special characters.
- [ ] **UI Scrolling & Events:** Add inertia/smoothing to scrolling and use a dynamic event queue to prevent input loss.

### Phase 6.5: Graphics & Pipeline Maturity
**Objective:** Eliminate development shortcuts in the rendering pipeline and enforce strict architecture.
- [ ] **Refactor: MathEditor Separation:** Split `math_editor.c` into `math_editor_view.c` (Rendering) and `math_editor.c` (Logic/Input).
- [ ] **Foundation: String Safety:** Replace manual `strncpy`/`snprintf` with safe foundation wrappers to prevent buffer overflows.
- [ ] **Async Shader Compilation:** Replace blocking `system("glslc ...")` calls with a dedicated thread or library (shaderc) integration to prevent UI freezes.
- [ ] **Non-Blocking Screenshots:** Implement async GPU readback (PBO-style) to avoid `vkQueueWaitIdle` stalls during capture.
- [ ] **Configurable V-Sync:** Expose Swapchain Present Mode configuration (Immediate/FIFO/Mailbox) to the RenderSystem API.
- [ ] **Compute Visualization:** Move the debug Compute Result quad (currently hardcoded in `render_system_update`) to a proper UI Image Panel or Editor Node.
- [ ] **UTF-8 Text Rendering:** Implement UTF-8 decoding in the text renderer loop to support Cyrillic and other multi-byte characters.

The codebase enforces strict Public/Internal API boundaries across all modules. The Math Engine is fully encapsulated, and the foundation is covered by unit tests. The system is now ready for 3D procedural geometry and compute shader integration.

---

## ğŸš€ Active Phases

### Phase 7: 3D Visualization & Compute (DEPENDS ON PHASE 3)
**Objective:** Visualize mathematical functions and data in 3D space.
- [ ] **Procedural Geometry:** Generate meshes from math functions (e.g., $z=f(x,y)$) using Compute Shaders.
- [ ] **Arcball Camera:** Implement an orbit camera for inspecting 3D surfaces.
- [ ] **Compute Particles:** Visualizing vector fields using particle systems.

### Phase 8: Editor & Tooling Maturity
**Objective:** Improve the user experience of the Visual Programming Environment.
- [ ] **Undo/Redo System:** Implement command history for graph operations.
- [ ] **Node Library Expansion:** Add Noise (Perlin/Simplex), Trigonometry, and Logic nodes.
- [ ] **Export System:** Export generated shaders (GLSL/SPIR-V) for external use.


---

## ğŸ›  Technical Debt & Backlog

*   **Shader Hot-Reloading:** Allow editing shaders at runtime without restarting.
*   **API Documentation:** Setup Doxygen or a similar tool to generate up-to-date API documentation from public headers.

==================================================
FILE START: src/app/main.c
==================================================
#include "engine/core/engine.h"
#include "foundation/logger/logger.h"
#include "features/math_engine/math_editor.h"
#include "foundation/config/config_system.h"
#include "engine/graphics/render_system.h"
#include "engine/assets/assets.h"
#include "foundation/memory/arena.h"

#include <string.h>
#include <stdlib.h>

// --- Application Logic ---

static void app_on_init(Engine* engine) {
    // Allocate MathEditor
    MathEditor* editor = math_editor_create(engine);
    if (!editor) {
        LOG_FATAL("Failed to create MathEditor");
        exit(1);
    }
    engine_set_user_data(engine, editor);
}

static void app_on_update(Engine* engine) {
    MathEditor* editor = (MathEditor*)engine_get_user_data(engine);
    if (!editor) return;

    // Update the Editor Feature
    math_editor_update(editor, engine);

    // Render the Editor Feature
    Scene* scene = render_system_get_scene(engine_get_render_system(engine));
    if (scene) {
        math_editor_render(editor, scene, engine_get_assets(engine), engine_get_frame_arena(engine));
    }
}

static void app_on_shutdown(Engine* engine) {
    MathEditor* editor = (MathEditor*)engine_get_user_data(engine);
    if (editor) {
         math_editor_destroy(editor);
    }
}

int main(int argc, char** argv) {
    config_system_load(argc, argv);

    // Parse Log Level
    int log_level = LOG_LEVEL_INFO;
    const char* log_lvl_str = config_get_string("log_level", "info");

    if (strcmp(log_lvl_str, "debug") == 0) log_level = LOG_LEVEL_DEBUG;
    else if (strcmp(log_lvl_str, "trace") == 0) log_level = LOG_LEVEL_TRACE;
    else if (strcmp(log_lvl_str, "warn") == 0) log_level = LOG_LEVEL_WARN;
    else if (strcmp(log_lvl_str, "error") == 0) log_level = LOG_LEVEL_ERROR;
    else if (strcmp(log_lvl_str, "fatal") == 0) log_level = LOG_LEVEL_FATAL;

    EngineConfig config = {
        .width = config_get_int("width", 1280), 
        .height = config_get_int("height", 720), 
        .title = config_get_string("title", "Graphics Engine"),
        .assets_path = config_get_string("assets", "assets"), 
        .ui_path = config_get_string("ui", "assets/ui/editor.yaml"),
        .log_level = log_level,
        .on_init = app_on_init, .on_update = app_on_update
    };
    
    // Log Interval / Screenshot
    float interval = config_get_float("log_interval", 0.0f);
    if (interval > 0.0f) {
         logger_set_trace_interval(interval);
         config.screenshot_interval = (double)interval;
    }

    logger_init("logs/graphics.log");

    Engine* engine = engine_create(&config);
    if (engine) {
        engine_run(engine);
        app_on_shutdown(engine); // Clean up user data
        engine_destroy(engine);
    }
    
    config_system_shutdown();
    logger_shutdown();
    return 0;
}


==================================================
FILE START: src/engine/assets/assets.c
==================================================
#include "engine/assets/assets.h"
#include "engine/assets/internal/assets_internal.h"
#include "engine/graphics/primitives.h"
#include "engine/text/font.h"
#include "foundation/platform/platform.h"
#include "foundation/platform/fs.h"
#include "foundation/logger/logger.h"
#include "foundation/memory/arena.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

AssetData assets_load_file(const Assets* assets, const char* relative_path) {
    AssetData ad = {0};
    if (!assets || !relative_path) return ad;
    
    // Construct full path
    // We use a small temporary buffer on stack, assuming paths are reasonable
    char full_path[512];
    snprintf(full_path, sizeof(full_path), "%s/%s", assets->root_dir, relative_path);
    
    ad.data = fs_read_bin(NULL, full_path, &ad.size);
    if (!ad.data) {
        LOG_ERROR("Assets: Failed to load file '%s'", full_path);
    }
    return ad;
}

void assets_free_file(AssetData* data) {
    if (data && data->data) {
        free(data->data);
        data->data = NULL;
        data->size = 0;
    }
}

bool assets_init_internal(Assets* out_assets, const char* assets_dir) {
    if (!out_assets) return false;

    memset(out_assets, 0, sizeof(*out_assets));

    // Initialize Arena (4KB is likely enough for just paths)
    if (!arena_init(&out_assets->arena, 4096)) {
        LOG_FATAL("Assets: Failed to initialize memory arena.");
        return false;
    }

    out_assets->root_dir = arena_push_string(&out_assets->arena, assets_dir);

    // Create Unit Quad (0,0 to 1,1)
    // De-interleave standardized primitive data
    size_t pos_size = PRIM_QUAD_VERTEX_COUNT * 3 * sizeof(float);
    size_t uv_size = PRIM_QUAD_VERTEX_COUNT * 2 * sizeof(float);
    size_t idx_size = PRIM_QUAD_INDEX_COUNT * sizeof(unsigned int);

    out_assets->unit_quad.positions = (float*)arena_alloc(&out_assets->arena, pos_size);
    out_assets->unit_quad.uvs = (float*)arena_alloc(&out_assets->arena, uv_size);
    out_assets->unit_quad.indices = (unsigned int*)arena_alloc(&out_assets->arena, idx_size);

    if (out_assets->unit_quad.positions && out_assets->unit_quad.uvs && out_assets->unit_quad.indices) {
        for (int i = 0; i < PRIM_QUAD_VERTEX_COUNT; ++i) {
            int src_idx = i * PRIM_VERTEX_STRIDE;
            out_assets->unit_quad.positions[i*3 + 0] = PRIM_QUAD_VERTS[src_idx + 0];
            out_assets->unit_quad.positions[i*3 + 1] = PRIM_QUAD_VERTS[src_idx + 1];
            out_assets->unit_quad.positions[i*3 + 2] = PRIM_QUAD_VERTS[src_idx + 2];
            
            out_assets->unit_quad.uvs[i*2 + 0] = PRIM_QUAD_VERTS[src_idx + 3];
            out_assets->unit_quad.uvs[i*2 + 1] = PRIM_QUAD_VERTS[src_idx + 4];
        }
        memcpy(out_assets->unit_quad.indices, PRIM_QUAD_INDICES, idx_size);
        
        out_assets->unit_quad.position_count = PRIM_QUAD_VERTEX_COUNT * 3;
        out_assets->unit_quad.uv_count = PRIM_QUAD_VERTEX_COUNT * 2;
        out_assets->unit_quad.index_count = PRIM_QUAD_INDEX_COUNT;
    } else {
        LOG_ERROR("Assets: Failed to allocate memory for unit quad.");
    }

    // Load Default Font
    // Note: We use the public API to load the file, but internal field to store it
    AssetData font_data = assets_load_file(out_assets, "fonts/font.ttf");
    if (font_data.data) {
        out_assets->font = font_create(font_data.data, font_data.size);
        if (!out_assets->font) {
            LOG_ERROR("Assets: Failed to create font from 'fonts/font.ttf'");
        }
        assets_free_file(&font_data);
    } else {
        LOG_WARN("Assets: Could not load default font 'fonts/font.ttf'. Text rendering will fail.");
    }

    LOG_INFO("Assets: Initialized with root '%s'", assets_dir);
    return true;
}

SceneAsset* assets_load_scene(Assets* assets, const char* relative_path) {
    if (!assets || !relative_path) return NULL;

    StringId id = str_id(relative_path);

    // 1. Check Cache
    for (size_t i = 0; i < assets->cached_scene_count; ++i) {
        if (assets->cached_scenes[i].path_id == id) {
            return assets->cached_scenes[i].asset;
        }
    }

    // 2. Load
    char full_path[512];
    snprintf(full_path, sizeof(full_path), "%s/%s", assets->root_dir, relative_path);

    SceneAsset* asset = scene_asset_load_from_file(full_path);
    
    // 3. Cache
    if (asset) {
        if (assets->cached_scene_count < MAX_CACHED_SCENES) {
            assets->cached_scenes[assets->cached_scene_count].path_id = id;
            assets->cached_scenes[assets->cached_scene_count].asset = asset;
            assets->cached_scene_count++;
            LOG_TRACE("Assets: Cached scene '%s' (Total: %zu)", relative_path, assets->cached_scene_count);
        } else {
            LOG_WARN("Assets: Cache full, scene '%s' not cached.", relative_path);
        }
    } else {
        LOG_ERROR("Assets: Failed to load scene '%s' (Full path: %s)", relative_path, full_path);
    }

    return asset;
}

Assets* assets_create(const char* assets_dir) {
    Assets* assets = (Assets*)calloc(1, sizeof(Assets));
    if (!assets) return NULL;
    
    if (!assets_init_internal(assets, assets_dir)) {
        free(assets);
        return NULL;
    }
    return assets;
}

void assets_destroy(Assets* assets) {
    if (!assets) return;
    
    if (assets->font) {
        font_destroy(assets->font);
    }
    
    arena_destroy(&assets->arena);
    free(assets);
}

const char* assets_get_root_dir(const Assets* assets) {
    return assets->root_dir;
}

const Mesh* assets_get_unit_quad(const Assets* assets) {
    return &assets->unit_quad;
}

const Font* assets_get_font(const Assets* assets) {
    return assets ? assets->font : NULL;
}


==================================================
FILE START: src/engine/assets/assets.h
==================================================
#ifndef ASSETS_SYSTEM_H
#define ASSETS_SYSTEM_H

#include <stdbool.h>
#include <stddef.h>

typedef struct Assets Assets;
typedef struct Mesh Mesh;
typedef struct Font Font;

typedef struct AssetData {
    void* data;
    size_t size;
} AssetData;

// Public API
Assets* assets_create(const char* assets_dir);
void assets_destroy(Assets* assets);

// Scene Loading (Cached)
// Path is relative to assets root (e.g. "ui/node.yaml")
typedef struct SceneAsset SceneAsset;
SceneAsset* assets_load_scene(Assets* assets, const char* relative_path);

// I/O
AssetData assets_load_file(const Assets* assets, const char* relative_path);
void assets_free_file(AssetData* data);

// Accessors
const char* assets_get_root_dir(const Assets* assets);
const Mesh* assets_get_unit_quad(const Assets* assets);
const Font* assets_get_font(const Assets* assets);

#endif // ASSETS_SYSTEM_H


==================================================
FILE START: src/engine/assets/internal/assets_internal.h
==================================================
#ifndef ASSETS_INTERNAL_H
#define ASSETS_INTERNAL_H

#include "../assets.h"
#include "foundation/memory/arena.h"
#include "foundation/string/string_id.h"
#include "engine/scene/render_packet.h"
#include "engine/scene/scene.h"

#define MAX_CACHED_SCENES 64

typedef struct CachedScene {
    StringId path_id;
    SceneAsset* asset;
} CachedScene;

struct Assets {
    MemoryArena arena; // For storing paths and metadata

    // Resource Paths
    const char* root_dir;
    
    // Built-in Resources
    Mesh unit_quad;
    Font* font;

    // Cache
    CachedScene cached_scenes[MAX_CACHED_SCENES];
    size_t cached_scene_count;
};

#endif // ASSETS_INTERNAL_H


==================================================
FILE START: src/engine/core/engine.c
==================================================
#include "engine/core/engine.h"
#include "foundation/logger/logger.h"
#include "foundation/platform/platform.h"
#include "foundation/platform/fs.h"
#include "foundation/meta/reflection.h"
#include "engine/text/font.h"
#include "foundation/memory/arena.h"
#include "engine/graphics/render_system.h"
#include "engine/assets/assets.h"
#include "engine/input/input.h"
#include "engine/ui/ui_core.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct Engine {
    // Platform
    PlatformWindow* window;
    InputSystem* input_system;

    // Systems
    RenderSystem* render_system;
    Assets* assets;
    
    // Application Data
    void* user_data;
    MemoryArena frame_arena;
    
    // State
    bool running;
    bool show_compute_visualizer;
    EngineConfig config;
    double screenshot_interval;
    double last_screenshot_time;
    double last_time;
    float dt;
    
    // Callbacks
    void (*on_update)(Engine* engine);
};

// --- Input Callbacks ---

static void on_framebuffer_size(PlatformWindow* window, int width, int height, void* user_data) {
    (void)window;
    Engine* engine = (Engine*)user_data;
    if (!engine) return;
    
    if (engine->render_system) {
        render_system_resize(engine->render_system, width, height);
    }
}

Engine* engine_create(const EngineConfig* config) {
    if (!config) return NULL;

    Engine* engine = (Engine*)calloc(1, sizeof(Engine));
    if (!engine) return NULL;

    // Init Frame Arena (16MB)
    if (!arena_init(&engine->frame_arena, 16 * 1024 * 1024)) {
        LOG_FATAL("Failed to initialize Frame Arena.");
        goto cleanup_engine;
    }

    engine->config = *config;

    // Store Callbacks
    engine->on_update = config->on_update;

    // 1. Logger
    logger_set_console_level(config->log_level);
    LOG_INFO("Engine Initializing...");
    
    // 2. Platform & Window
    if (!platform_layer_init()) {
        LOG_FATAL("Failed to initialize platform layer.");
        goto cleanup_frame_arena;
    }
    
    engine->window = platform_create_window(config->width, config->height, config->title);
    if (!engine->window) {
        LOG_FATAL("Failed to create window.");
        goto cleanup_platform;
    }
    
    // Callbacks
    platform_set_window_user_pointer(engine->window, engine);
    // Note: Input callbacks are registered by input_system_init
    platform_set_framebuffer_size_callback(engine->window, on_framebuffer_size, engine);

    // 3. Input System
    engine->input_system = input_system_create(engine->window);
    if (!engine->input_system) {
        LOG_FATAL("Failed to initialize InputSystem.");
        goto cleanup_window;
    }

    // 4. Assets
    engine->assets = assets_create(config->assets_path);
    if (!engine->assets) {
        LOG_FATAL("Failed to initialize assets from '%s'", config->assets_path);
        goto cleanup_input;
    }

    // 5. Render System
    RenderSystemConfig rs_config = {
        .window = engine->window,
        .backend_type = "vulkan"
    };
    engine->render_system = render_system_create(&rs_config);
    if (!engine->render_system) {
        LOG_FATAL("Failed to initialize RenderSystem.");
        goto cleanup_assets;
    }

    // 6. UI System
    ui_system_init();

    // Bindings
    render_system_bind_assets(engine->render_system, engine->assets);
    
    // 7. Application Init Hook (App sets up Graph, UI, binds them to Renderer)
    if (config->on_init) {
        config->on_init(engine);
    }
    
    // Screenshot Init
    engine->screenshot_interval = config->screenshot_interval;
    engine->last_screenshot_time = platform_get_time_ms() / 1000.0;
    
    // Clean old screenshots
    if (engine->screenshot_interval > 0.0) {
        if (!platform_mkdir("logs")) platform_mkdir("logs");
        if (platform_mkdir("logs/screenshots")) {
             // Directory exists or created, clean it
             PlatformDir* dir = platform_dir_open("logs/screenshots");
             if (dir) {
                 PlatformDirEntry entry;
                 while (platform_dir_read(dir, &entry)) {
                     if (!entry.is_dir) {
                         char path[512];
                         snprintf(path, sizeof(path), "logs/screenshots/%s", entry.name);
                         platform_remove_file(path);
                     }
                     free(entry.name);
                 }
                 platform_dir_close(dir);
             }
        }
    }

    engine->running = true;
    return engine;

cleanup_assets:
    assets_destroy(engine->assets);
cleanup_input:
    input_system_destroy(engine->input_system);
cleanup_window:
    platform_destroy_window(engine->window);
cleanup_platform:
    platform_layer_shutdown();
cleanup_frame_arena:
    arena_destroy(&engine->frame_arena);
cleanup_engine:
    free(engine);
    return NULL;
}

void engine_run(Engine* engine) {
    if (!engine) return;

    LOG_INFO("Engine Loop Starting...");
    
    RenderSystem* rs = engine->render_system;
    engine->last_time = platform_get_time_ms() / 1000.0;
    
    while (engine->running && !platform_window_should_close(engine->window)) {
        double now = platform_get_time_ms() / 1000.0;
        engine->dt = (float)(now - engine->last_time);
        engine->last_time = now;

        // Reset Frame Arena
        arena_reset(&engine->frame_arena);
        
        // Auto Screenshot
        if (engine->screenshot_interval > 0.0 && (now - engine->last_screenshot_time) > engine->screenshot_interval) {
            char path[256];
            snprintf(path, sizeof(path), "logs/screenshots/screen_%.3f.png", now);
            LOG_INFO("Requesting screenshot: %s", path);
            render_system_request_screenshot(rs, path);
            engine->last_screenshot_time = now;
        }

        render_system_begin_frame(rs, now);
        
        // Input Update
        input_system_update(engine->input_system);
        
        // Input Poll (Triggers callbacks)
        platform_poll_events();

        // Application Update Hook (App updates Graph, UI Layout, etc.)
        if (engine->on_update) {
            engine->on_update(engine);
        }

        // Render Update
        render_system_update(rs);

        // Draw
        render_system_draw(rs);
    }
}

void engine_destroy(Engine* engine) {
    if (!engine) return;
    
    ui_system_shutdown();
    render_system_destroy(engine->render_system);
    input_system_destroy(engine->input_system);
    assets_destroy(engine->assets);
    
    if (engine->window) {
        platform_destroy_window(engine->window);
    }
    platform_layer_shutdown();
    arena_destroy(&engine->frame_arena);
    free(engine);
}

// --- Accessors ---

RenderSystem* engine_get_render_system(Engine* engine) {
    return engine ? engine->render_system : NULL;
}

InputSystem* engine_get_input_system(Engine* engine) {
    return engine ? engine->input_system : NULL;
}

Assets* engine_get_assets(Engine* engine) {
    return engine ? engine->assets : NULL;
}

PlatformWindow* engine_get_window(Engine* engine) {
    return engine ? engine->window : NULL;
}

MemoryArena* engine_get_frame_arena(Engine* engine) {
    return engine ? &engine->frame_arena : NULL;
}

const EngineConfig* engine_get_config(const Engine* engine) {
    return engine ? &engine->config : NULL;
}

void* engine_get_user_data(const Engine* engine) {
    return engine ? engine->user_data : NULL;
}

void engine_set_user_data(Engine* engine, void* user_data) {
    if (engine) engine->user_data = user_data;
}

float engine_get_dt(const Engine* engine) {
    return engine ? engine->dt : 0.0f;
}

bool engine_is_running(const Engine* engine) {
    return engine ? engine->running : false;
}

void engine_set_show_compute(Engine* engine, bool show) {
    if (engine) engine->show_compute_visualizer = show;
}

bool engine_get_show_compute(const Engine* engine) {
    return engine ? engine->show_compute_visualizer : false;
}


==================================================
FILE START: src/engine/core/engine.h
==================================================
#ifndef ENGINE_H
#define ENGINE_H

#include <stdbool.h>

// Forward Declarations (C11 allows redefinition of typedefs)
typedef struct RenderSystem RenderSystem;
typedef struct Assets Assets;
typedef struct PlatformWindow PlatformWindow;
typedef struct InputSystem InputSystem;
typedef struct MemoryArena MemoryArena;

typedef struct Engine Engine;

typedef struct EngineConfig {
    int width;
    int height;
    const char* title;
    const char* assets_path;
    const char* ui_path;
    int log_level;
    double screenshot_interval;

    // Application Callbacks
    void (*on_init)(Engine* engine);
    void (*on_update)(Engine* engine);
} EngineConfig;

// Lifecycle
Engine* engine_create(const EngineConfig* config);
void engine_run(Engine* engine);
void engine_destroy(Engine* engine);

// Accessors
RenderSystem* engine_get_render_system(Engine* engine);
InputSystem* engine_get_input_system(Engine* engine);
Assets* engine_get_assets(Engine* engine);
PlatformWindow* engine_get_window(Engine* engine);
MemoryArena* engine_get_frame_arena(Engine* engine);
const EngineConfig* engine_get_config(const Engine* engine);

void* engine_get_user_data(const Engine* engine);
void engine_set_user_data(Engine* engine, void* user_data);

float engine_get_dt(const Engine* engine);
bool engine_is_running(const Engine* engine);

void engine_set_show_compute(Engine* engine, bool show);
bool engine_get_show_compute(const Engine* engine);

#endif // ENGINE_H


==================================================
FILE START: src/engine/graphics/internal/render_frame_packet.h
==================================================
#ifndef RENDER_FRAME_PACKET_H
#define RENDER_FRAME_PACKET_H

#include "engine/scene/render_packet.h"

struct RenderFramePacket {
    // The unified scene state for this frame
    Scene* scene;
};
// Wait, I said I would remove the typedef because it's in render_system.h.
// BUT, if this file is included standalone, it needs the typedef?
// 'render_packet.h' seems internal.
// Let's assume it's included where RenderFramePacket is known or we should just use struct.
// Actually, re-reading the error: 'redefinition of typedef RenderFramePacket'.
// So yes, remove typedef.


#endif // RENDER_FRAME_PACKET_H


==================================================
FILE START: src/engine/graphics/internal/renderer_backend.c
==================================================
#include "engine/graphics/internal/renderer_backend.h"
#include <string.h>
#include <stdlib.h>

#define MAX_BACKENDS 8
static RendererBackend* registry[MAX_BACKENDS] = {0};
static int registry_count = 0;

bool renderer_backend_register(RendererBackend* backend) {
    if (!backend || registry_count >= MAX_BACKENDS) return false;
    registry[registry_count++] = backend;
    return true;
}

RendererBackend* renderer_backend_get(const char* id) {
    if (!id) return NULL;
    for (int i = 0; i < registry_count; ++i) {
        if (strcmp(registry[i]->id, id) == 0) {
            return registry[i];
        }
    }
    return NULL;
}

RendererBackend* renderer_backend_default(void) {
    if (registry_count > 0) return registry[0];
    return NULL;
}


==================================================
FILE START: src/engine/graphics/internal/renderer_backend.h
==================================================
#ifndef RENDERER_BACKEND_H
#define RENDERER_BACKEND_H

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

// Forward Declarations
typedef struct PlatformWindow PlatformWindow;
typedef struct PlatformSurface PlatformSurface;
typedef struct Scene Scene;
typedef struct Font Font;

// Backend Initialization Parameters
typedef struct RenderBackendInit {
    PlatformWindow* window;
    PlatformSurface* surface;
    const Font* font;
    
    // Resources (Data Blobs)
    struct {
        const void* data;
        size_t size;
    } vert_shader;
    
    struct {
        const void* data;
        size_t size;
    } frag_shader;
} RenderBackendInit;

// The Abstract Renderer Interface (V-Table)
typedef struct RendererBackend {
    const char* id;
    void* state; // Internal backend state (VulkanRendererState*, WebGpuState*, etc.)

    // Lifecycle
    bool (*init)(struct RendererBackend* backend, const RenderBackendInit* init);
    void (*cleanup)(struct RendererBackend* backend);

    // Core Loop
    void (*render_scene)(struct RendererBackend* backend, const Scene* scene);
    void (*update_viewport)(struct RendererBackend* backend, int width, int height);

    // Utilities
    void (*request_screenshot)(struct RendererBackend* backend, const char* filepath);

    // --- Compute Subsystem ---
    
    // Create a compute pipeline from SPIR-V bytecode.
    // Returns a handle > 0 on success, 0 on failure.
    // 'layout_index' allows selecting pre-defined layouts (0 = Default: Output Image + UBO).
    uint32_t (*compute_pipeline_create)(struct RendererBackend* backend, const void* spirv_code, size_t size, int layout_index);
    
    // Destroy a compute pipeline.
    void (*compute_pipeline_destroy)(struct RendererBackend* backend, uint32_t pipeline_id);
    
    // Dispatch a compute shader.
    // 'work_group_x/y/z': Number of local workgroups.
    // 'push_constants': Pointer to data (max 128 bytes usually).
    // 'push_constants_size': Size of data.
    // The backend handles binding the output image associated with the context or graph.
    void (*compute_dispatch)(struct RendererBackend* backend, uint32_t pipeline_id, uint32_t group_x, uint32_t group_y, uint32_t group_z, void* push_constants, size_t push_constants_size);
    
    // Sync: Wait for compute to finish (memory barrier).
    void (*compute_wait)(struct RendererBackend* backend);

    // Optional: Compile high-level shader source to bytecode
    // Returns true on success. Allocates out_spv (caller must free).
    // stage: "compute", "vertex", "fragment"
    bool (*compile_shader)(struct RendererBackend* backend, const char* source, size_t size, const char* stage, void** out_spv, size_t* out_spv_size);

} RendererBackend;

// Registry / Factory
bool renderer_backend_register(RendererBackend* backend);
RendererBackend* renderer_backend_get(const char* id);
RendererBackend* renderer_backend_default(void);

#endif // RENDERER_BACKEND_H


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_context.c
==================================================
#include "vk_context.h"
#include "vk_utils.h"
#include "foundation/logger/logger.h"
#include <stdio.h>
#include <stdlib.h>

static void log_gpu_info(VkPhysicalDevice dev) {
    VkPhysicalDeviceProperties props;
    vkGetPhysicalDeviceProperties(dev, &props);

    const char* type = "Unknown";
    switch (props.deviceType) {
    case VK_PHYSICAL_DEVICE_TYPE_OTHER: type = "Other"; break;
    case VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU: type = "Integrated"; break;
    case VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU: type = "Discrete"; break;
    case VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU: type = "Virtual"; break;
    case VK_PHYSICAL_DEVICE_TYPE_CPU: type = "CPU"; break;
    default: break;
    }

    LOG_INFO("Using GPU: %s (%s) vendor=0x%04x device=0x%04x driver=0x%x api=%u.%u.%u",
           props.deviceName,
           type,
           props.vendorID,
           props.deviceID,
           props.driverVersion,
           VK_VERSION_MAJOR(props.apiVersion),
           VK_VERSION_MINOR(props.apiVersion),
           VK_VERSION_PATCH(props.apiVersion));
}

void vk_create_instance(VulkanRendererState* state) {
    VkApplicationInfo ai = { .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO, .pApplicationName = "vk_gui", .apiVersion = VK_API_VERSION_1_0 };
    VkInstanceCreateInfo ici = { .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO, .pApplicationInfo = &ai };
    
    /* request platform extensions */
    uint32_t extc = 0; 
    const char** exts = NULL;
    if (!platform_get_required_extensions(&exts, &extc)) {
        LOG_FATAL("Failed to query platform Vulkan extensions");
    }
    ici.enabledExtensionCount = extc; 
    ici.ppEnabledExtensionNames = exts;
    
    state->res = vkCreateInstance(&ici, NULL, &state->instance);
    LOG_TRACE("vkCreateInstance (application)");
    
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateInstance", state->res);
}

void vk_pick_physical_and_create_device(VulkanRendererState* state) {
    uint32_t pc = 0; 
    vkEnumeratePhysicalDevices(state->instance, &pc, NULL); 
    if (pc == 0) { LOG_FATAL("No physical dev"); return; }
    
    VkPhysicalDevice* list = (VkPhysicalDevice*)malloc(sizeof(VkPhysicalDevice) * pc); 
    vkEnumeratePhysicalDevices(state->instance, &pc, list);
    
    VkPhysicalDevice best_device = VK_NULL_HANDLE;
    int best_score = -1;

    for (uint32_t i = 0; i < pc; i++) {
        VkPhysicalDeviceProperties props;
        vkGetPhysicalDeviceProperties(list[i], &props);
        
        int score = 0;
        if (props.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU) score = 1000;
        else if (props.deviceType == VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU) score = 100;
        else if (props.deviceType == VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU) score = 50;
        else if (props.deviceType == VK_PHYSICAL_DEVICE_TYPE_CPU) score = 1;

        LOG_DEBUG("Candidate GPU [%u]: %s (Score: %d)", i, props.deviceName, score);
        
        if (score > best_score) {
            best_score = score;
            best_device = list[i];
        }
    }
    state->physical_device = best_device;
    free((void*)list);

    log_gpu_info(state->physical_device);

    /* find queue family with graphics + present */
    uint32_t qcount = 0; 
    vkGetPhysicalDeviceQueueFamilyProperties(state->physical_device, &qcount, NULL);
    VkQueueFamilyProperties* qprops = malloc(sizeof(VkQueueFamilyProperties) * qcount); 
    vkGetPhysicalDeviceQueueFamilyProperties(state->physical_device, &qcount, qprops);
    
    int found = -1;
    for (uint32_t i = 0; i < qcount; i++) {
        VkBool32 pres = false; 
        vkGetPhysicalDeviceSurfaceSupportKHR(state->physical_device, i, state->surface, &pres);
        if ((qprops[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) && pres) { found = (int)i; break; }
    }
    free(qprops);

    if (found < 0) LOG_FATAL("No suitable queue family");
    state->graphics_family = (uint32_t)found;

    float prio = 1.0f;
    VkDeviceQueueCreateInfo qci = { .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO, .queueFamilyIndex = state->graphics_family, .queueCount = 1, .pQueuePriorities = &prio };
    const char* dev_ext[] = { VK_KHR_SWAPCHAIN_EXTENSION_NAME };
    VkDeviceCreateInfo dci = { .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, .queueCreateInfoCount = 1, .pQueueCreateInfos = &qci, .enabledExtensionCount = 1, .ppEnabledExtensionNames = dev_ext };
    
    state->res = vkCreateDevice(state->physical_device, &dci, NULL, &state->device);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateDevice", state->res);
    
    vkGetDeviceQueue(state->device, state->graphics_family, 0, &state->queue);
}

void vk_recreate_instance_and_surface(VulkanRendererState* state) {
    if (state->platform_surface && state->instance) {
        platform_destroy_surface(state->instance, NULL, state->platform_surface);
    } else if (state->surface && state->instance) {
        vkDestroySurfaceKHR(state->instance, state->surface, NULL);
    }
    state->surface = VK_NULL_HANDLE;
    if (state->instance) { 
        vkDestroyInstance(state->instance, NULL); 
        state->instance = VK_NULL_HANDLE; 
    }

    vk_create_instance(state);
    
    if (!state->platform_surface ||
        !platform_create_surface(state->window, state->instance, NULL, state->platform_surface)) {
        LOG_FATAL("Failed to recreate platform surface");
    }
    state->surface = (VkSurfaceKHR)(state->platform_surface ? state->platform_surface->handle : NULL);
}


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_context.h
==================================================
#ifndef VK_CONTEXT_H
#define VK_CONTEXT_H

#include "vk_types.h"

void vk_create_instance(VulkanRendererState* state);
void vk_pick_physical_and_create_device(VulkanRendererState* state);
void vk_recreate_instance_and_surface(VulkanRendererState* state);

#endif // VK_CONTEXT_H


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_pipeline.c
==================================================
#include "vk_pipeline.h"
#include "vk_utils.h"
#include "foundation/logger/logger.h"
#include <stdlib.h>
#include <stddef.h>

static VkShaderModule create_shader_module(VulkanRendererState* state, const uint32_t* code, size_t size) {
    if (!code || size == 0) {
        LOG_FATAL("Shader code is empty/null");
        return VK_NULL_HANDLE;
    }
    
    VkShaderModuleCreateInfo ci = { 
        .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        .codeSize = size,
        .pCode = code
    };
    
    VkShaderModule mod; 
    state->res = vkCreateShaderModule(state->device, &ci, NULL, &mod);
    if (state->res != VK_SUCCESS) {
        LOG_FATAL("vkCreateShaderModule failed: %d", state->res);
    }
    return mod;
}

void vk_create_descriptor_layout(VulkanRendererState* state) {
    // Set 0: Texture Sampler
    VkDescriptorSetLayoutBinding binding0 = { 
        .binding = 0, 
        .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 
        .descriptorCount = 1, 
        .stageFlags = VK_SHADER_STAGE_FRAGMENT_BIT 
    };
    VkDescriptorSetLayoutCreateInfo lci0 = { 
        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, 
        .bindingCount = 1, 
        .pBindings = &binding0 
    };
    state->res = vkCreateDescriptorSetLayout(state->device, &lci0, NULL, &state->descriptor_layout);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateDescriptorSetLayout (Set 0)", state->res);
    
    // Set 1: Instance Buffer (SSBO)
    VkDescriptorSetLayoutBinding binding1 = { 
        .binding = 0, 
        .descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 
        .descriptorCount = 1, 
        .stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT
    };
    VkDescriptorSetLayoutCreateInfo lci1 = { 
        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO, 
        .bindingCount = 1, 
        .pBindings = &binding1 
    };
    state->res = vkCreateDescriptorSetLayout(state->device, &lci1, NULL, &state->instance_layout);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateDescriptorSetLayout (Set 1)", state->res);

    // Compute Layout: Set 0 = Storage Image (Write)
    VkDescriptorSetLayoutBinding bindingC = {
        .binding = 0,
        .descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE,
        .descriptorCount = 1,
        .stageFlags = VK_SHADER_STAGE_COMPUTE_BIT
    };
    VkDescriptorSetLayoutCreateInfo lciC = {
        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO,
        .bindingCount = 1,
        .pBindings = &bindingC
    };
    state->res = vkCreateDescriptorSetLayout(state->device, &lciC, NULL, &state->compute_write_layout);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateDescriptorSetLayout (Compute)", state->res);
}

VkResult vk_create_compute_pipeline_shader(VulkanRendererState* state, const uint32_t* code, size_t size, int layout_idx, VkPipeline* out_pipeline, VkPipelineLayout* out_layout) {
    (void)layout_idx; // Unused for now
    // 1. Create Shader Module
    VkShaderModuleCreateInfo ci = { 
        .sType = VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO,
        .codeSize = size,
        .pCode = code
    };
    VkShaderModule mod;
    VkResult res = vkCreateShaderModule(state->device, &ci, NULL, &mod);
    if (res != VK_SUCCESS) return res;

    // 2. Create Layout
    // For now, layout_idx is ignored and we always use the default:
    // Set 0: Compute Write (Storage Image)
    // Push Constants: 128 bytes
    
    VkPushConstantRange pcr = { 
        .stageFlags = VK_SHADER_STAGE_COMPUTE_BIT, 
        .offset = 0, 
        .size = 128 
    };
    
    VkPipelineLayoutCreateInfo plci = { 
        .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, 
        .setLayoutCount = 1, 
        .pSetLayouts = &state->compute_write_layout, 
        .pushConstantRangeCount = 1, 
        .pPushConstantRanges = &pcr 
    };
    
    res = vkCreatePipelineLayout(state->device, &plci, NULL, out_layout);
    if (res != VK_SUCCESS) {
        vkDestroyShaderModule(state->device, mod, NULL);
        return res;
    }

    // 3. Create Pipeline
    VkPipelineShaderStageCreateInfo stage = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO,
        .stage = VK_SHADER_STAGE_COMPUTE_BIT,
        .module = mod,
        .pName = "main"
    };

    VkComputePipelineCreateInfo cpci = {
        .sType = VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO,
        .stage = stage,
        .layout = *out_layout
    };
    
    res = vkCreateComputePipelines(state->device, VK_NULL_HANDLE, 1, &cpci, NULL, out_pipeline);
    
    // Module can be destroyed after pipeline creation
    vkDestroyShaderModule(state->device, mod, NULL);
    
    if (res != VK_SUCCESS) {
        vkDestroyPipelineLayout(state->device, *out_layout, NULL);
    }
    
    return res;
}

void vk_create_pipeline(VulkanRendererState* state) {
    VkShaderModule vs = create_shader_module(state, state->vert_shader_src.code, state->vert_shader_src.size);
    VkShaderModule fs = create_shader_module(state, state->frag_shader_src.code, state->frag_shader_src.size);
    
    // ... (stages, vertex input) ...
    VkPipelineShaderStageCreateInfo stages[2] = {
        {.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, .stage = VK_SHADER_STAGE_VERTEX_BIT, .module = vs, .pName = "main" },
        {.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO, .stage = VK_SHADER_STAGE_FRAGMENT_BIT, .module = fs, .pName = "main" }
    };
    
    // Stride = 20 bytes (5 floats)
    VkVertexInputBindingDescription bind = { .binding = 0, .stride = 5 * sizeof(float), .inputRate = VK_VERTEX_INPUT_RATE_VERTEX };
    
    VkVertexInputAttributeDescription attr[2] = {
        {.location = 0, .binding = 0, .format = VK_FORMAT_R32G32B32_SFLOAT, .offset = 0 },
        {.location = 1, .binding = 0, .format = VK_FORMAT_R32G32_SFLOAT, .offset = 3 * sizeof(float) }
    };
    
    VkPipelineVertexInputStateCreateInfo vxi = { 
        .sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO, 
        .vertexBindingDescriptionCount = 1, 
        .pVertexBindingDescriptions = &bind, 
        .vertexAttributeDescriptionCount = 2, 
        .pVertexAttributeDescriptions = attr 
    };

    VkPipelineInputAssemblyStateCreateInfo ia = { .sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO, .topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST };
    
    float viewport_w = (state->swapchain_extent.width == 0) ? 1.0f : (float)state->swapchain_extent.width;
    float viewport_h = (state->swapchain_extent.height == 0) ? 1.0f : (float)state->swapchain_extent.height;
    
    VkViewport vp = { .x = 0, .y = 0, .width = viewport_w, .height = viewport_h, .minDepth = 0.0f, .maxDepth = 1.0f };
    VkRect2D sc = { .offset = {0,0}, .extent = state->swapchain_extent };
    VkPipelineViewportStateCreateInfo vpci = { .sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO, .viewportCount = 1, .pViewports = &vp, .scissorCount = 1, .pScissors = &sc };
    
    VkPipelineRasterizationStateCreateInfo rs = { .sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO, .polygonMode = VK_POLYGON_MODE_FILL, .cullMode = VK_CULL_MODE_NONE, .frontFace = VK_FRONT_FACE_CLOCKWISE, .lineWidth = 1.0f };
    VkPipelineMultisampleStateCreateInfo ms = { .sType = VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO, .rasterizationSamples = VK_SAMPLE_COUNT_1_BIT };
    
    VkPipelineDepthStencilStateCreateInfo ds = {
        .sType = VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO,
        .depthTestEnable = VK_TRUE,
        .depthWriteEnable = VK_TRUE,
        .depthCompareOp = VK_COMPARE_OP_LESS_OR_EQUAL,
        .depthBoundsTestEnable = VK_FALSE,
        .stencilTestEnable = VK_FALSE
    };
    
    VkPipelineColorBlendAttachmentState cbatt = { 
        .blendEnable = state->swapchain_supports_blend, 
        .srcColorBlendFactor = VK_BLEND_FACTOR_SRC_ALPHA, 
        .dstColorBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA, 
        .colorBlendOp = VK_BLEND_OP_ADD, 
        .srcAlphaBlendFactor = VK_BLEND_FACTOR_ONE, 
        .dstAlphaBlendFactor = VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA, 
        .alphaBlendOp = VK_BLEND_OP_ADD, 
        .colorWriteMask = VK_COLOR_COMPONENT_R_BIT | VK_COLOR_COMPONENT_G_BIT | VK_COLOR_COMPONENT_B_BIT | VK_COLOR_COMPONENT_A_BIT 
    };
    VkPipelineColorBlendStateCreateInfo cb = { .sType = VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO, .attachmentCount = 1, .pAttachments = &cbatt };
    
    // Unified Push Constants: view_proj only (64 bytes)
    VkPushConstantRange pcr = { .stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT, .offset = 0, .size = 64 };
    
    // Layouts: Set 0 (Tex), Set 1 (Inst), Set 2 (User Tex)
    VkDescriptorSetLayout layouts[] = { state->descriptor_layout, state->instance_layout, state->descriptor_layout };
    
    VkPipelineLayoutCreateInfo plci = { .sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO, .setLayoutCount = 3, .pSetLayouts = layouts, .pushConstantRangeCount = 1, .pPushConstantRanges = &pcr };
    
    state->res = vkCreatePipelineLayout(state->device, &plci, NULL, &state->pipeline_layout);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreatePipelineLayout", state->res);
    
    VkGraphicsPipelineCreateInfo gpci = { 
        .sType = VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO, 
        .stageCount = 2, 
        .pStages = stages, 
        .pVertexInputState = &vxi, 
        .pInputAssemblyState = &ia, 
        .pViewportState = &vpci, 
        .pRasterizationState = &rs, 
        .pMultisampleState = &ms, 
        .pDepthStencilState = &ds, 
        .pColorBlendState = &cb, 
        .layout = state->pipeline_layout, 
        .renderPass = state->render_pass, 
        .subpass = 0 
    };
    
    state->res = vkCreateGraphicsPipelines(state->device, VK_NULL_HANDLE, 1, &gpci, NULL, &state->pipeline);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateGraphicsPipelines", state->res);
    
    vkDestroyShaderModule(state->device, vs, NULL); 
    vkDestroyShaderModule(state->device, fs, NULL);
}


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_pipeline.h
==================================================
#ifndef VK_PIPELINE_H
#define VK_PIPELINE_H

#include "vk_types.h"

void vk_create_descriptor_layout(VulkanRendererState* state);
void vk_create_pipeline(VulkanRendererState* state);

VkResult vk_create_compute_pipeline_shader(VulkanRendererState* state, const uint32_t* code, size_t size, int layout_idx, VkPipeline* out_pipeline, VkPipelineLayout* out_layout);

#endif // VK_PIPELINE_H


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_resources.c
==================================================
#include "vk_resources.h"
#include "vk_swapchain.h"
#include "vk_utils.h"
#include "foundation/logger/logger.h"
#include "engine/text/font.h" // Include Font Module
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>

// ... (previous functions unchanged)

void vk_create_buffer(VulkanRendererState* state, VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags props, VkBuffer* out_buf, VkDeviceMemory* out_mem) {
    VkBufferCreateInfo bci = { .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, .size = size, .usage = usage, .sharingMode = VK_SHARING_MODE_EXCLUSIVE };
    state->res = vkCreateBuffer(state->device, &bci, NULL, out_buf);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateBuffer", state->res);
    VkMemoryRequirements mr; vkGetBufferMemoryRequirements(state->device, *out_buf, &mr);
    VkMemoryAllocateInfo mai = { .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, .allocationSize = mr.size, .memoryTypeIndex = find_mem_type(state->physical_device, mr.memoryTypeBits, props) };
    state->res = vkAllocateMemory(state->device, &mai, NULL, out_mem);
    if (state->res != VK_SUCCESS) fatal_vk("vkAllocateMemory", state->res);
    vkBindBufferMemory(state->device, *out_buf, *out_mem, 0);
}

static VkCommandBuffer begin_single_time_commands(VulkanRendererState* state) {
    VkCommandBufferAllocateInfo ai = { .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, .commandPool = state->cmdpool, .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY, .commandBufferCount = 1 };
    VkCommandBuffer cb;
    vkAllocateCommandBuffers(state->device, &ai, &cb);
    VkCommandBufferBeginInfo bi = { .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO, .flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT };
    vkBeginCommandBuffer(cb, &bi);
    return cb;
}

static void end_single_time_commands(VulkanRendererState* state, VkCommandBuffer cb) {
    vkEndCommandBuffer(cb);
    VkSubmitInfo si = { .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO, .commandBufferCount = 1, .pCommandBuffers = &cb };
    vkQueueSubmit(state->queue, 1, &si, VK_NULL_HANDLE);
    vkQueueWaitIdle(state->queue);
    vkFreeCommandBuffers(state->device, state->cmdpool, 1, &cb);
}

static void transition_image_layout(VulkanRendererState* state, VkImage image, VkImageLayout oldLayout, VkImageLayout newLayout) {
    VkCommandBuffer cb = begin_single_time_commands(state);
    VkImageMemoryBarrier barrier = { .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER, .oldLayout = oldLayout, .newLayout = newLayout, .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED, .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED, .image = image, .subresourceRange = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 } };
    VkPipelineStageFlags src_stage = VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT;
    VkPipelineStageFlags dst_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
    if (oldLayout == VK_IMAGE_LAYOUT_UNDEFINED && newLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) {
        barrier.srcAccessMask = 0;
        barrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        dst_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
    }
    else if (oldLayout == VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL && newLayout == VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL) {
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;
        barrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;
        src_stage = VK_PIPELINE_STAGE_TRANSFER_BIT;
        dst_stage = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT;
    }
    vkCmdPipelineBarrier(cb, src_stage, dst_stage, 0, 0, NULL, 0, NULL, 1, &barrier);
    end_single_time_commands(state, cb);
}

static void copy_buffer_to_image(VulkanRendererState* state, VkBuffer buffer, VkImage image, uint32_t width, uint32_t height) {
    VkCommandBuffer cb = begin_single_time_commands(state);
    VkBufferImageCopy copy = { .bufferOffset = 0, .bufferRowLength = 0, .bufferImageHeight = 0, .imageSubresource = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .mipLevel = 0, .baseArrayLayer = 0, .layerCount = 1 }, .imageOffset = {0,0,0}, .imageExtent = { width, height, 1 } };
    vkCmdCopyBufferToImage(cb, buffer, image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &copy);
    end_single_time_commands(state, cb);
}

bool vk_create_vertex_buffer(VulkanRendererState* state, FrameResources *frame, size_t bytes) {
    if (frame->vertex_buffer != VK_NULL_HANDLE && frame->vertex_capacity >= bytes) {
        return true;
    }

    if (frame->vertex_buffer) {
        vkDestroyBuffer(state->device, frame->vertex_buffer, NULL);
        frame->vertex_buffer = VK_NULL_HANDLE;
    }
    if (frame->vertex_memory) {
        vkFreeMemory(state->device, frame->vertex_memory, NULL);
        frame->vertex_memory = VK_NULL_HANDLE;
        frame->vertex_capacity = 0;
    }

    VkBuffer new_buffer = VK_NULL_HANDLE;
    VkDeviceMemory new_memory = VK_NULL_HANDLE;
    VkBufferCreateInfo bci = { .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO, .size = bytes, .usage = VK_BUFFER_USAGE_VERTEX_BUFFER_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT, .sharingMode = VK_SHARING_MODE_EXCLUSIVE };
    
    VkResult create = vkCreateBuffer(state->device, &bci, NULL, &new_buffer);
    if (create != VK_SUCCESS) {
        LOG_ERROR("vkCreateBuffer failed for vertex buffer");
        return false;
    }

    VkMemoryRequirements mr; vkGetBufferMemoryRequirements(state->device, new_buffer, &mr);
    VkMemoryAllocateInfo mai = { .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, .allocationSize = mr.size, .memoryTypeIndex = find_mem_type(state->physical_device, mr.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) };
    
    VkResult alloc = vkAllocateMemory(state->device, &mai, NULL, &new_memory);
    if (alloc != VK_SUCCESS) {
        LOG_ERROR("vkAllocateMemory failed for vertex buffer");
        vkDestroyBuffer(state->device, new_buffer, NULL);
        return false;
    }

    vkBindBufferMemory(state->device, new_buffer, new_memory, 0);
    frame->vertex_buffer = new_buffer;
    frame->vertex_memory = new_memory;
    frame->vertex_capacity = bytes;
    return true;
}

void vk_create_font_texture(VulkanRendererState* state) {
    int width, height;
    unsigned char* pixels;
    font_get_atlas_data(state->font, &width, &height, &pixels);

    if (!pixels) {
        LOG_FATAL("Font atlas not available from Font Module");
        return;
    }

    VkImageCreateInfo ici = { .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, .imageType = VK_IMAGE_TYPE_2D, .format = VK_FORMAT_R8_UNORM, .extent = { (uint32_t)width, (uint32_t)height, 1 }, .mipLevels = 1, .arrayLayers = 1, .samples = VK_SAMPLE_COUNT_1_BIT, .tiling = VK_IMAGE_TILING_OPTIMAL, .usage = VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT, .sharingMode = VK_SHARING_MODE_EXCLUSIVE, .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED }; 
    state->res = vkCreateImage(state->device, &ici, NULL, &state->font_image);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateImage", state->res);
    VkMemoryRequirements mr; vkGetImageMemoryRequirements(state->device, state->font_image, &mr);
    VkMemoryAllocateInfo mai = { .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, .allocationSize = mr.size, .memoryTypeIndex = find_mem_type(state->physical_device, mr.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) };
    state->res = vkAllocateMemory(state->device, &mai, NULL, &state->font_image_mem);
    if (state->res != VK_SUCCESS) fatal_vk("vkAllocateMemory", state->res);
    vkBindImageMemory(state->device, state->font_image, state->font_image_mem, 0);

    VkBuffer staging = VK_NULL_HANDLE; VkDeviceMemory staging_mem = VK_NULL_HANDLE;
    vk_create_buffer(state, width * height, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, &staging, &staging_mem);
    void* mapped = NULL; vkMapMemory(state->device, staging_mem, 0, VK_WHOLE_SIZE, 0, &mapped); memcpy(mapped, pixels, width * height); vkUnmapMemory(state->device, staging_mem);

    transition_image_layout(state, state->font_image, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
    copy_buffer_to_image(state, staging, state->font_image, (uint32_t)width, (uint32_t)height);
    transition_image_layout(state, state->font_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);

    vkDestroyBuffer(state->device, staging, NULL);
    vkFreeMemory(state->device, staging_mem, NULL);

    VkImageViewCreateInfo ivci = { .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, .image = state->font_image, .viewType = VK_IMAGE_VIEW_TYPE_2D, .format = VK_FORMAT_R8_UNORM, .subresourceRange = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 } };
    state->res = vkCreateImageView(state->device, &ivci, NULL, &state->font_image_view);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateImageView", state->res);

    VkSamplerCreateInfo sci = { .sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO, .magFilter = VK_FILTER_LINEAR, .minFilter = VK_FILTER_LINEAR, .addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, .addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, .addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE, .borderColor = VK_BORDER_COLOR_INT_OPAQUE_BLACK, .unnormalizedCoordinates = VK_FALSE, .mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST };
    state->res = vkCreateSampler(state->device, &sci, NULL, &state->font_sampler);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateSampler", state->res);
}

void vk_create_descriptor_pool_and_set(VulkanRendererState* state) {
    VkDescriptorPoolSize pools[] = {
        { .type = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, .descriptorCount = 16 },
        { .type = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, .descriptorCount = 16 },
        { .type = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, .descriptorCount = 16 }
    };
    VkDescriptorPoolCreateInfo dpci = { 
        .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO, 
        .maxSets = 16, 
        .poolSizeCount = 3, 
        .pPoolSizes = pools 
    };
    state->res = vkCreateDescriptorPool(state->device, &dpci, NULL, &state->descriptor_pool);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateDescriptorPool", state->res);

    // Set 0: Texture
    VkDescriptorSetAllocateInfo dsai0 = { .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, .descriptorPool = state->descriptor_pool, .descriptorSetCount = 1, .pSetLayouts = &state->descriptor_layout };
    state->res = vkAllocateDescriptorSets(state->device, &dsai0, &state->descriptor_set);
    if (state->res != VK_SUCCESS) fatal_vk("vkAllocateDescriptorSets (Set 0)", state->res);

    VkDescriptorImageInfo dii = { .sampler = state->font_sampler, .imageView = state->font_image_view, .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL };
    VkWriteDescriptorSet w0 = { .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, .dstSet = state->descriptor_set, .dstBinding = 0, .descriptorCount = 1, .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, .pImageInfo = &dii };
    vkUpdateDescriptorSets(state->device, 1, &w0, 0, NULL);
    
    // Set 1: Instance Buffer
    // Note: Instance Set is allocated per-frame (Double Buffered) in vulkan_renderer.c
    // We only create the layout here (which is done in vk_create_descriptor_layout, not here).
    // Here we just skip Set 1 allocation.
    
    // Set 2: User Texture (Compute Target)
    VkDescriptorSetAllocateInfo dsai2 = { .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, .descriptorPool = state->descriptor_pool, .descriptorSetCount = 1, .pSetLayouts = &state->descriptor_layout }; // Same layout as Set 0
    state->res = vkAllocateDescriptorSets(state->device, &dsai2, &state->compute_target_descriptor);
    if (state->res != VK_SUCCESS) fatal_vk("vkAllocateDescriptorSets (Set 2)", state->res);
    
    // Set 0 (Compute): Write Target
    VkDescriptorSetAllocateInfo dsaiC = { .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO, .descriptorPool = state->descriptor_pool, .descriptorSetCount = 1, .pSetLayouts = &state->compute_write_layout };
    state->res = vkAllocateDescriptorSets(state->device, &dsaiC, &state->compute_write_descriptor);
    if (state->res != VK_SUCCESS) fatal_vk("vkAllocateDescriptorSets (Compute Write)", state->res);

    // Bind placeholder (font) initially so it's valid
    VkDescriptorImageInfo dii2 = { .sampler = state->font_sampler, .imageView = state->font_image_view, .imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL };
    VkWriteDescriptorSet w2 = { .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, .dstSet = state->compute_target_descriptor, .dstBinding = 0, .descriptorCount = 1, .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, .pImageInfo = &dii2 };
    vkUpdateDescriptorSets(state->device, 1, &w2, 0, NULL);
}

void vk_ensure_compute_target(VulkanRendererState* state, int width, int height) {
    if (state->compute_width == width && state->compute_height == height && state->compute_target_image) return;

    // Cleanup old
    if (state->compute_target_view) { vkDestroyImageView(state->device, state->compute_target_view, NULL); state->compute_target_view = VK_NULL_HANDLE; }
    if (state->compute_target_image) { vkDestroyImage(state->device, state->compute_target_image, NULL); state->compute_target_image = VK_NULL_HANDLE; }
    if (state->compute_target_memory) { vkFreeMemory(state->device, state->compute_target_memory, NULL); state->compute_target_memory = VK_NULL_HANDLE; }

    if (width <= 0 || height <= 0) return;

    state->compute_width = width;
    state->compute_height = height;

    VkImageCreateInfo ici = { 
        .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO, 
        .imageType = VK_IMAGE_TYPE_2D, 
        .format = VK_FORMAT_R8G8B8A8_UNORM, // Standard RGBA
        .extent = { (uint32_t)width, (uint32_t)height, 1 }, 
        .mipLevels = 1, 
        .arrayLayers = 1, 
        .samples = VK_SAMPLE_COUNT_1_BIT, 
        .tiling = VK_IMAGE_TILING_OPTIMAL, 
        .usage = VK_IMAGE_USAGE_STORAGE_BIT | VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT, // Storage + Sampled
        .sharingMode = VK_SHARING_MODE_EXCLUSIVE, 
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED 
    }; 
    
    state->res = vkCreateImage(state->device, &ici, NULL, &state->compute_target_image);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateImage (compute)", state->res);

    VkMemoryRequirements mr; vkGetImageMemoryRequirements(state->device, state->compute_target_image, &mr);
    VkMemoryAllocateInfo mai = { .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, .allocationSize = mr.size, .memoryTypeIndex = find_mem_type(state->physical_device, mr.memoryTypeBits, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT) };
    state->res = vkAllocateMemory(state->device, &mai, NULL, &state->compute_target_memory);
    if (state->res != VK_SUCCESS) fatal_vk("vkAllocateMemory (compute)", state->res);
    vkBindImageMemory(state->device, state->compute_target_image, state->compute_target_memory, 0);

    // Create View
    VkImageViewCreateInfo ivci = { 
        .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, 
        .image = state->compute_target_image, 
        .viewType = VK_IMAGE_VIEW_TYPE_2D, 
        .format = VK_FORMAT_R8G8B8A8_UNORM, 
        .subresourceRange = { .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT, .baseMipLevel = 0, .levelCount = 1, .baseArrayLayer = 0, .layerCount = 1 } 
    };
    state->res = vkCreateImageView(state->device, &ivci, NULL, &state->compute_target_view);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateImageView (compute)", state->res);

    // Transition to General (ready for compute write)
    transition_image_layout(state, state->compute_target_image, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_GENERAL);
    
    // Update Descriptor Set 2 to point to this new view
    if (state->compute_target_descriptor) {
        VkDescriptorImageInfo dii = { 
            .sampler = state->font_sampler, // Reuse sampler
            .imageView = state->compute_target_view, 
            .imageLayout = VK_IMAGE_LAYOUT_GENERAL // We will read from General layout for simplicity in MVP
        };
        VkWriteDescriptorSet w = { 
            .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, 
            .dstSet = state->compute_target_descriptor, 
            .dstBinding = 0, 
            .descriptorCount = 1, 
            .descriptorType = VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 
            .pImageInfo = &dii 
        };
        vkUpdateDescriptorSets(state->device, 1, &w, 0, NULL);
    }
    
    // Update Compute Write Descriptor (Set 0)
    if (state->compute_write_descriptor) {
        VkDescriptorImageInfo diiC = { 
            .imageView = state->compute_target_view, 
            .imageLayout = VK_IMAGE_LAYOUT_GENERAL
        };
        VkWriteDescriptorSet wC = { 
            .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, 
            .dstSet = state->compute_write_descriptor, 
            .dstBinding = 0, 
            .descriptorCount = 1, 
            .descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, 
            .pImageInfo = &diiC 
        };
        vkUpdateDescriptorSets(state->device, 1, &wC, 0, NULL);
    }
}

void vk_destroy_device_resources(VulkanRendererState* state) {
    vk_cleanup_swapchain(state, false);

    if (state->descriptor_pool) { vkDestroyDescriptorPool(state->device, state->descriptor_pool, NULL); state->descriptor_pool = VK_NULL_HANDLE; }
    if (state->descriptor_layout) { vkDestroyDescriptorSetLayout(state->device, state->descriptor_layout, NULL); state->descriptor_layout = VK_NULL_HANDLE; }
    if (state->instance_layout) { vkDestroyDescriptorSetLayout(state->device, state->instance_layout, NULL); state->instance_layout = VK_NULL_HANDLE; }
    if (state->font_sampler) { vkDestroySampler(state->device, state->font_sampler, NULL); state->font_sampler = VK_NULL_HANDLE; }
    if (state->font_image_view) { vkDestroyImageView(state->device, state->font_image_view, NULL); state->font_image_view = VK_NULL_HANDLE; }
    if (state->font_image) { vkDestroyImage(state->device, state->font_image, NULL); state->font_image = VK_NULL_HANDLE; }
    if (state->font_image_mem) { vkFreeMemory(state->device, state->font_image_mem, NULL); state->font_image_mem = VK_NULL_HANDLE; }
    
    // Unified Resources (Quad)
    if (state->unit_quad_buffer) { vkDestroyBuffer(state->device, state->unit_quad_buffer, NULL); state->unit_quad_buffer = VK_NULL_HANDLE; }
    if (state->unit_quad_memory) { vkFreeMemory(state->device, state->unit_quad_memory, NULL); state->unit_quad_memory = VK_NULL_HANDLE; }
    if (state->unit_quad_index_buffer) { vkDestroyBuffer(state->device, state->unit_quad_index_buffer, NULL); state->unit_quad_index_buffer = VK_NULL_HANDLE; }
    if (state->unit_quad_index_memory) { vkFreeMemory(state->device, state->unit_quad_index_memory, NULL); state->unit_quad_index_memory = VK_NULL_HANDLE; }

    // Cleanup Compute
    if (state->compute_target_view) { vkDestroyImageView(state->device, state->compute_target_view, NULL); state->compute_target_view = VK_NULL_HANDLE; }
    if (state->compute_target_image) { vkDestroyImage(state->device, state->compute_target_image, NULL); state->compute_target_image = VK_NULL_HANDLE; }
    if (state->compute_target_memory) { vkFreeMemory(state->device, state->compute_target_memory, NULL); state->compute_target_memory = VK_NULL_HANDLE; }
    
    for (size_t i = 0; i < 2; ++i) {
        if (state->frame_resources[i].vertex_buffer) { vkDestroyBuffer(state->device, state->frame_resources[i].vertex_buffer, NULL); state->frame_resources[i].vertex_buffer = VK_NULL_HANDLE; }
        if (state->frame_resources[i].vertex_memory) { vkFreeMemory(state->device, state->frame_resources[i].vertex_memory, NULL); state->frame_resources[i].vertex_memory = VK_NULL_HANDLE; }
        state->frame_resources[i].vertex_capacity = 0;
        state->frame_resources[i].vertex_count = 0;
        state->frame_resources[i].stage = FRAME_AVAILABLE;
        state->frame_resources[i].inflight_fence = VK_NULL_HANDLE;
    }
    if (state->sem_img_avail) { vkDestroySemaphore(state->device, state->sem_img_avail, NULL); state->sem_img_avail = VK_NULL_HANDLE; }
    if (state->sem_render_done) { vkDestroySemaphore(state->device, state->sem_render_done, NULL); state->sem_render_done = VK_NULL_HANDLE; }
}


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_resources.h
==================================================
#ifndef VK_RESOURCES_H
#define VK_RESOURCES_H

#include "vk_types.h"

void vk_create_buffer(VulkanRendererState* state, VkDeviceSize size, VkBufferUsageFlags usage, VkMemoryPropertyFlags props, VkBuffer* out_buf, VkDeviceMemory* out_mem);
bool vk_create_vertex_buffer(VulkanRendererState* state, FrameResources *frame, size_t bytes);
void vk_create_font_texture(VulkanRendererState* state);
void vk_create_descriptor_pool_and_set(VulkanRendererState* state);
void vk_ensure_compute_target(VulkanRendererState* state, int width, int height);

void vk_destroy_device_resources(VulkanRendererState* state);

#endif // VK_RESOURCES_H


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_swapchain.c
==================================================
#include "vk_swapchain.h"
#include "vk_utils.h"
#include "foundation/logger/logger.h"
#include <stdlib.h>

typedef struct {
    VkBool32 color_attachment;
    VkBool32 blend;
} FormatSupport;

static FormatSupport get_format_support(VkPhysicalDevice physical, VkFormat fmt) {
    VkFormatProperties props;
    vkGetPhysicalDeviceFormatProperties(physical, fmt, &props);
    FormatSupport support = {
        .color_attachment = (props.optimalTilingFeatures & VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT) != 0,
        .blend = (props.optimalTilingFeatures & VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT) != 0
    };
    return support;
}

static VkFormat choose_depth_format(VkPhysicalDevice physical)
{
    VkFormat candidates[] = {
        VK_FORMAT_D32_SFLOAT,
        VK_FORMAT_D24_UNORM_S8_UINT,
        VK_FORMAT_D16_UNORM,
    };

    for (size_t i = 0; i < sizeof(candidates)/sizeof(candidates[0]); ++i) {
        VkFormat format = candidates[i];
        VkFormatProperties props;
        vkGetPhysicalDeviceFormatProperties(physical, format, &props);
        if (props.optimalTilingFeatures & VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT) {
            return format;
        }
    }

    return VK_FORMAT_UNDEFINED;
}

void vk_create_swapchain_and_views(VulkanRendererState* state, VkSwapchainKHR old_swapchain) {
    /* choose format */
    uint32_t fc = 0; 
    vkGetPhysicalDeviceSurfaceFormatsKHR(state->physical_device, state->surface, &fc, NULL); 
    if (fc == 0) { LOG_FATAL("no surface formats"); return; }
    
    VkSurfaceFormatKHR* fmts = (VkSurfaceFormatKHR*)malloc(sizeof(VkSurfaceFormatKHR) * fc); 
    vkGetPhysicalDeviceSurfaceFormatsKHR(state->physical_device, state->surface, &fc, fmts);
    
    VkSurfaceFormatKHR chosen_fmt = { 0 };
    FormatSupport chosen_support = { 0 };
    VkSurfaceFormatKHR srgb_choice = { 0 };
    FormatSupport srgb_support = { 0 };
    VkBool32 have_srgb = VK_FALSE;
    VkBool32 have_srgb_blend = VK_FALSE;
    VkSurfaceFormatKHR blend_choice = { 0 };
    FormatSupport blend_support = { 0 };
    VkBool32 have_blend_only = VK_FALSE;

    for (uint32_t i = 0; i < fc; i++) {
        FormatSupport support = get_format_support(state->physical_device, fmts[i].format);
        if (!support.color_attachment) continue;

        if (chosen_support.color_attachment == VK_FALSE) {
            chosen_fmt = fmts[i];
            chosen_support = support;
        }

        if (support.blend && !have_blend_only) {
            blend_choice = fmts[i];
            blend_support = support;
            have_blend_only = VK_TRUE;
        }

        if (fmts[i].format == VK_FORMAT_B8G8R8A8_UNORM) {
            srgb_choice = fmts[i];
            srgb_support = support;
            have_srgb = VK_TRUE;
            if (support.blend) {
                have_srgb_blend = VK_TRUE;
                chosen_fmt = srgb_choice;
                chosen_support = srgb_support;
                break;
            }
        }
    }

    if (have_srgb_blend || (!chosen_support.color_attachment && have_srgb)) {
        chosen_fmt = srgb_choice;
        chosen_support = srgb_support;
    }
    else if (!chosen_support.color_attachment && have_blend_only) {
        chosen_fmt = blend_choice;
        chosen_support = blend_support;
    }

    if (!chosen_support.color_attachment) LOG_FATAL("no color attachment format for swapchain");

    if (chosen_fmt.format == VK_FORMAT_UNDEFINED) {
        chosen_fmt.format = VK_FORMAT_B8G8R8A8_UNORM;
    }
    
    // Check support again for the chosen (possibly defaulted) format
    chosen_support = get_format_support(state->physical_device, chosen_fmt.format);
    if (!chosen_support.color_attachment) LOG_FATAL("swapchain format lacks color attachment support");
    
    state->swapchain_supports_blend = chosen_support.blend;
    state->swapchain_format = chosen_fmt.format;
    free(fmts);

    PlatformWindowSize fb_size = platform_get_framebuffer_size(state->window);
    int w = fb_size.width;
    int h = fb_size.height;
    while (w == 0 || h == 0) {
        platform_wait_events();
        if (platform_window_should_close(state->window)) return;
        fb_size = platform_get_framebuffer_size(state->window);
        w = fb_size.width;
        h = fb_size.height;
    }

    VkSurfaceCapabilitiesKHR caps; 
    vkGetPhysicalDeviceSurfaceCapabilitiesKHR(state->physical_device, state->surface, &caps);

    uint32_t img_count = caps.minImageCount + 1;
    if (caps.maxImageCount > 0 && img_count > caps.maxImageCount) img_count = caps.maxImageCount;

    if (caps.currentExtent.width != UINT32_MAX) state->swapchain_extent = caps.currentExtent;
    else {
        uint32_t clamped_w = (uint32_t)w; uint32_t clamped_h = (uint32_t)h;
        if (clamped_w < caps.minImageExtent.width) clamped_w = caps.minImageExtent.width;
        if (clamped_w > caps.maxImageExtent.width) clamped_w = caps.maxImageExtent.width;
        if (clamped_h < caps.minImageExtent.height) clamped_h = caps.minImageExtent.height;
        if (clamped_h > caps.maxImageExtent.height) clamped_h = caps.maxImageExtent.height;
        state->swapchain_extent.width = clamped_w; 
        state->swapchain_extent.height = clamped_h;
    }

    state->transformer.viewport_size = (Vec2){(float)state->swapchain_extent.width, (float)state->swapchain_extent.height};

    VkCompositeAlphaFlagBitsKHR comp_alpha = VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR;
    VkCompositeAlphaFlagBitsKHR pref_alphas[] = {
        VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR,
        VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR,
        VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR,
        VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR
    };
    for (size_t i = 0; i < sizeof(pref_alphas) / sizeof(pref_alphas[0]); i++) {
        if (caps.supportedCompositeAlpha & pref_alphas[i]) { comp_alpha = pref_alphas[i]; break; }
    }

    VkImageUsageFlags usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT;
    if (!(caps.supportedUsageFlags & usage)) LOG_FATAL("swapchain color usage unsupported");

    VkPresentModeKHR present_mode = VK_PRESENT_MODE_FIFO_KHR;
    LOG_INFO("Selected Present Mode: %d (FIFO=%d, MAILBOX=%d, IMMEDIATE=%d)", 
           present_mode, VK_PRESENT_MODE_FIFO_KHR, VK_PRESENT_MODE_MAILBOX_KHR, VK_PRESENT_MODE_IMMEDIATE_KHR);

    VkSwapchainCreateInfoKHR sci = { 
        .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR, 
        .surface = state->surface, 
        .minImageCount = img_count, 
        .imageFormat = state->swapchain_format, 
        .imageColorSpace = chosen_fmt.colorSpace, 
        .imageExtent = state->swapchain_extent, 
        .imageArrayLayers = 1, 
        .imageUsage = usage, 
        .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE, 
        .preTransform = caps.currentTransform, 
        .compositeAlpha = comp_alpha, 
        .presentMode = present_mode, 
        .clipped = VK_TRUE, 
        .oldSwapchain = old_swapchain 
    };
    
    state->res = vkCreateSwapchainKHR(state->device, &sci, NULL, &state->swapchain);
    LOG_INFO("vkCreateSwapchainKHR: Swapchain created.");
    
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateSwapchainKHR", state->res);
    
    vkGetSwapchainImagesKHR(state->device, state->swapchain, &state->swapchain_img_count, NULL);
    state->swapchain_imgs = (VkImage*)malloc(sizeof(VkImage) * state->swapchain_img_count);
    vkGetSwapchainImagesKHR(state->device, state->swapchain, &state->swapchain_img_count, state->swapchain_imgs);
    
    state->swapchain_imgviews = (VkImageView*)malloc(sizeof(VkImageView) * state->swapchain_img_count);
    for (uint32_t i = 0; i < state->swapchain_img_count; i++) {
        VkImageViewCreateInfo ivci = { 
            .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO, 
            .image = state->swapchain_imgs[i], 
            .viewType = VK_IMAGE_VIEW_TYPE_2D, 
            .format = state->swapchain_format, 
            .subresourceRange = { VK_IMAGE_ASPECT_COLOR_BIT, 0,1,0,1 } 
        };
        state->res = vkCreateImageView(state->device, &ivci, NULL, &state->swapchain_imgviews[i]);
        if (state->res != VK_SUCCESS) fatal_vk("vkCreateImageView", state->res);
    }
}

void vk_destroy_depth_resources(VulkanRendererState* state) {
    if (state->depth_image_view) {
        vkDestroyImageView(state->device, state->depth_image_view, NULL);
        state->depth_image_view = VK_NULL_HANDLE;
    }
    if (state->depth_image) {
        vkDestroyImage(state->device, state->depth_image, NULL);
        state->depth_image = VK_NULL_HANDLE;
    }
    if (state->depth_memory) {
        vkFreeMemory(state->device, state->depth_memory, NULL);
        state->depth_memory = VK_NULL_HANDLE;
    }
}

void vk_create_depth_resources(VulkanRendererState* state) {
    vk_destroy_depth_resources(state);

    state->depth_format = choose_depth_format(state->physical_device);
    if (state->depth_format == VK_FORMAT_UNDEFINED) {
        LOG_FATAL("No supported depth format found");
    }

    VkImageCreateInfo image_info = {
        .sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
        .imageType = VK_IMAGE_TYPE_2D,
        .format = state->depth_format,
        .extent = { state->swapchain_extent.width, state->swapchain_extent.height, 1 },
        .mipLevels = 1,
        .arrayLayers = 1,
        .samples = VK_SAMPLE_COUNT_1_BIT,
        .tiling = VK_IMAGE_TILING_OPTIMAL,
        .usage = VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT,
        .sharingMode = VK_SHARING_MODE_EXCLUSIVE,
        .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED
    };

    state->res = vkCreateImage(state->device, &image_info, NULL, &state->depth_image);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateImage (depth)", state->res);

    VkMemoryRequirements mem_req;
    vkGetImageMemoryRequirements(state->device, state->depth_image, &mem_req);
    VkMemoryAllocateInfo alloc_info = { .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO, .allocationSize = mem_req.size };
    VkPhysicalDeviceMemoryProperties mem_props; vkGetPhysicalDeviceMemoryProperties(state->physical_device, &mem_props);
    uint32_t mem_type = UINT32_MAX;
    for (uint32_t i = 0; i < mem_props.memoryTypeCount; i++) {
        if ((mem_req.memoryTypeBits & (1u << i)) && (mem_props.memoryTypes[i].propertyFlags & VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT)) {
            mem_type = i; break; }
    }
    if (mem_type == UINT32_MAX) LOG_FATAL("No suitable memory type for depth buffer");
    alloc_info.memoryTypeIndex = mem_type;
    state->res = vkAllocateMemory(state->device, &alloc_info, NULL, &state->depth_memory);
    if (state->res != VK_SUCCESS) fatal_vk("vkAllocateMemory (depth)", state->res);
    vkBindImageMemory(state->device, state->depth_image, state->depth_memory, 0);

    VkImageViewCreateInfo view_info = {
        .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
        .image = state->depth_image,
        .viewType = VK_IMAGE_VIEW_TYPE_2D,
        .format = state->depth_format,
        .subresourceRange = { VK_IMAGE_ASPECT_DEPTH_BIT, 0, 1, 0, 1 }
    };

    state->res = vkCreateImageView(state->device, &view_info, NULL, &state->depth_image_view);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateImageView (depth)", state->res);
}

void vk_create_render_pass(VulkanRendererState* state) {
    if (state->depth_format == VK_FORMAT_UNDEFINED) {
        state->depth_format = choose_depth_format(state->physical_device);
        if (state->depth_format == VK_FORMAT_UNDEFINED) LOG_FATAL("No supported depth format found");
    }

    VkAttachmentDescription attachments[2] = {
        { .format = state->swapchain_format, .samples = VK_SAMPLE_COUNT_1_BIT, .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR, .storeOp = VK_ATTACHMENT_STORE_OP_STORE, .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE, .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE, .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED, .finalLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR },
        { .format = state->depth_format, .samples = VK_SAMPLE_COUNT_1_BIT, .loadOp = VK_ATTACHMENT_LOAD_OP_CLEAR, .storeOp = VK_ATTACHMENT_STORE_OP_DONT_CARE, .stencilLoadOp = VK_ATTACHMENT_LOAD_OP_DONT_CARE, .stencilStoreOp = VK_ATTACHMENT_STORE_OP_DONT_CARE, .initialLayout = VK_IMAGE_LAYOUT_UNDEFINED, .finalLayout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL }
    };
    VkAttachmentReference color_ref = { .attachment = 0, .layout = VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL };
    VkAttachmentReference depth_ref = { .attachment = 1, .layout = VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL };
    VkSubpassDescription sub = { .pipelineBindPoint = VK_PIPELINE_BIND_POINT_GRAPHICS, .colorAttachmentCount = 1, .pColorAttachments = &color_ref, .pDepthStencilAttachment = &depth_ref };
    VkRenderPassCreateInfo rpci = { .sType = VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO, .attachmentCount = 2, .pAttachments = attachments, .subpassCount = 1, .pSubpasses = &sub };
    state->res = vkCreateRenderPass(state->device, &rpci, NULL, &state->render_pass);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateRenderPass", state->res);
}

void vk_create_cmds_and_sync(VulkanRendererState* state) {
    if (state->sem_img_avail) { vkDestroySemaphore(state->device, state->sem_img_avail, NULL); state->sem_img_avail = VK_NULL_HANDLE; }
    if (state->sem_render_done) { vkDestroySemaphore(state->device, state->sem_render_done, NULL); state->sem_render_done = VK_NULL_HANDLE; }
    
    VkCommandPoolCreateInfo cpci = { .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO, .queueFamilyIndex = state->graphics_family, .flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT };
    state->res = vkCreateCommandPool(state->device, &cpci, NULL, &state->cmdpool);
    if (state->res != VK_SUCCESS) fatal_vk("vkCreateCommandPool", state->res);
    
    state->cmdbuffers = (VkCommandBuffer*)malloc(sizeof(VkCommandBuffer) * state->swapchain_img_count);
    VkCommandBufferAllocateInfo cbai = { .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, .commandPool = state->cmdpool, .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY, .commandBufferCount = state->swapchain_img_count };
    state->res = vkAllocateCommandBuffers(state->device, &cbai, state->cmdbuffers);
    if (state->res != VK_SUCCESS) fatal_vk("vkAllocateCommandBuffers", state->res);

    state->framebuffers = (VkFramebuffer*)malloc(sizeof(VkFramebuffer) * state->swapchain_img_count);
    for (uint32_t i = 0; i < state->swapchain_img_count; i++) {
        VkImageView attachments[2] = { state->swapchain_imgviews[i], state->depth_image_view };
        VkFramebufferCreateInfo fci = { .sType = VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO, .renderPass = state->render_pass, .attachmentCount = 2, .pAttachments = attachments, .width = state->swapchain_extent.width, .height = state->swapchain_extent.height, .layers = 1 };
        state->res = vkCreateFramebuffer(state->device, &fci, NULL, &state->framebuffers[i]);
        if (state->res != VK_SUCCESS) fatal_vk("vkCreateFramebuffer", state->res);
    }
    VkSemaphoreCreateInfo sci = { .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO }; 
    vkCreateSemaphore(state->device, &sci, NULL, &state->sem_img_avail); 
    vkCreateSemaphore(state->device, &sci, NULL, &state->sem_render_done);
    
    state->fences = (VkFence*)malloc(sizeof(VkFence) * state->swapchain_img_count);
    for (uint32_t i = 0; i < state->swapchain_img_count; i++) {
        VkFenceCreateInfo fci = { .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, .flags = VK_FENCE_CREATE_SIGNALED_BIT };
        vkCreateFence(state->device, &fci, NULL, &state->fences[i]);
    }

    free(state->image_frame_owner);
    state->image_frame_owner = calloc(state->swapchain_img_count, sizeof(int));
    if (state->image_frame_owner) {
        for (uint32_t i = 0; i < state->swapchain_img_count; ++i) {
            state->image_frame_owner[i] = -1;
        }
    }
    state->current_frame_cursor = 0;
}

void vk_cleanup_swapchain(VulkanRendererState* state, bool keep_swapchain_handle) {
    if (state->cmdbuffers) {
        vkFreeCommandBuffers(state->device, state->cmdpool, state->swapchain_img_count, state->cmdbuffers);
        free((void*)state->cmdbuffers);
        state->cmdbuffers = NULL;
    }
    if (state->cmdpool) {
        vkDestroyCommandPool(state->device, state->cmdpool, NULL);
        state->cmdpool = VK_NULL_HANDLE;
    }
    if (state->framebuffers) {
        for (uint32_t i = 0; i < state->swapchain_img_count; i++) vkDestroyFramebuffer(state->device, state->framebuffers[i], NULL);
        free((void*)state->framebuffers);
        state->framebuffers = NULL;
    }
    if (state->fences) {
        for (uint32_t i = 0; i < state->swapchain_img_count; i++) vkDestroyFence(state->device, state->fences[i], NULL);
        free((void*)state->fences);
        state->fences = NULL;
    }
    for (size_t i = 0; i < 2; ++i) {
        state->frame_resources[i].stage = FRAME_AVAILABLE;
        state->frame_resources[i].inflight_fence = VK_NULL_HANDLE;
    }
    free((void*)state->image_frame_owner);
    state->image_frame_owner = NULL;
    if (state->swapchain_imgviews) {
        for (uint32_t i = 0; i < state->swapchain_img_count; i++) vkDestroyImageView(state->device, state->swapchain_imgviews[i], NULL);
        free((void*)state->swapchain_imgviews);
        state->swapchain_imgviews = NULL;
    }
    if (state->swapchain_imgs) {
        free((void*)state->swapchain_imgs);
        state->swapchain_imgs = NULL;
    }
    vk_destroy_depth_resources(state);
    
    if (!keep_swapchain_handle && state->swapchain) {
        vkDestroySwapchainKHR(state->device, state->swapchain, NULL);
        LOG_INFO("vkDestroySwapchainKHR: Swapchain destroyed.");
        state->swapchain = VK_NULL_HANDLE;
    }
    if (state->pipeline) {
        vkDestroyPipeline(state->device, state->pipeline, NULL);
        state->pipeline = VK_NULL_HANDLE;
    }
    if (state->pipeline_layout) {
        vkDestroyPipelineLayout(state->device, state->pipeline_layout, NULL);
        state->pipeline_layout = VK_NULL_HANDLE;
    }
    if (state->render_pass) {
        vkDestroyRenderPass(state->device, state->render_pass, NULL);
        state->render_pass = VK_NULL_HANDLE;
    }
    state->swapchain_img_count = 0;
}


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_swapchain.h
==================================================
#ifndef VK_SWAPCHAIN_H
#define VK_SWAPCHAIN_H

#include "vk_types.h"

void vk_create_swapchain_and_views(VulkanRendererState* state, VkSwapchainKHR old_swapchain);
void vk_create_depth_resources(VulkanRendererState* state);
void vk_destroy_depth_resources(VulkanRendererState* state);
void vk_create_render_pass(VulkanRendererState* state);
void vk_create_cmds_and_sync(VulkanRendererState* state);
void vk_cleanup_swapchain(VulkanRendererState* state, bool keep_swapchain_handle);

#endif // VK_SWAPCHAIN_H


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_types.h
==================================================
#ifndef VK_TYPES_H
#define VK_TYPES_H

#include <stdbool.h>
#include <stdint.h>
#include <vulkan/vulkan.h>

#include "foundation/math/coordinate_systems.h"
#include "foundation/platform/platform.h"
#include "engine/graphics/internal/vulkan/vulkan_renderer.h"

typedef struct Font Font;

typedef struct { float viewport[2]; } ViewConstants;

typedef enum {
    FRAME_AVAILABLE,
    FRAME_FILLING,
    FRAME_SUBMITTED,
} FrameStage;

typedef struct {

    size_t vertex_capacity;
} FrameCpuArena;

typedef struct {
    FrameCpuArena cpu;
    VkBuffer vertex_buffer;
    VkDeviceMemory vertex_memory;
    VkDeviceSize vertex_capacity;
    size_t vertex_count;
    FrameStage stage;
    VkFence inflight_fence;

    // Per-Frame Instance Buffer (Dynamic)
    VkBuffer instance_buffer;
    VkDeviceMemory instance_memory;
    void* instance_mapped;
    VkDescriptorSet instance_set; // Set 1: Points to this frame's buffer
    size_t instance_capacity;     // Current capacity (element count)
} FrameResources;

typedef struct VulkanRendererState {
    PlatformWindow* window;
    PlatformSurface* platform_surface;
    VkInstance instance;
    VkPhysicalDevice physical_device;
    VkDevice device;
    uint32_t graphics_family;
    VkQueue queue;
    VkSurfaceKHR surface;
    VkSwapchainKHR swapchain;
    
    // Shader Sources (Persisted for Pipeline Recreation)
    struct {
        uint32_t* code;
        size_t size;
    } vert_shader_src;
    
    struct {
        uint32_t* code;
        size_t size;
    } frag_shader_src;

    uint32_t swapchain_img_count;
    VkImage* swapchain_imgs;
    VkImageView* swapchain_imgviews;
    VkFormat swapchain_format;
    VkExtent2D swapchain_extent;
    VkBool32 swapchain_supports_blend;
    VkRenderPass render_pass;
    VkPipelineLayout pipeline_layout;
    VkPipeline pipeline;
    VkCommandPool cmdpool;
    VkCommandBuffer* cmdbuffers;
    VkFramebuffer* framebuffers;
    VkResult res;
    VkSemaphore sem_img_avail;
    VkSemaphore sem_render_done;
    VkFence* fences;
    FrameResources frame_resources[2];
    uint32_t current_frame_cursor;
    int* image_frame_owner;
    VkImage depth_image;
    VkDeviceMemory depth_memory;
    VkImageView depth_image_view;
    VkFormat depth_format;
    VkImage font_image;
    VkDeviceMemory font_image_mem;
    VkImageView font_image_view;
    VkSampler font_sampler;
    VkDescriptorSetLayout descriptor_layout;
    VkDescriptorPool descriptor_pool;
    VkDescriptorSet descriptor_set; // Set 0: Global Textures
    CoordinateSystem2D transformer;
    const Font* font;
    
    // Screenshot State
    bool screenshot_pending;
    char screenshot_path[256];
    void* screenshot_threads_head; // Linked list of active screenshot threads

    // Unified Resources
    VkBuffer unit_quad_buffer;
    VkDeviceMemory unit_quad_memory;
    VkBuffer unit_quad_index_buffer;
    VkDeviceMemory unit_quad_index_memory;
    
    // Instancing (Global Layout, Per-Frame Sets)
    VkDescriptorSetLayout instance_layout;

    // Compute Target (Visualization)
    VkImage compute_target_image;
    VkDeviceMemory compute_target_memory;
    VkImageView compute_target_view;
    VkDescriptorSet compute_target_descriptor; // Set 2 (Sampling)
    VkDescriptorSet compute_write_descriptor;  // Set 0 (Compute Writing)
    VkDescriptorSetLayout compute_write_layout;
    int compute_width;
    int compute_height;
    
    // Compute Sync
    VkFence compute_fence;
    VkCommandBuffer compute_cmd;

    // --- Compute Pipeline Pool ---
#define MAX_COMPUTE_PIPELINES 32
    struct {
        bool active;
        VkPipeline pipeline;
        VkPipelineLayout layout;
    } compute_pipelines[MAX_COMPUTE_PIPELINES];

} VulkanRendererState;

#endif // VK_TYPES_H


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_utils.c
==================================================
#include "engine/graphics/internal/vulkan/vk_utils.h"
#include "foundation/logger/logger.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <vulkan/vulkan.h>

void fatal_vk(const char* msg, VkResult res) {
    LOG_FATAL("%s: VkResult %d", msg, res);
}

double vk_now_ms(void) {
    // Implement or wrap platform time
    // For now, simple placeholder or use platform if available
    // Better to move this to platform layer or use platform_get_time_ms
    return 0.0; // Placeholder
}

uint32_t find_mem_type(VkPhysicalDevice physical_device, uint32_t type_filter, VkMemoryPropertyFlags properties) {
    VkPhysicalDeviceMemoryProperties mem_props;
    vkGetPhysicalDeviceMemoryProperties(physical_device, &mem_props);

    for (uint32_t i = 0; i < mem_props.memoryTypeCount; i++) {
        if ((type_filter & (1 << i)) && 
            (mem_props.memoryTypes[i].propertyFlags & properties) == properties) {
            return i;
        }
    }

    LOG_FATAL("Failed to find suitable memory type!");
    return 0;
}

uint32_t* read_file_bin_u32(const char* filename, size_t* out_size) {
    FILE* file = fopen(filename, "rb");
    if (!file) {
        LOG_ERROR("Failed to open file: %s", filename);
        return NULL;
    }

    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);

    if (file_size % 4 != 0) {
        LOG_WARN("File size is not a multiple of 4 (SPIR-V requirement?): %s", filename);
    }

    uint32_t* buffer = (uint32_t*)malloc(file_size);
    if (!buffer) {
        LOG_FATAL("Failed to allocate memory for file: %s", filename);
        fclose(file);
        return NULL;
    }

    size_t read_bytes = fread(buffer, 1, file_size, file);
    if (read_bytes != (size_t)file_size) {
        LOG_ERROR("Failed to read file: %s", filename);
        free(buffer);
        fclose(file);
        return NULL;
    }

    fclose(file);
    if (out_size) *out_size = file_size;
    return buffer;
}


==================================================
FILE START: src/engine/graphics/internal/vulkan/vk_utils.h
==================================================
#ifndef VK_UTILS_H
#define VK_UTILS_H

#include "engine/graphics/internal/vulkan/vk_types.h"

// Helper to log fatal error and exit (or abort)
void fatal_vk(const char* msg, VkResult res);

double vk_now_ms(void);

// Logging
// void vk_log_command(VulkanRendererState* state, RenderLogLevel level, const char* cmd, const char* param, double start_time_ms);

// Memory
uint32_t find_mem_type(VkPhysicalDevice physical_device, uint32_t type_filter, VkMemoryPropertyFlags properties);

// File I/O
uint32_t* read_file_bin_u32(const char* filename, size_t* out_size);

#endif // VK_UTILS_H


==================================================
FILE START: src/engine/graphics/internal/vulkan/vulkan_renderer.c
==================================================
#include "engine/graphics/internal/vulkan/vulkan_renderer.h"
#include "engine/scene/render_packet.h"

#include "engine/graphics/internal/vulkan/vk_types.h"
#include "engine/graphics/internal/vulkan/vk_context.h"
#include "engine/graphics/internal/vulkan/vk_swapchain.h"
#include "engine/graphics/internal/vulkan/vk_pipeline.h"
#include "engine/graphics/internal/vulkan/vk_resources.h"
#include "engine/graphics/internal/vulkan/vk_utils.h"
#include "engine/graphics/primitives.h"
#include "engine/text/font.h"

#include "foundation/logger/logger.h"
#include "foundation/platform/platform.h"
#include "foundation/platform/fs.h"
#include "foundation/math/coordinate_systems.h"
#include "foundation/image/image.h"
#include "foundation/thread/thread.h"

#include <stdlib.h>
#include <string.h>
#include <math.h>

typedef struct ScreenshotContext {
    char path[256];
    int width;
    int height;
    bool needs_swizzle;
    uint8_t* data;
} ScreenshotContext;

typedef struct ThreadNode {
    Thread* thread;
    struct ThreadNode* next;
} ThreadNode;

static int save_screenshot_task(void* arg) {
    ScreenshotContext* ctx = (ScreenshotContext*)arg;
    if (ctx) {
        if (ctx->needs_swizzle) {
            image_swizzle_bgra_to_rgba(ctx->data, ctx->width * ctx->height);
        }
        
        LOG_TRACE("Screenshot Thread: Writing to disk (%s)...", ctx->path);
        // Using default compression (which is slow but standard). Threading hides the latency.
        if (image_write_png(ctx->path, ctx->width, ctx->height, 4, ctx->data, ctx->width * 4)) {
            LOG_TRACE("Screenshot saved to %s", ctx->path);
        }
        free(ctx->data);
        free(ctx);
    }
    return 0;
}

// Must match shader struct layout (std140)
typedef struct GpuInstanceData {
    Mat4 model;
    Vec4 color;
    Vec4 uv_rect;
    Vec4 params_1;
    Vec4 params_2;
    Vec4 clip_rect; // Added
} GpuInstanceData;

static void vulkan_renderer_request_screenshot(RendererBackend* backend, const char* filepath) {
    VulkanRendererState* state = (VulkanRendererState*)backend->state;
    if (!state || !filepath) return;
    
    LOG_DEBUG("Vulkan: Queueing screenshot to %s", filepath);
    platform_strncpy(state->screenshot_path, filepath, sizeof(state->screenshot_path) - 1);
    state->screenshot_pending = true;
}

// Helper to resize instance buffer dynamically
static void ensure_instance_capacity(VulkanRendererState* state, FrameResources* frame, size_t required_count) {
    if (frame->instance_capacity >= required_count && frame->instance_buffer != VK_NULL_HANDLE) return;

    // Calculate new capacity (Start with 1024, double until fits)
    size_t new_cap = frame->instance_capacity > 0 ? frame->instance_capacity : 1024;
    while (new_cap < required_count) new_cap *= 2;
    
    // Cleanup old buffer
    if (frame->instance_buffer != VK_NULL_HANDLE) {
        vkDestroyBuffer(state->device, frame->instance_buffer, NULL);
        vkFreeMemory(state->device, frame->instance_memory, NULL);
    }

    frame->instance_capacity = new_cap;
    VkDeviceSize size = new_cap * sizeof(GpuInstanceData);
    
    // Create new buffer (Host Coherent for frequent updates)
    vk_create_buffer(state, size, VK_BUFFER_USAGE_STORAGE_BUFFER_BIT, 
                     VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, 
                     &frame->instance_buffer, &frame->instance_memory);
    
    vkMapMemory(state->device, frame->instance_memory, 0, VK_WHOLE_SIZE, 0, &frame->instance_mapped);
    
    // Update Descriptor Set
    // If set doesn't exist, allocate it
    if (frame->instance_set == VK_NULL_HANDLE) {
        VkDescriptorSetAllocateInfo alloc_info = {
            .sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO,
            .descriptorPool = state->descriptor_pool,
            .descriptorSetCount = 1,
            .pSetLayouts = &state->instance_layout
        };
        if (vkAllocateDescriptorSets(state->device, &alloc_info, &frame->instance_set) != VK_SUCCESS) {
            LOG_FATAL("Failed to allocate instance descriptor set");
        }
    }
    
    // Point set to new buffer
    VkDescriptorBufferInfo dbi = { .buffer = frame->instance_buffer, .offset = 0, .range = VK_WHOLE_SIZE };
    VkWriteDescriptorSet w = { 
        .sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET, 
        .dstSet = frame->instance_set, 
        .dstBinding = 0, 
        .descriptorCount = 1, 
        .descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, 
        .pBufferInfo = &dbi 
    };
    vkUpdateDescriptorSets(state->device, 1, &w, 0, NULL);
    
    LOG_TRACE("Resized Instance Buffer to %zu elements", new_cap);
}

// --- COMPUTE SUBSYSTEM ---

static uint32_t vulkan_compute_pipeline_create(RendererBackend* backend, const void* spirv_code, size_t size, int layout_index) {
    VulkanRendererState* state = (VulkanRendererState*)backend->state;
    
    // Find free slot
    int slot = -1;
    for (int i = 0; i < MAX_COMPUTE_PIPELINES; ++i) {
        if (!state->compute_pipelines[i].active) {
            slot = i;
            break;
        }
    }
    
    if (slot == -1) {
        LOG_ERROR("Max compute pipelines reached (%d)", MAX_COMPUTE_PIPELINES);
        return 0;
    }
    
    VkPipeline pipeline;
    VkPipelineLayout layout;
    
    // Convert void* to uint32_t* (assume 4-byte aligned and size is bytes)
    VkResult res = vk_create_compute_pipeline_shader(state, (const uint32_t*)spirv_code, size, layout_index, &pipeline, &layout);
    
    if (res != VK_SUCCESS) {
        LOG_ERROR("Failed to create compute pipeline: %d", res);
        return 0;
    }
    
    state->compute_pipelines[slot].active = true;
    state->compute_pipelines[slot].pipeline = pipeline;
    state->compute_pipelines[slot].layout = layout;
    
    return (uint32_t)(slot + 1);
}

static void vulkan_compute_pipeline_destroy(RendererBackend* backend, uint32_t pipeline_id) {
    VulkanRendererState* state = (VulkanRendererState*)backend->state;
    if (pipeline_id == 0 || pipeline_id > MAX_COMPUTE_PIPELINES) return;
    
    int idx = (int)pipeline_id - 1;
    if (state->compute_pipelines[idx].active) {
        vkDestroyPipeline(state->device, state->compute_pipelines[idx].pipeline, NULL);
        vkDestroyPipelineLayout(state->device, state->compute_pipelines[idx].layout, NULL);
        state->compute_pipelines[idx].active = false;
    }
}

static void vulkan_compute_dispatch(RendererBackend* backend, uint32_t pipeline_id, uint32_t group_x, uint32_t group_y, uint32_t group_z, void* push_constants, size_t push_constants_size) {
    VulkanRendererState* state = (VulkanRendererState*)backend->state;
    if (pipeline_id == 0 || pipeline_id > MAX_COMPUTE_PIPELINES) return;
    
    int idx = (int)pipeline_id - 1;
    if (!state->compute_pipelines[idx].active) return;
    
    VkPipeline pipeline = state->compute_pipelines[idx].pipeline;
    VkPipelineLayout layout = state->compute_pipelines[idx].layout;
    
    // Use the dedicated compute command buffer
    // Wait for fence to ensure previous submission is done
    vkWaitForFences(state->device, 1, &state->compute_fence, VK_TRUE, UINT64_MAX);
    vkResetFences(state->device, 1, &state->compute_fence);
    
    vkResetCommandBuffer(state->compute_cmd, 0);
    
    VkCommandBufferBeginInfo begin_info = { .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO };
    if (vkBeginCommandBuffer(state->compute_cmd, &begin_info) != VK_SUCCESS) {
        LOG_ERROR("Failed to begin compute cmd");
        return;
    }
    
    // Bind Pipeline
    vkCmdBindPipeline(state->compute_cmd, VK_PIPELINE_BIND_POINT_COMPUTE, pipeline);
    
    // Bind Descriptor Set 0 (Write Target)
    if (state->compute_write_descriptor) {
        vkCmdBindDescriptorSets(state->compute_cmd, VK_PIPELINE_BIND_POINT_COMPUTE, layout, 0, 1, &state->compute_write_descriptor, 0, NULL);
    }
    
    // Push Constants
    if (push_constants && push_constants_size > 0) {
        vkCmdPushConstants(state->compute_cmd, layout, VK_SHADER_STAGE_COMPUTE_BIT, 0, (uint32_t)push_constants_size, push_constants);
    }
    
    // Dispatch
    vkCmdDispatch(state->compute_cmd, group_x, group_y, group_z);
    
    // Barrier (Make sure writes are visible to fragment shader)
    VkImageMemoryBarrier barrier = {
        .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
        .oldLayout = VK_IMAGE_LAYOUT_GENERAL,
        .newLayout = VK_IMAGE_LAYOUT_GENERAL, // Keep it general for now
        .srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT,
        .dstAccessMask = VK_ACCESS_SHADER_READ_BIT,
        .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
        .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
        .image = state->compute_target_image,
        .subresourceRange = { VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1 }
    };
    
    vkCmdPipelineBarrier(state->compute_cmd, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT, 0, 0, NULL, 0, NULL, 1, &barrier);
    
    vkEndCommandBuffer(state->compute_cmd);
    
    // Submit
    VkSubmitInfo submit_info = { 
        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO, 
        .commandBufferCount = 1, 
        .pCommandBuffers = &state->compute_cmd 
    };
    
    vkQueueSubmit(state->queue, 1, &submit_info, state->compute_fence);
}

static void vulkan_compute_wait(RendererBackend* backend) {
    VulkanRendererState* state = (VulkanRendererState*)backend->state;
    vkWaitForFences(state->device, 1, &state->compute_fence, VK_TRUE, UINT64_MAX);
}

static bool vulkan_compile_shader(RendererBackend* backend, const char* source, size_t size, const char* stage, void** out_spv, size_t* out_spv_size) {
    (void)backend;
    
    // 1. Ensure logs dir exists
    platform_mkdir("logs");
    
    // 2. Write source to temp file
    const char* tmp_src = "logs/tmp_compile.glsl";
    const char* tmp_spv = "logs/tmp_compile.spv";
    
    FILE* f = fopen(tmp_src, "w");
    if (!f) return false;
    fwrite(source, 1, size, f);
    fclose(f);
    
    // 3. Construct Command
    char cmd[512];
    snprintf(cmd, sizeof(cmd), "glslc -fshader-stage=%s %s -o %s", stage, tmp_src, tmp_spv);
    
    // 4. Run
    int res = system(cmd);
    if (res != 0) {
        LOG_ERROR("Vulkan: Shader compilation failed. Command: %s", cmd);
        return false;
    }
    
    // 5. Read Result
    size_t sz = 0;
    void* code = fs_read_bin(NULL, tmp_spv, &sz);
    if (!code) return false;
    
    *out_spv = code;
    *out_spv_size = sz;
    return true;
}

static bool vulkan_renderer_init(RendererBackend* backend, const RenderBackendInit* init) {
    VulkanRendererState* state = (VulkanRendererState*)backend->state;
    
    // Config
    state->window = init->window;
    state->platform_surface = init->surface;
    state->font = init->font;
    
    // Copy Shader Data
    if (init->vert_shader.data && init->vert_shader.size > 0) {
        state->vert_shader_src.size = init->vert_shader.size;
        state->vert_shader_src.code = malloc(init->vert_shader.size);
        memcpy(state->vert_shader_src.code, init->vert_shader.data, init->vert_shader.size);
    }
    if (init->frag_shader.data && init->frag_shader.size > 0) {
        state->frag_shader_src.size = init->frag_shader.size;
        state->frag_shader_src.code = malloc(init->frag_shader.size);
        memcpy(state->frag_shader_src.code, init->frag_shader.data, init->frag_shader.size);
    }
    
    // 1. Instance
    vk_create_instance(state);
    
    // 2. Surface
    if (!platform_create_surface(state->window, state->instance, NULL, state->platform_surface)) {
        LOG_FATAL("Failed to create surface");
        return false;
    }
    state->surface = (VkSurfaceKHR)state->platform_surface->handle;

    // 3. Device
    vk_pick_physical_and_create_device(state);

    // 4. Swapchain
    vk_create_swapchain_and_views(state, VK_NULL_HANDLE);
    
    // 5. Render Pass
    vk_create_render_pass(state);

    // 6. Resources (Depth, Command Pool, Sync)
    vk_create_depth_resources(state);
    vk_create_cmds_and_sync(state);
    
    // 7. Descriptor & Pipeline
    vk_create_descriptor_layout(state);
    vk_create_pipeline(state);

    // 8. Fonts & Textures
    vk_create_font_texture(state);
    vk_create_descriptor_pool_and_set(state);

    // 9. Static Buffers (Quad)
    // Vertex Buffer
    VkDeviceSize v_size = sizeof(PRIM_QUAD_VERTS);
    vk_create_buffer(state, v_size, VK_BUFFER_USAGE_VERTEX_BUFFER_BIT, 
                     VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, 
                     &state->unit_quad_buffer, &state->unit_quad_memory);
    
    void* v_map;
    vkMapMemory(state->device, state->unit_quad_memory, 0, VK_WHOLE_SIZE, 0, &v_map);
    memcpy(v_map, PRIM_QUAD_VERTS, v_size);
    vkUnmapMemory(state->device, state->unit_quad_memory);

    // Index Buffer
    VkDeviceSize i_size = sizeof(PRIM_QUAD_INDICES);
    vk_create_buffer(state, i_size, VK_BUFFER_USAGE_INDEX_BUFFER_BIT, 
                     VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, 
                     &state->unit_quad_index_buffer, &state->unit_quad_index_memory);
                     
    void* i_map;
    vkMapMemory(state->device, state->unit_quad_index_memory, 0, VK_WHOLE_SIZE, 0, &i_map);
    memcpy(i_map, PRIM_QUAD_INDICES, i_size);
    vkUnmapMemory(state->device, state->unit_quad_index_memory);
    
    // 10. Per-Frame Instance Resources
    for (int i = 0; i < 2; ++i) {
        state->frame_resources[i].instance_capacity = 0;
        state->frame_resources[i].instance_buffer = VK_NULL_HANDLE;
        state->frame_resources[i].instance_set = VK_NULL_HANDLE;
        ensure_instance_capacity(state, &state->frame_resources[i], 1024); // Initial allocation
    }

    // 11. Compute Infrastructure
    VkFenceCreateInfo fci = { .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO, .flags = VK_FENCE_CREATE_SIGNALED_BIT };
    vkCreateFence(state->device, &fci, NULL, &state->compute_fence);
    
    VkCommandBufferAllocateInfo cbai = { 
        .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO, 
        .commandPool = state->cmdpool, 
        .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY, 
        .commandBufferCount = 1 
    };
    vkAllocateCommandBuffers(state->device, &cbai, &state->compute_cmd);
    
    vk_ensure_compute_target(state, 512, 512);

    LOG_INFO("Vulkan Initialized.");
    return true;
}

static void vulkan_renderer_update_viewport(RendererBackend* backend, int width, int height) {
    VulkanRendererState* state = (VulkanRendererState*)backend->state;
    // Handle resize
    if (width == 0 || height == 0) return;
    
    vkDeviceWaitIdle(state->device);
    
    // Save old swapchain handle
    VkSwapchainKHR old_swapchain = state->swapchain;
    
    // Cleanup old resources (destroys framebuffers, cmd buffers, pipelines, etc.)
    // Pass 'true' to keep the swapchain handle alive in 'state->swapchain' for now,
    // although we have a copy in 'old_swapchain'.
    vk_cleanup_swapchain(state, true); 
    
    // Create new swapchain, passing the old one for recycling
    vk_create_swapchain_and_views(state, old_swapchain);
    
    // Destroy the old swapchain handle (driver requires this if not NULL)
    // Note: vkCreateSwapchainKHR uses oldSwapchain for optimization but doesn't destroy it.
    if (old_swapchain != VK_NULL_HANDLE) {
        vkDestroySwapchainKHR(state->device, old_swapchain, NULL);
    }
    
    // Recreate dependent resources
    vk_create_depth_resources(state);
    vk_create_render_pass(state);
    
    // Recreate Framebuffers, Command Pool, and Command Buffers (which were destroyed by cleanup)
    vk_create_cmds_and_sync(state);
    
    // Recreate Pipeline (which depends on Render Pass and was destroyed)
    vk_create_pipeline(state);
    
    // Reset frame cursor as sync objects were recreated
    state->current_frame_cursor = 0;
}

static void vulkan_renderer_render_scene(RendererBackend* backend, const Scene* scene) {
    VulkanRendererState* state = (VulkanRendererState*)backend->state;
    if (!state || !scene) return;
    
    // Frame Sync
    vkWaitForFences(state->device, 1, &state->fences[state->current_frame_cursor], VK_TRUE, UINT64_MAX);
    vkWaitForFences(state->device, 1, &state->fences[state->current_frame_cursor], VK_TRUE, UINT64_MAX);
    
    uint32_t image_index;
    VkResult result = vkAcquireNextImageKHR(state->device, state->swapchain, UINT64_MAX, 
                                            state->sem_img_avail, VK_NULL_HANDLE, &image_index);

    if (result == VK_ERROR_OUT_OF_DATE_KHR || (result != VK_SUCCESS && result != VK_SUBOPTIMAL_KHR)) {
        // resize or error
        return;
    }
    
    vkResetFences(state->device, 1, &state->fences[state->current_frame_cursor]);
    
    // --- UPDATE RESOURCES ---
    FrameResources* frame = &state->frame_resources[state->current_frame_cursor];
    
    // 1. Check Capacity and Resize if needed
    size_t count = 0;
    const SceneObject* scene_objects = scene_get_all_objects(scene, &count);
    
    if (count == 0) count = 1; // Avoid 0 size
    ensure_instance_capacity(state, frame, count);
    
    // 2. Upload Data
    GpuInstanceData* instances = (GpuInstanceData*)frame->instance_mapped;
    if (scene_objects) {
        for (size_t i = 0; i < (count == 1 && !scene_objects ? 0 : count); ++i) { // Handle dummy count=1 if objects are null
             // Re-check count usage. If scene_objects is NULL, count is 0 from accessor, but we forced it to 1 above for buffer alloc.
             // So we must use original count for loop, or check scene_objects.
             // Better:
        }
    }
    
    // Refined loop:
    size_t actual_count = 0;
    scene_objects = scene_get_all_objects(scene, &actual_count);
    
    for (size_t i = 0; i < actual_count; ++i) {
        const SceneObject* obj = &scene_objects[i];
        
        Mat4 m;
        Mat4 s = mat4_scale(obj->scale);
        Mat4 t = mat4_translation(obj->position);
        m = mat4_multiply(&t, &s);
        
        instances[i].model = m;
        instances[i].color = obj->color;
        instances[i].uv_rect = obj->uv_rect;
        instances[i].params_1 = obj->raw.params_0;
        instances[i].params_2 = obj->raw.params_1; // Pass through extra data (9-slice or curves)
        instances[i].clip_rect = obj->ui.clip_rect;
    }
    
    // --- COMMAND RECORDING ---
    VkCommandBuffer cmd = state->cmdbuffers[state->current_frame_cursor];
    vkResetCommandBuffer(cmd, 0);
    
    VkCommandBufferBeginInfo begin_info = {.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO};
    vkBeginCommandBuffer(cmd, &begin_info);
    
    // Begin Pass
    VkRenderPassBeginInfo pass_info = {.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO};
    pass_info.renderPass = state->render_pass;
    pass_info.framebuffer = state->framebuffers[image_index];
    pass_info.renderArea.offset = (VkOffset2D){0, 0};
    pass_info.renderArea.extent = state->swapchain_extent;
    
    VkClearValue clear_values[2];
    clear_values[0].color = (VkClearColorValue){{0.1f, 0.1f, 0.12f, 1.0f}};
    clear_values[1].depthStencil = (VkClearDepthStencilValue){1.0f, 0};
    
    pass_info.clearValueCount = 2;
    pass_info.pClearValues = clear_values;
    
    vkCmdBeginRenderPass(cmd, &pass_info, VK_SUBPASS_CONTENTS_INLINE);
    vkCmdBindPipeline(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, state->pipeline);
    
    // Viewport
    VkViewport viewport = {0.0f, 0.0f, (float)state->swapchain_extent.width, (float)state->swapchain_extent.height, 0.0f, 1.0f};
    vkCmdSetViewport(cmd, 0, 1, &viewport);
    
    VkRect2D scissor = {{0, 0}, state->swapchain_extent};
    vkCmdSetScissor(cmd, 0, 1, &scissor);

    // Bind Quad Vertex Buffer
    VkDeviceSize offsets[] = {0};
    vkCmdBindVertexBuffers(cmd, 0, 1, &state->unit_quad_buffer, offsets);
    vkCmdBindIndexBuffer(cmd, state->unit_quad_index_buffer, 0, VK_INDEX_TYPE_UINT32);

    // Bind Descriptors
    // Set 0: Global Textures (Font)
    vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, state->pipeline_layout, 0, 1, &state->descriptor_set, 0, NULL);
    
    // Set 1: Instance Data (Per-Frame)
    vkCmdBindDescriptorSets(cmd, VK_PIPELINE_BIND_POINT_GRAPHICS, state->pipeline_layout, 1, 1, &frame->instance_set, 0, NULL);
    
    // Push Constants (ViewProj)
    SceneCamera cam = scene_get_camera(scene);
    vkCmdPushConstants(cmd, state->pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(Mat4), &cam.view_matrix); 

    // Draw
    if (actual_count > 0) {
        vkCmdDrawIndexed(cmd, PRIM_QUAD_INDEX_COUNT, (uint32_t)actual_count, 0, 0, 0);
    }
    
    vkCmdEndRenderPass(cmd);

    // Screenshot Buffer
    VkBuffer screenshot_buffer = VK_NULL_HANDLE;
    VkDeviceMemory screenshot_memory = VK_NULL_HANDLE;

    if (state->screenshot_pending) {
        LOG_TRACE("Screenshot: Starting capture sequence...");
        // Prepare Buffer
        uint32_t w = state->swapchain_extent.width;
        uint32_t h = state->swapchain_extent.height;
        VkDeviceSize size = w * h * 4;
        
        vk_create_buffer(state, size, VK_BUFFER_USAGE_TRANSFER_DST_BIT, 
                         VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, 
                         &screenshot_buffer, &screenshot_memory);
                         
        LOG_TRACE("Screenshot: Buffer created (Handle: %p)", (void*)screenshot_buffer);

        // Transition Image: PRESENT_SRC_KHR -> TRANSFER_SRC_OPTIMAL
        VkImageMemoryBarrier barrier = {
            .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
            .srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
            .dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT,
            .oldLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR, // Assumes renderpass finalLayout
            .newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
            .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
            .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
            .image = state->swapchain_imgs[image_index],
            .subresourceRange = { VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1 }
        };
        vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 
                             0, 0, NULL, 0, NULL, 1, &barrier);

        // Copy
        VkBufferImageCopy region = {
            .bufferOffset = 0,
            .bufferRowLength = 0,
            .bufferImageHeight = 0,
            .imageSubresource = { VK_IMAGE_ASPECT_COLOR_BIT, 0, 0, 1 },
            .imageOffset = {0, 0, 0},
            .imageExtent = {w, h, 1}
        };
        vkCmdCopyImageToBuffer(cmd, state->swapchain_imgs[image_index], VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, screenshot_buffer, 1, &region);
        
        // Transition Back: TRANSFER_SRC -> PRESENT_SRC
        barrier.srcAccessMask = VK_ACCESS_TRANSFER_READ_BIT;
        barrier.dstAccessMask = 0;
        barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
        barrier.newLayout = VK_IMAGE_LAYOUT_PRESENT_SRC_KHR;
        
        vkCmdPipelineBarrier(cmd, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, 
                             0, 0, NULL, 0, NULL, 1, &barrier);
    }

    vkEndCommandBuffer(cmd);
    
    // Submit
    VkSubmitInfo submit_info = {.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO};
    VkPipelineStageFlags wait_stages[] = {VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT};
    submit_info.waitSemaphoreCount = 1;
    submit_info.pWaitSemaphores = &state->sem_img_avail;
    submit_info.pWaitDstStageMask = wait_stages;
    submit_info.commandBufferCount = 1;
    submit_info.pCommandBuffers = &cmd;
    submit_info.signalSemaphoreCount = 1;
    submit_info.pSignalSemaphores = &state->sem_render_done;
    
    vkQueueSubmit(state->queue, 1, &submit_info, state->fences[state->current_frame_cursor]);

    // Save Screenshot (Offloaded to thread)
    if (state->screenshot_pending && screenshot_buffer) {
        LOG_TRACE("Screenshot: Waiting for GPU...");
        vkQueueWaitIdle(state->queue);
        
        uint32_t w = state->swapchain_extent.width;
        uint32_t h = state->swapchain_extent.height;
        
        LOG_TRACE("Screenshot: Mapping memory...");
        uint8_t* data = NULL;
        vkMapMemory(state->device, screenshot_memory, 0, VK_WHOLE_SIZE, 0, (void**)&data);
        
        if (data) {
            LOG_TRACE("Screenshot: Copying to host buffer...");
            size_t size = w * h * 4;
            uint8_t* host_copy = (uint8_t*)malloc(size);
            if (host_copy) {
                memcpy(host_copy, data, size);
                
                ScreenshotContext* ctx = (ScreenshotContext*)malloc(sizeof(ScreenshotContext));
                if (ctx) {
                    platform_strncpy(ctx->path, state->screenshot_path, sizeof(ctx->path) - 1);
                    ctx->width = (int)w;
                    ctx->height = (int)h;
                    ctx->data = host_copy;
                    ctx->needs_swizzle = (state->swapchain_format == VK_FORMAT_B8G8R8A8_UNORM || state->swapchain_format == VK_FORMAT_B8G8R8A8_SRGB);

                    Thread* t = thread_create(save_screenshot_task, ctx);
                    if (t) {
                        ThreadNode* node = (ThreadNode*)malloc(sizeof(ThreadNode));
                        if (node) {
                            node->thread = t;
                            node->next = (ThreadNode*)state->screenshot_threads_head;
                            state->screenshot_threads_head = (void*)node;
                            LOG_TRACE("Screenshot: Offloaded to thread (tracked).");
                        } else {
                            LOG_ERROR("Screenshot: Failed to allocate thread node! Detaching fallback.");
                            thread_detach(t);
                        }
                    } else {
                        LOG_ERROR("Screenshot: Failed to create thread!");
                        free(host_copy);
                        free(ctx);
                    }
                } else {
                    LOG_ERROR("Screenshot: Failed to allocate context!");
                    free(host_copy);
                }
            } else {
                LOG_ERROR("Screenshot: Failed to allocate host buffer!");
            }
            vkUnmapMemory(state->device, screenshot_memory);
        } else {
            LOG_ERROR("Screenshot: Failed to map memory!");
        }
        
        vkDestroyBuffer(state->device, screenshot_buffer, NULL);
        vkFreeMemory(state->device, screenshot_memory, NULL);
        
        state->screenshot_pending = false;
        LOG_TRACE("Screenshot: Done.");
    }
    
    // Present
    VkPresentInfoKHR present_info = {.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR};
    present_info.waitSemaphoreCount = 1;
    present_info.pWaitSemaphores = &state->sem_render_done;
    present_info.swapchainCount = 1;
    present_info.pSwapchains = &state->swapchain;
    present_info.pImageIndices = &image_index;
    
    vkQueuePresentKHR(state->queue, &present_info);
    
    state->current_frame_cursor = (state->current_frame_cursor + 1) % 2;
}

static void vulkan_renderer_cleanup(RendererBackend* backend) {
    if (!backend) return;
    VulkanRendererState* state = (VulkanRendererState*)backend->state;
    if (state) {
        vkDeviceWaitIdle(state->device);
        
        // Join active screenshot threads
        ThreadNode* curr = (ThreadNode*)state->screenshot_threads_head;
        while (curr) {
            LOG_TRACE("Waiting for screenshot thread...");
            thread_join(curr->thread);
            ThreadNode* next = curr->next;
            free(curr);
            curr = next;
        }
        state->screenshot_threads_head = NULL;
        
        // Clean up per-frame resources
        for (int i = 0; i < 2; ++i) {
            if (state->frame_resources[i].instance_buffer) {
                vkDestroyBuffer(state->device, state->frame_resources[i].instance_buffer, NULL);
                vkFreeMemory(state->device, state->frame_resources[i].instance_memory, NULL);
            }
        }
        
        if (state->vert_shader_src.code) free(state->vert_shader_src.code);
        if (state->frag_shader_src.code) free(state->frag_shader_src.code);

        vk_destroy_device_resources(state);
        
        if (state->surface) {
            platform_destroy_surface(state->instance, NULL, state->platform_surface);
        }
        vkDestroyInstance(state->instance, NULL);
        free(state);
    }
    
    free(backend);
}

// Factory
RendererBackend* vulkan_renderer_backend(void) {
    // Allocate Backend and State on Heap
    RendererBackend* backend = (RendererBackend*)calloc(1, sizeof(RendererBackend));
    if (!backend) return NULL;

    VulkanRendererState* state = (VulkanRendererState*)calloc(1, sizeof(VulkanRendererState));
    if (!state) {
        free(backend);
        return NULL;
    }
    
    backend->id = "vulkan";
    backend->state = state;
    backend->init = vulkan_renderer_init;
    backend->render_scene = vulkan_renderer_render_scene;
    backend->update_viewport = vulkan_renderer_update_viewport;
    backend->cleanup = vulkan_renderer_cleanup;
    backend->request_screenshot = vulkan_renderer_request_screenshot;
    
    // Compute
    backend->compute_pipeline_create = vulkan_compute_pipeline_create;
    backend->compute_pipeline_destroy = vulkan_compute_pipeline_destroy;
    backend->compute_dispatch = vulkan_compute_dispatch;
    backend->compute_wait = vulkan_compute_wait;
    backend->compile_shader = vulkan_compile_shader;
    
    return backend;
}


==================================================
FILE START: src/engine/graphics/internal/vulkan/vulkan_renderer.h
==================================================
#ifndef VULKAN_RENDERER_H
#define VULKAN_RENDERER_H

#include "engine/graphics/internal/renderer_backend.h"

RendererBackend* vulkan_renderer_backend(void);

#endif // VULKAN_RENDERER_H


==================================================
FILE START: src/engine/graphics/layer_constants.h
==================================================
#ifndef LAYER_CONSTANTS_H
#define LAYER_CONSTANTS_H

// --- Orthographic Projection Range ---
// Defined in render_system_begin_frame: mat4_orthographic(..., -100.0f, 100.0f)
// Note: Due to OpenGL->Vulkan clip space differences and the specific projection matrix,
// Visible Z range is effectively [-100.0, 0.0] where:
// Z = 0.0   -> Depth 0.0 (Near / Topmost)
// Z = -100.0 -> Depth 1.0 (Far / Bottommost)
// Therefore, HIGHER Z values (closer to 0) render ON TOP of LOWER Z values.

#define RENDER_ORTHO_Z_NEAR (-100.0f)
#define RENDER_ORTHO_Z_FAR  (100.0f)

// --- UI Depth Layers ---

// The deepest background layer (e.g., Canvas background)
#define RENDER_LAYER_UI_BASE        (-10.0f)

// Standard UI Panels (Windows, Sidebars) - significantly above the canvas
#define RENDER_LAYER_UI_PANEL       (-5.0f)

// Overlay Elements (Tooltips, Dropdowns, Modals) - on top of everything
#define RENDER_LAYER_UI_OVERLAY     (-1.0f)

// --- Increments ---
// Amount to increment Z for each nested child in the UI tree
#define RENDER_DEPTH_STEP_UI        (0.01f)
// Finer increment for content within the same container (text on button)
#define RENDER_DEPTH_STEP_CONTENT   (0.001f)

#endif // LAYER_CONSTANTS_H


==================================================
FILE START: src/engine/graphics/primitives.h
==================================================
#ifndef PRIMITIVES_H
#define PRIMITIVES_H

// Standard Vertex Format for Primitives: Pos(3) + UV(2) = 5 floats
#define PRIM_VERTEX_STRIDE 5
#define PRIM_QUAD_VERTEX_COUNT 4
#define PRIM_QUAD_INDEX_COUNT 6

// Interleaved: Pos (3) + UV (2)
// Quad: 0..1 range
static const float PRIM_QUAD_VERTS[] = {
    0.0f, 0.0f, 0.0f,   0.0f, 0.0f, // BL
    1.0f, 0.0f, 0.0f,   1.0f, 0.0f, // BR
    1.0f, 1.0f, 0.0f,   1.0f, 1.0f, // TR
    0.0f, 1.0f, 0.0f,   0.0f, 1.0f  // TL
};

static const unsigned int PRIM_QUAD_INDICES[] = {
    0, 1, 2, 
    0, 2, 3
};

#endif // PRIMITIVES_H


==================================================
FILE START: src/engine/graphics/render_system.c
==================================================
#include "engine/graphics/render_system.h"
#include "engine/assets/assets.h"
#include "engine/graphics/internal/render_frame_packet.h"
#include "foundation/logger/logger.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "foundation/thread/thread.h"

#include "foundation/platform/platform.h"
#include "engine/graphics/internal/renderer_backend.h"
#include "engine/graphics/internal/vulkan/vulkan_renderer.h"

struct RenderSystem {
    // Dependencies (Injectable)
    Assets* assets;

    // Internal State
    PlatformWindow* window;
    struct RendererBackend* backend;
    
    // Packet buffering
    RenderFramePacket packets[2];
    int front_packet_index;
    int back_packet_index;
    bool packet_ready;
    Mutex* packet_mutex;
    
    // Thread control
    bool running;
    bool renderer_ready;
    bool show_compute_result;
    uint32_t active_compute_pipeline;
    double current_time;
    
    uint64_t frame_count;
};

// --- Helper: Packet Management ---

static void render_packet_free_resources(RenderFramePacket* packet) {
    if (!packet) return;
    scene_clear(packet->scene);
}

const RenderFramePacket* render_system_acquire_packet(RenderSystem* sys) {
    if (!sys) return NULL;

    mutex_lock(sys->packet_mutex);
    if (sys->packet_ready) {
        int temp = sys->front_packet_index;
        sys->front_packet_index = sys->back_packet_index;
        sys->back_packet_index = temp;
        sys->packet_ready = false;
    }
    mutex_unlock(sys->packet_mutex);

    return &sys->packets[sys->front_packet_index];
}

Scene* render_system_get_scene(RenderSystem* sys) {
    if (!sys) return NULL;
    return sys->packets[sys->back_packet_index].scene;
}

// --- Init & Bootstrap ---

static void try_bootstrap_renderer(RenderSystem* sys) {
    if (!sys) return;
    if (sys->renderer_ready) return;
    
    // Dependencies Check
    if (!sys->window) return;
    if (!sys->assets) return;
    if (!sys->backend) return;

    // Load Shaders into Memory
    AssetData vert_shader = assets_load_file(sys->assets, "shaders/ui_default.vert.spv");
    AssetData frag_shader = assets_load_file(sys->assets, "shaders/ui_default.frag.spv");
    
    if (!vert_shader.data || !frag_shader.data) {
        LOG_ERROR("RenderSystem: Failed to load default shaders from assets.");
        assets_free_file(&vert_shader);
        assets_free_file(&frag_shader);
        return;
    }

    PlatformSurface surface = {0};
    
    RenderBackendInit init = {
        .window = sys->window,
        .surface = &surface, // Pass pointer to empty surface struct, backend/platform fills it
        .font = assets_get_font(sys->assets),
        .vert_shader = { .data = vert_shader.data, .size = vert_shader.size },
        .frag_shader = { .data = frag_shader.data, .size = frag_shader.size },
    };

    sys->renderer_ready = sys->backend->init(sys->backend, &init);
    
    // Cleanup loaded assets (Backend should have copied what it needs)
    assets_free_file(&vert_shader);
    assets_free_file(&frag_shader);
}

RenderSystem* render_system_create(const RenderSystemConfig* config) {
    if (!config) return NULL;
    RenderSystem* sys = calloc(1, sizeof(RenderSystem));
    if (!sys) return NULL;

    sys->window = config->window;
    
    sys->packet_mutex = mutex_create();
    sys->back_packet_index = 1;
    sys->frame_count = 0;

    // Create Scenes
    sys->packets[0].scene = scene_create();
    sys->packets[1].scene = scene_create();

    // Register Backend
    renderer_backend_register(vulkan_renderer_backend());
    const char* backend_id = config->backend_type ? config->backend_type : "vulkan";
    sys->backend = renderer_backend_get(backend_id);
    if (!sys->backend) {
        LOG_ERROR("RenderSystem: Failed to load backend '%s'", backend_id);
        scene_destroy(sys->packets[0].scene);
        scene_destroy(sys->packets[1].scene);
        mutex_destroy(sys->packet_mutex);
        free(sys);
        return NULL;
    }
    
    return sys;
}

void render_system_destroy(RenderSystem* sys) {
    if (!sys) return;
    
    if (sys->backend && sys->backend->cleanup) {
        sys->backend->cleanup(sys->backend);
    }
    
    render_packet_free_resources(&sys->packets[0]);
    scene_destroy(sys->packets[0].scene);
    
    render_packet_free_resources(&sys->packets[1]);
    scene_destroy(sys->packets[1].scene);
    
    mutex_destroy(sys->packet_mutex);
    free(sys);
}

void render_system_bind_assets(RenderSystem* sys, Assets* assets) {
    sys->assets = assets;
    try_bootstrap_renderer(sys);
}

void render_system_begin_frame(RenderSystem* sys, double time) {
    if (!sys) return;
    sys->frame_count++;
    sys->current_time = time;

    // Prepare Back Packet
    RenderFramePacket* dest = &sys->packets[sys->back_packet_index];
    
    // Clear old scene
    render_packet_free_resources(dest);
    
    scene_set_frame_number(dest->scene, sys->frame_count);

    // Setup Camera (Ortho)
    PlatformWindowSize size = platform_get_framebuffer_size(sys->window);
    float w = (float)size.width;
    float h = (float)size.height;
    if (w < 1.0f) w = 1.0f;
    if (h < 1.0f) h = 1.0f;

    // View: Identity (Camera at 0,0)
    SceneCamera camera = {0};
    camera.view_matrix = mat4_identity();
    
    Mat4 proj = mat4_orthographic(0.0f, w, 0.0f, h, -100.0f, 100.0f);
    camera.view_matrix = proj; // Matches original behavior (overwriting view with proj)
    
    scene_set_camera(dest->scene, camera);
}

void render_system_update(RenderSystem* sys) {
    if (!sys || !sys->renderer_ready) return;

    if (sys->active_compute_pipeline > 0 && sys->backend && sys->backend->compute_dispatch) {
        // Must match generated GLSL push constant layout
        struct {
            float time;
            float width;
            float height;
        } push = {
            .time = (float)sys->current_time,
            .width = 512.0f,
            .height = 512.0f
        };
        
        // Dispatch Compute (Target is 512x512, assuming 16x16 workgroups)
        sys->backend->compute_dispatch(sys->backend, sys->active_compute_pipeline, 32, 32, 1, &push, sizeof(push));
    }

    // DEBUG: Compute Result Visualization
    if (sys->show_compute_result) {
        SceneObject quad = {0};
        quad.id = 9999;
        quad.position = (Vec3){600.0f, 100.0f, 0.0f};
        quad.scale = (Vec3){512.0f, 512.0f, 1.0f};
        quad.color = (Vec4){1.0f, 1.0f, 1.0f, 1.0f};
        quad.raw.params_0.x = (float)SCENE_MODE_USER_TEXTURE; // User Texture
        quad.uv_rect = (Vec4){0.0f, 0.0f, 1.0f, 1.0f};
        
        RenderFramePacket* dest = &sys->packets[sys->back_packet_index];
        scene_add_object(dest->scene, quad);
    }

    // Mark Packet Ready
    mutex_lock(sys->packet_mutex);
    sys->packet_ready = true;
    mutex_unlock(sys->packet_mutex);
}

void render_system_draw(RenderSystem* sys) {
    if (!sys || !sys->renderer_ready || !sys->backend) return;
    
    const RenderFramePacket* packet = render_system_acquire_packet(sys);
    if (packet && sys->backend->render_scene) {
        sys->backend->render_scene(sys->backend, packet->scene);
    }
}

void render_system_resize(RenderSystem* sys, int width, int height) {
    if (sys && sys->backend && sys->backend->update_viewport) {
        sys->backend->update_viewport(sys->backend, width, height);
    }
}

void render_system_set_compute_pipeline(RenderSystem* sys, uint32_t pipeline_id) {
    if (!sys) return;
    sys->active_compute_pipeline = pipeline_id;
    LOG_INFO("RenderSystem: Active compute pipeline set to %u", pipeline_id);
}

uint32_t render_system_create_compute_pipeline(RenderSystem* sys, uint32_t* spv_code, size_t spv_size) {
    if (!sys || !sys->backend || !sys->backend->compute_pipeline_create) return 0;
    return sys->backend->compute_pipeline_create(sys->backend, spv_code, spv_size, 0);
}

uint32_t render_system_create_compute_pipeline_from_source(RenderSystem* sys, const char* source) {
    if (!sys || !sys->backend) return 0;
    
    // 1. Compile
    void* spv_code = NULL;
    size_t spv_size = 0;
    
    if (!sys->backend->compile_shader) {
        LOG_ERROR("Backend does not support runtime shader compilation.");
        return 0;
    }
    
    if (!sys->backend->compile_shader(sys->backend, source, strlen(source), "compute", &spv_code, &spv_size)) {
        LOG_ERROR("Shader compilation failed.");
        return 0;
    }
    
    // 2. Create Pipeline
    uint32_t id = 0;
    if (sys->backend->compute_pipeline_create) {
        id = sys->backend->compute_pipeline_create(sys->backend, spv_code, spv_size, 0);
    }
    
    // 3. Free SPIR-V
    free(spv_code);
    
    return id;
}

void render_system_destroy_compute_pipeline(RenderSystem* sys, uint32_t pipeline_id) {
    if (!sys || !sys->backend || !sys->backend->compute_pipeline_destroy) return;
    sys->backend->compute_pipeline_destroy(sys->backend, pipeline_id);
}

void render_system_request_screenshot(RenderSystem* sys, const char* filepath) {
    if (!sys || !sys->backend || !sys->backend->request_screenshot) return;
    sys->backend->request_screenshot(sys->backend, filepath);
}

double render_system_get_time(RenderSystem* sys) { return sys ? sys->current_time : 0.0; }
uint64_t render_system_get_frame_count(RenderSystem* sys) { return sys ? sys->frame_count : 0; }
bool render_system_is_ready(RenderSystem* sys) { return sys ? sys->renderer_ready : false; }
void render_system_set_show_compute(RenderSystem* sys, bool show) { if(sys) sys->show_compute_result = show; }


==================================================
FILE START: src/engine/graphics/render_system.h
==================================================
#ifndef RENDER_SYSTEM_H
#define RENDER_SYSTEM_H

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

typedef struct RenderSystem RenderSystem;
typedef struct RenderFramePacket RenderFramePacket;

typedef struct Assets Assets;
typedef struct PlatformWindow PlatformWindow;
typedef struct Scene Scene;


typedef struct RenderSystemConfig {
    PlatformWindow* window;
    const char* backend_type; // "vulkan"
} RenderSystemConfig;

RenderSystem* render_system_create(const RenderSystemConfig* config);
void render_system_destroy(RenderSystem* sys);

// Connect dependencies
void render_system_bind_assets(RenderSystem* sys, Assets* assets);

// Updates the render system (Syncs logic to render packet)
void render_system_update(RenderSystem* sys);

// Begins a new frame (updates time and frame count, clears scene)
void render_system_begin_frame(RenderSystem* sys, double time);

// Gets the current mutable scene for the frame being prepared
Scene* render_system_get_scene(RenderSystem* sys);

// Draws the current packet (Executes backend render)
void render_system_draw(RenderSystem* sys);

// Notifies system of resize
void render_system_resize(RenderSystem* sys, int width, int height);

// Sets the active compute pipeline for the next frames
void render_system_set_compute_pipeline(RenderSystem* sys, uint32_t pipeline_id);
uint32_t render_system_create_compute_pipeline(RenderSystem* sys, uint32_t* spv_code, size_t spv_size);
// Compiles GLSL (if supported by backend) and creates pipeline
uint32_t render_system_create_compute_pipeline_from_source(RenderSystem* sys, const char* source);
void render_system_destroy_compute_pipeline(RenderSystem* sys, uint32_t pipeline_id);

// Request a screenshot to be saved to the specified path
void render_system_request_screenshot(RenderSystem* sys, const char* filepath);

const RenderFramePacket* render_system_acquire_packet(RenderSystem* sys);

// --- Public State Accessors (for read-only access if needed) ---
double render_system_get_time(RenderSystem* sys);
uint64_t render_system_get_frame_count(RenderSystem* sys);
bool render_system_is_ready(RenderSystem* sys);
void render_system_set_show_compute(RenderSystem* sys, bool show);

#endif // RENDER_SYSTEM_H


==================================================
FILE START: src/engine/input/input.c
==================================================
#include "engine/input/input.h"
#include "engine/input/internal/input_internal.h"
#include "foundation/platform/platform.h"
#include "foundation/logger/logger.h"
#include <string.h>
#include <stdlib.h>

// --- Helpers ---

static bool check_modifiers(const InputSystem* sys, int mods) {
    bool shift = sys->state.keys[INPUT_KEY_LEFT_SHIFT] || sys->state.keys[INPUT_KEY_RIGHT_SHIFT];
    bool ctrl = sys->state.keys[INPUT_KEY_LEFT_CONTROL] || sys->state.keys[INPUT_KEY_RIGHT_CONTROL];
    bool alt = sys->state.keys[INPUT_KEY_LEFT_ALT] || sys->state.keys[INPUT_KEY_RIGHT_ALT];
    bool super = sys->state.keys[INPUT_KEY_LEFT_SUPER] || sys->state.keys[INPUT_KEY_RIGHT_SUPER];
    // TODO: Caps/Num lock if needed

    if ((mods & INPUT_MOD_SHIFT) && !shift) return false;
    if ((mods & INPUT_MOD_CONTROL) && !ctrl) return false;
    if ((mods & INPUT_MOD_ALT) && !alt) return false;
    if ((mods & INPUT_MOD_SUPER) && !super) return false;
    
    // Strict modifier check? 
    // Usually if I ask for Ctrl+Z, Ctrl+Shift+Z should NOT trigger it?
    // For now, let's implement strict checking: if mod is NOT requested but IS pressed, fail?
    // Common behavior: simple inclusion. Ctrl+Z usually triggers on Ctrl+Shift+Z unless Shift+Z is also bound.
    // Let's stick to "required modifiers are present".
    
    return true;
}

// --- Input Callbacks ---

static void push_event(InputSystem* sys, InputEvent event) {
    if (sys->queue.count < MAX_INPUT_EVENTS) {
        sys->queue.events[sys->queue.count++] = event;
    }
}

static void on_mouse_button(PlatformWindow* window, PlatformMouseButton button, PlatformInputAction action, int mods, void* user_data) {
    (void)window;
    InputSystem* sys = (InputSystem*)user_data;
    if (!sys) return;
    
    // State
    if (button == PLATFORM_MOUSE_BUTTON_LEFT) {
        if (action == PLATFORM_PRESS) {
            sys->state.mouse_down = true;
        } else if (action == PLATFORM_RELEASE) {
            sys->state.mouse_down = false;
        }
    }

    // Event
    InputEvent event = {0};
    if (action == PLATFORM_PRESS) event.type = INPUT_EVENT_MOUSE_PRESSED;
    else if (action == PLATFORM_RELEASE) event.type = INPUT_EVENT_MOUSE_RELEASED;
    
    if (event.type != INPUT_EVENT_NONE) {
        event.data.mouse_button.button = (int)button;
        event.data.mouse_button.mods = mods;
        event.data.mouse_button.x = sys->state.mouse_x;
        event.data.mouse_button.y = sys->state.mouse_y;
        push_event(sys, event);
    }
}

static void on_scroll(PlatformWindow* window, double xoff, double yoff, void* user_data) {
    (void)window;
    InputSystem* sys = (InputSystem*)user_data;
    if (!sys) return;

    // Event
    InputEvent event = {0};
    event.type = INPUT_EVENT_SCROLL;
    event.data.scroll.dx = (float)xoff;
    event.data.scroll.dy = (float)yoff;
    push_event(sys, event);
}

static void on_key(PlatformWindow* window, int key, int scancode, PlatformInputAction action, int mods, void* user_data) {
    (void)window;
    InputSystem* sys = (InputSystem*)user_data;
    if (!sys) return;
    
    // State Update
    if (key >= 0 && key <= INPUT_KEY_LAST) {
        if (action == PLATFORM_PRESS) {
            sys->state.keys[key] = true;
        } else if (action == PLATFORM_RELEASE) {
            sys->state.keys[key] = false;
        }
        // Repeat does not change boolean state
    }

    // Event
    InputEvent event = {0};
    if (action == PLATFORM_PRESS) event.type = INPUT_EVENT_KEY_PRESSED;
    else if (action == PLATFORM_RELEASE) event.type = INPUT_EVENT_KEY_RELEASED;
    else if (action == PLATFORM_REPEAT) event.type = INPUT_EVENT_KEY_REPEAT;

    if (event.type != INPUT_EVENT_NONE) {
        event.data.key.key = key;
        event.data.key.scancode = scancode;
        event.data.key.mods = mods;
        push_event(sys, event);
    }
}

static void on_char(PlatformWindow* window, unsigned int codepoint, void* user_data) {
    (void)window;
    InputSystem* sys = (InputSystem*)user_data;
    if (!sys) return;
    
    // Event
    InputEvent event = {0};
    event.type = INPUT_EVENT_CHAR;
    event.data.character.codepoint = codepoint;
    push_event(sys, event);
}

static void on_cursor_pos(PlatformWindow* window, double x, double y, void* user_data) {
    (void)window;
    InputSystem* sys = (InputSystem*)user_data;
    if (!sys) return;

    // State
    sys->state.mouse_x = (float)x;
    sys->state.mouse_y = (float)y;

    // Event
    InputEvent event = {0};
    event.type = INPUT_EVENT_MOUSE_MOVED;
    event.data.mouse.x = (float)x;
    event.data.mouse.y = (float)y;
    push_event(sys, event);
}

// --- Public API ---

InputSystem* input_system_create(PlatformWindow* window) {
    if (!window) return NULL;
    
    InputSystem* sys = (InputSystem*)calloc(1, sizeof(InputSystem));
    if (!sys) return NULL;

    // Register Callbacks with 'sys' as user_data
    platform_set_mouse_button_callback(window, on_mouse_button, sys);
    platform_set_scroll_callback(window, on_scroll, sys);
    platform_set_key_callback(window, on_key, sys);
    platform_set_char_callback(window, on_char, sys);
    platform_set_cursor_pos_callback(window, on_cursor_pos, sys);

    return sys;
}

void input_system_destroy(InputSystem* sys) {
    if (sys) {
        free(sys);
    }
}

void input_system_update(InputSystem* sys) {
    if (!sys) return;

    // Reset per-frame input
    sys->queue.count = 0;
    
    sys->_prev_mouse_down = sys->state.mouse_down;
    memcpy(sys->_prev_keys, sys->state.keys, sizeof(sys->state.keys));
}

// --- Action Mapping ---

void input_map_action(InputSystem* sys, const char* action_name, InputKey default_key, int modifiers) {
    if (!sys || !action_name) return;

    StringId id = str_id(action_name);

    // Update existing or add new
    for (int i = 0; i < sys->action_count; ++i) {
        if (sys->actions[i].name_hash == id) {
            sys->actions[i].key = default_key;
            sys->actions[i].mods = modifiers;
            return;
        }
    }

    if (sys->action_count < MAX_ACTIONS) {
        sys->actions[sys->action_count].name_hash = id;
        sys->actions[sys->action_count].key = default_key;
        sys->actions[sys->action_count].mods = modifiers;
        sys->action_count++;
        // LOG_DEBUG("Mapped Action '%s' to Key %d (Mods: %d)", action_name, default_key, modifiers);
    } else {
        LOG_ERROR("Input Action limit reached! Cannot map '%s'", action_name);
    }
}

bool input_is_action_pressed(const InputSystem* sys, const char* action_name) {
    if (!sys || !action_name) return false;
    StringId id = str_id(action_name);

    for (int i = 0; i < sys->action_count; ++i) {
        if (sys->actions[i].name_hash == id) {
            InputKey k = sys->actions[i].key;
            if (k == INPUT_KEY_UNKNOWN) return false; // Unbound
            
            bool key_down = sys->state.keys[k];
            bool mods_ok = check_modifiers(sys, sys->actions[i].mods);
            return key_down && mods_ok;
        }
    }
    return false;
}

bool input_is_action_just_pressed(const InputSystem* sys, const char* action_name) {
    if (!sys || !action_name) return false;
    StringId id = str_id(action_name);

    for (int i = 0; i < sys->action_count; ++i) {
        if (sys->actions[i].name_hash == id) {
            InputKey k = sys->actions[i].key;
            if (k == INPUT_KEY_UNKNOWN) return false;

            bool key_down = sys->state.keys[k];
            bool prev_down = sys->_prev_keys[k];
            bool mods_ok = check_modifiers(sys, sys->actions[i].mods);

            // Note: We don't check if modifiers were "just pressed", usually just the trigger key.
            return key_down && !prev_down && mods_ok;
        }
    }
    return false;
}

bool input_is_action_released(const InputSystem* sys, const char* action_name) {
    if (!sys || !action_name) return false;
    StringId id = str_id(action_name);

    for (int i = 0; i < sys->action_count; ++i) {
        if (sys->actions[i].name_hash == id) {
            InputKey k = sys->actions[i].key;
            if (k == INPUT_KEY_UNKNOWN) return false;

            bool key_down = sys->state.keys[k];
            bool prev_down = sys->_prev_keys[k];
            // Modifiers state at release moment? 
            // Usually we want to know if it WAS pressed and NOW isn't.
            return !key_down && prev_down;
        }
    }
    return false;
}

// --- Accessors ---

float input_get_mouse_x(const InputSystem* sys) {
    return sys ? sys->state.mouse_x : 0.0f;
}

float input_get_mouse_y(const InputSystem* sys) {
    return sys ? sys->state.mouse_y : 0.0f;
}

bool input_is_mouse_down(const InputSystem* sys) {
    return sys ? sys->state.mouse_down : false;
}

bool input_is_key_down(const InputSystem* sys, InputKey key) {
    if (!sys || key < 0 || key > INPUT_KEY_LAST) return false;
    return sys->state.keys[key];
}

int input_get_event_count(const InputSystem* sys) {
    return sys ? sys->queue.count : 0;
}

const InputEvent* input_get_event(const InputSystem* sys, int index) {
    if (!sys || index < 0 || index >= sys->queue.count) return NULL;
    return &sys->queue.events[index];
}


==================================================
FILE START: src/engine/input/input.h
==================================================
#ifndef ENGINE_INPUT_H
#define ENGINE_INPUT_H

#include <stdint.h>
#include <stdbool.h>

// Forward declarations
typedef struct PlatformWindow PlatformWindow;
typedef struct InputSystem InputSystem; // Opaque handle

// Event-based Input System
typedef enum InputEventType {
    INPUT_EVENT_NONE = 0,
    INPUT_EVENT_KEY_PRESSED,
    INPUT_EVENT_KEY_RELEASED,
    INPUT_EVENT_KEY_REPEAT,
    INPUT_EVENT_MOUSE_MOVED,
    INPUT_EVENT_MOUSE_PRESSED,
    INPUT_EVENT_MOUSE_RELEASED,
    INPUT_EVENT_SCROLL,
    INPUT_EVENT_CHAR
} InputEventType;

typedef struct InputEvent {
    InputEventType type;
    union {
        struct {
            int key;
            int scancode;
            int mods;
        } key;
        struct {
            float x, y;
        } mouse;
        struct {
            int button;
            int mods;
            float x, y;
        } mouse_button;
        struct {
            float dx, dy;
        } scroll;
        struct {
            uint32_t codepoint;
        } character;
    } data;
} InputEvent;

#define MAX_INPUT_EVENTS 256

// --- Input Codes (Matches GLFW for convenience) ---

typedef enum InputKey {
    /* The unknown key */
    INPUT_KEY_UNKNOWN = -1,

    /* Printable keys */
    INPUT_KEY_SPACE = 32,
    INPUT_KEY_APOSTROPHE = 39,  /* ' */
    INPUT_KEY_COMMA = 44,       /* , */
    INPUT_KEY_MINUS = 45,       /* - */
    INPUT_KEY_PERIOD = 46,      /* . */
    INPUT_KEY_SLASH = 47,       /* / */
    INPUT_KEY_0 = 48,
    INPUT_KEY_1 = 49,
    INPUT_KEY_2 = 50,
    INPUT_KEY_3 = 51,
    INPUT_KEY_4 = 52,
    INPUT_KEY_5 = 53,
    INPUT_KEY_6 = 54,
    INPUT_KEY_7 = 55,
    INPUT_KEY_8 = 56,
    INPUT_KEY_9 = 57,
    INPUT_KEY_SEMICOLON = 59,   /* ; */
    INPUT_KEY_EQUAL = 61,       /* = */
    INPUT_KEY_A = 65,
    INPUT_KEY_B = 66,
    INPUT_KEY_C = 67,
    INPUT_KEY_D = 68,
    INPUT_KEY_E = 69,
    INPUT_KEY_F = 70,
    INPUT_KEY_G = 71,
    INPUT_KEY_H = 72,
    INPUT_KEY_I = 73,
    INPUT_KEY_J = 74,
    INPUT_KEY_K = 75,
    INPUT_KEY_L = 76,
    INPUT_KEY_M = 77,
    INPUT_KEY_N = 78,
    INPUT_KEY_O = 79,
    INPUT_KEY_P = 80,
    INPUT_KEY_Q = 81,
    INPUT_KEY_R = 82,
    INPUT_KEY_S = 83,
    INPUT_KEY_T = 84,
    INPUT_KEY_U = 85,
    INPUT_KEY_V = 86,
    INPUT_KEY_W = 87,
    INPUT_KEY_X = 88,
    INPUT_KEY_Y = 89,
    INPUT_KEY_Z = 90,
    INPUT_KEY_LEFT_BRACKET = 91,  /* [ */
    INPUT_KEY_BACKSLASH = 92,     /* \ */
    INPUT_KEY_RIGHT_BRACKET = 93, /* ] */
    INPUT_KEY_GRAVE_ACCENT = 96,  /* ` */
    INPUT_KEY_WORLD_1 = 161,      /* non-US #1 */
    INPUT_KEY_WORLD_2 = 162,      /* non-US #2 */

    /* Function keys */
    INPUT_KEY_ESCAPE = 256,
    INPUT_KEY_ENTER = 257,
    INPUT_KEY_TAB = 258,
    INPUT_KEY_BACKSPACE = 259,
    INPUT_KEY_INSERT = 260,
    INPUT_KEY_DELETE = 261,
    INPUT_KEY_RIGHT = 262,
    INPUT_KEY_LEFT = 263,
    INPUT_KEY_DOWN = 264,
    INPUT_KEY_UP = 265,
    INPUT_KEY_PAGE_UP = 266,
    INPUT_KEY_PAGE_DOWN = 267,
    INPUT_KEY_HOME = 268,
    INPUT_KEY_END = 269,
    INPUT_KEY_CAPS_LOCK = 280,
    INPUT_KEY_SCROLL_LOCK = 281,
    INPUT_KEY_NUM_LOCK = 282,
    INPUT_KEY_PRINT_SCREEN = 283,
    INPUT_KEY_PAUSE = 284,
    INPUT_KEY_F1 = 290,
    INPUT_KEY_F2 = 291,
    INPUT_KEY_F3 = 292,
    INPUT_KEY_F4 = 293,
    INPUT_KEY_F5 = 294,
    INPUT_KEY_F6 = 295,
    INPUT_KEY_F7 = 296,
    INPUT_KEY_F8 = 297,
    INPUT_KEY_F9 = 298,
    INPUT_KEY_F10 = 299,
    INPUT_KEY_F11 = 300,
    INPUT_KEY_F12 = 301,
    INPUT_KEY_F13 = 302,
    INPUT_KEY_F14 = 303,
    INPUT_KEY_F15 = 304,
    INPUT_KEY_F16 = 305,
    INPUT_KEY_F17 = 306,
    INPUT_KEY_F18 = 307,
    INPUT_KEY_F19 = 308,
    INPUT_KEY_F20 = 309,
    INPUT_KEY_F21 = 310,
    INPUT_KEY_F22 = 311,
    INPUT_KEY_F23 = 312,
    INPUT_KEY_F24 = 313,
    INPUT_KEY_F25 = 314,
    INPUT_KEY_KP_0 = 320,
    INPUT_KEY_KP_1 = 321,
    INPUT_KEY_KP_2 = 322,
    INPUT_KEY_KP_3 = 323,
    INPUT_KEY_KP_4 = 324,
    INPUT_KEY_KP_5 = 325,
    INPUT_KEY_KP_6 = 326,
    INPUT_KEY_KP_7 = 327,
    INPUT_KEY_KP_8 = 328,
    INPUT_KEY_KP_9 = 329,
    INPUT_KEY_KP_DECIMAL = 330,
    INPUT_KEY_KP_DIVIDE = 331,
    INPUT_KEY_KP_MULTIPLY = 332,
    INPUT_KEY_KP_SUBTRACT = 333,
    INPUT_KEY_KP_ADD = 334,
    INPUT_KEY_KP_ENTER = 335,
    INPUT_KEY_KP_EQUAL = 336,
    INPUT_KEY_LEFT_SHIFT = 340,
    INPUT_KEY_LEFT_CONTROL = 341,
    INPUT_KEY_LEFT_ALT = 342,
    INPUT_KEY_LEFT_SUPER = 343,
    INPUT_KEY_RIGHT_SHIFT = 344,
    INPUT_KEY_RIGHT_CONTROL = 345,
    INPUT_KEY_RIGHT_ALT = 346,
    INPUT_KEY_RIGHT_SUPER = 347,
    INPUT_KEY_MENU = 348,
    
    INPUT_KEY_LAST = INPUT_KEY_MENU
} InputKey;

typedef enum InputMod {
    INPUT_MOD_NONE = 0,
    INPUT_MOD_SHIFT = 0x0001,
    INPUT_MOD_CONTROL = 0x0002,
    INPUT_MOD_ALT = 0x0004,
    INPUT_MOD_SUPER = 0x0008,
    INPUT_MOD_CAPS_LOCK = 0x0010,
    INPUT_MOD_NUM_LOCK = 0x0020
} InputMod;

// --- Lifecycle ---

InputSystem* input_system_create(struct PlatformWindow* window);
void input_system_destroy(InputSystem* sys);
void input_system_update(InputSystem* sys);

// --- Action Mapping API (Phase 6) ---

/**
 * @brief Maps a logical action name to a physical key binding.
 * @param action_name Unique name for the action (e.g., "Undo", "Save").
 * @param default_key The key that triggers this action.
 * @param modifiers Bitmask of InputMod flags required (e.g., INPUT_MOD_CONTROL).
 */
void input_map_action(InputSystem* sys, const char* action_name, InputKey default_key, int modifiers);

/**
 * @brief Checks if an action is currently being held down.
 */
bool input_is_action_pressed(const InputSystem* sys, const char* action_name);

/**
 * @brief Checks if an action was just pressed this frame.
 */
bool input_is_action_just_pressed(const InputSystem* sys, const char* action_name);

/**
 * @brief Checks if an action was just released this frame.
 */
bool input_is_action_released(const InputSystem* sys, const char* action_name);

// --- Accessors (State) ---

float input_get_mouse_x(const InputSystem* sys);
float input_get_mouse_y(const InputSystem* sys);
bool input_is_mouse_down(const InputSystem* sys);
bool input_is_key_down(const InputSystem* sys, InputKey key);

// --- Accessors (Events) ---

// Returns the number of events recorded this frame
int input_get_event_count(const InputSystem* sys);

// Returns a pointer to the event at index 'index', or NULL if out of bounds.
// The pointer is valid only until the next update.
const InputEvent* input_get_event(const InputSystem* sys, int index);

#endif // ENGINE_INPUT_H


==================================================
FILE START: src/engine/input/internal/input_internal.h
==================================================
#ifndef ENGINE_INPUT_INTERNAL_H
#define ENGINE_INPUT_INTERNAL_H

#include "engine/input/input.h"
#include "foundation/string/string_id.h"

// Internal Event Queue
typedef struct InputEventQueue {
    InputEvent events[MAX_INPUT_EVENTS];
    int count;
} InputEventQueue;

// Internal State (Polling)
typedef struct InputState {
    float mouse_x, mouse_y;
    double last_scroll_y;
    bool mouse_down;
    
    // Key state for the current frame
    bool keys[INPUT_KEY_LAST + 1];
} InputState;

typedef struct ActionMapping {
    StringId name_hash;
    InputKey key;
    int mods;
} ActionMapping;

#define MAX_ACTIONS 128

// Full System Definition
struct InputSystem {
    InputState state;
    InputEventQueue queue;
    
    // Internal logic
    bool _prev_mouse_down;
    bool _prev_keys[INPUT_KEY_LAST + 1];

    // Action Mappings
    ActionMapping actions[MAX_ACTIONS];
    int action_count;
};

#endif // ENGINE_INPUT_INTERNAL_H


==================================================
FILE START: src/engine/scene/internal/render_packet_internal.h
==================================================
#ifndef RENDER_PACKET_INTERNAL_H
#define RENDER_PACKET_INTERNAL_H

#include "../render_packet.h"
#include "foundation/memory/arena.h"

// The Scene Container implementation
struct Scene {
    // Memory Arena for frame-local scene objects
    // This replaces the malloc/realloc dynamic array pattern
    MemoryArena arena;

    // Pointer to the start of the object array in the arena
    SceneObject* objects;
    
    // Number of objects currently in the arena
    size_t object_count;
    
    SceneCamera camera;
    
    uint64_t frame_number;
};

#endif // RENDER_PACKET_INTERNAL_H


==================================================
FILE START: src/engine/scene/internal/scene_graph.c
==================================================
#include "../scene.h"
#include "scene_graph.h"
#include "foundation/memory/arena.h"
#include "foundation/memory/pool.h"
#include "foundation/math/coordinate_systems.h"
#include "foundation/meta/reflection.h"

#include <stdlib.h>
#include <string.h>

// --- Scene Tree Internal ---

static void destroy_recursive(SceneTree* tree, SceneNode* node) {
    if (!node) return;
    
    SceneNode* child = node->first_child;
    while (child) {
        SceneNode* next = child->next_sibling;
        destroy_recursive(tree, child);
        child = next;
    }
    
    pool_free(tree->node_pool, node);
}

SceneTree* scene_internal_tree_create(SceneAsset* assets, size_t arena_size) {
    SceneTree* tree = (SceneTree*)calloc(1, sizeof(SceneTree));
    if (!tree) return NULL;
    
    if (!arena_init(&tree->arena, arena_size)) {
        free(tree);
        return NULL;
    }
    
    tree->assets = assets;
    tree->node_pool = pool_create(sizeof(SceneNode), 256);
    return tree;
}

void scene_internal_tree_destroy(SceneTree* tree) {
    if (!tree) return;
    if (tree->root) destroy_recursive(tree, tree->root);
    pool_destroy(tree->node_pool);
    arena_destroy(&tree->arena);
    free(tree);
}

// --- Node Management Internal ---

SceneNode* scene_internal_node_create(SceneTree* tree, const SceneNodeSpec* spec, void* data, const MetaStruct* meta) {
    if (!tree || !spec) return NULL;

    SceneNode* node = (SceneNode*)pool_alloc(tree->node_pool);
    node->spec = spec;
    node->data_ptr = data;
    node->meta = meta;
    node->flags = spec->flags;
    
    // Initial transform update
    node->local_matrix = mat4_identity();
    node->world_matrix = mat4_identity();

    // Create static children defined in spec
    for (size_t i = 0; i < spec->child_count; ++i) {
        SceneNode* child = scene_internal_node_create(tree, spec->children[i], data, meta);
        if (child) {
            scene_internal_node_add_child(node, child);
        }
    }
    
    return node;
}

void scene_internal_node_add_child(SceneNode* parent, SceneNode* child) {
    if (!parent || !child) return;
    
    child->parent = parent;
    child->next_sibling = NULL;
    child->prev_sibling = parent->last_child;
    
    if (parent->last_child) {
        parent->last_child->next_sibling = child;
    } else {
        parent->first_child = child;
    }
    parent->last_child = child;
    parent->child_count++;
    
    child->flags |= SCENE_FLAG_DIRTY;
}

void scene_internal_node_clear_children(SceneNode* parent, SceneTree* tree) {
    if (!parent || !tree) return;
    
    SceneNode* curr = parent->first_child;
    while (curr) {
        SceneNode* next = curr->next_sibling;
        destroy_recursive(tree, curr);
        curr = next;
    }
    parent->first_child = NULL;
    parent->last_child = NULL;
    parent->child_count = 0;
}

// --- Transform System Internal ---

void scene_internal_node_update_transforms(SceneNode* node, const Mat4* parent_world) {
    if (!node) return;

    // 1. Build Local Matrix (from spec transform)
    const SceneTransformSpec* trans = &node->spec->transform;
    
    Vec3 scale = { 
        trans->local_scale.x == 0 ? 1.0f : trans->local_scale.x, 
        trans->local_scale.y == 0 ? 1.0f : trans->local_scale.y, 
        trans->local_scale.z == 0 ? 1.0f : trans->local_scale.z 
    };
    Mat4 mat_s = mat4_scale(scale);
    
    EulerAngles euler = { trans->local_rotation.x, trans->local_rotation.y, trans->local_rotation.z };
    Mat4 mat_r = mat4_rotation_euler(euler);
    
    Mat4 mat_t = mat4_translation(trans->local_position);
    
    Mat4 mat_rs = mat4_multiply(&mat_r, &mat_s);
    node->local_matrix = mat4_multiply(&mat_t, &mat_rs);

    // 2. World Matrix
    if (parent_world) {
        node->world_matrix = mat4_multiply(parent_world, &node->local_matrix);
    } else {
        node->world_matrix = node->local_matrix;
    }

    // 3. Recurse
    for (SceneNode* child = node->first_child; child; child = child->next_sibling) {
        scene_internal_node_update_transforms(child, &node->world_matrix);
    }
}

SceneNode* scene_internal_node_find_by_id(SceneNode* root, const char* id) {
    if (!root || !id) return NULL;
    StringId target = str_id(id);
    if ((root->spec ? root->spec->id : 0) == target) return root;
    
    for (SceneNode* child = root->first_child; child; child = child->next_sibling) {
        SceneNode* found = scene_internal_node_find_by_id(child, id);
        if (found) return found;
    }
    return NULL;
}


==================================================
FILE START: src/engine/scene/internal/scene_graph.h
==================================================
#ifndef SCENE_GRAPH_H
#define SCENE_GRAPH_H

#include "scene_tree_internal.h"

// Internal Scene Graph Functions (called by scene_system.c)

SceneTree* scene_internal_tree_create(SceneAsset* assets, size_t arena_size);
void scene_internal_tree_destroy(SceneTree* tree);

SceneNode* scene_internal_node_create(SceneTree* tree, const SceneNodeSpec* spec, void* data, const struct MetaStruct* meta);
void scene_internal_node_add_child(SceneNode* parent, SceneNode* child);
void scene_internal_node_clear_children(SceneNode* parent, SceneTree* tree);
void scene_internal_node_update_transforms(SceneNode* node, const Mat4* parent_world);
SceneNode* scene_internal_node_find_by_id(SceneNode* root, const char* id);

#endif // SCENE_GRAPH_H


==================================================
FILE START: src/engine/scene/internal/scene_loader.c
==================================================
#include "scene_tree_internal.h"
#include "../scene.h"
#include "scene_loader.h"
#include "foundation/config/simple_yaml.h"
#include "foundation/logger/logger.h"
#include "foundation/memory/arena.h"
#include "foundation/meta/reflection.h"
#include "foundation/platform/fs.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

// --- Helper Functions ---

static SceneNodeKind parse_kind(const char* type_str);

static SceneNodeKind parse_kind(const char* type_str) {
    if (!type_str) return SCENE_NODE_KIND_CONTAINER;

    const MetaEnum* kind_enum = meta_get_enum("SceneNodeKind");
    int val = 0;
    if (kind_enum && meta_enum_get_value(kind_enum, type_str, &val)) {
        return (SceneNodeKind)val;
    }
    
    // Default to container for everything else
    return SCENE_NODE_KIND_CONTAINER;
}

static SceneNodeSpec* ui_node_spec_copy(SceneAsset* asset, const SceneNodeSpec* src) {
    if (!src) return NULL;
    SceneNodeSpec* dst = scene_asset_push_node(asset);
    memcpy(dst, src, sizeof(SceneNodeSpec));
    
    // We share string pointers because they are all in the same Asset Arena
    
    // Deep copy children
    if (src->child_count > 0) {
        dst->children = (SceneNodeSpec**)arena_alloc_zero(&asset->arena, src->child_count * sizeof(SceneNodeSpec*));
        for (size_t i = 0; i < src->child_count; ++i) {
            dst->children[i] = ui_node_spec_copy(asset, src->children[i]);
        }
    }
    
    if (src->item_template) {
        dst->item_template = ui_node_spec_copy(asset, src->item_template);
    }
    
    return dst;
}

// --- Generic Recursive Parser for Structs ---

static void parse_struct_fields(void* instance, const MetaStruct* meta, const ConfigNode* map, SceneAsset* asset);

static void parse_field_value(void* instance, const MetaField* field, const ConfigNode* val, SceneAsset* asset) {
    if (!instance || !field || !val) return;
    
    void* field_ptr = (char*)instance + field->offset;

    if (field->type == META_TYPE_STRUCT) {
         const MetaStruct* sub_meta = meta_get_struct(field->type_name);
         if (sub_meta) {
             parse_struct_fields(field_ptr, sub_meta, val, asset);
         }
    } else if (val->type == CONFIG_NODE_SEQUENCE && (field->type >= META_TYPE_VEC2 && field->type <= META_TYPE_VEC4)) {
         int vec_size = field->type - META_TYPE_VEC2 + 2;
         float* f_ptr = (float*)field_ptr;
         for (int k = 0; k < vec_size; ++k) {
             float v = 0.0f;
             if (k < (int)val->item_count && val->items[k]->scalar) {
                 v = (float)atof(val->items[k]->scalar);
             } else if (k == 3) {
                 v = 1.0f; 
             }
             f_ptr[k] = v;
         }
    } else if (field->type == META_TYPE_STRING) {
         const char* s = val->scalar ? val->scalar : "";
         char* str_copy = arena_push_string(&asset->arena, s);
         *(char**)field_ptr = str_copy;
    } else {
         const char* s = val->scalar ? val->scalar : "";
         if (!meta_set_from_string(instance, field, s)) {
             if (s[0] != '\0' && field->type == META_TYPE_ENUM) {
                 LOG_WARN("UiParser: Unknown enum value '%s' for type '%s'", s, field->type_name);
             }
         }
    }
}

static void parse_struct_fields(void* instance, const MetaStruct* meta, const ConfigNode* map, SceneAsset* asset) {
    if (!instance || !meta || !map || map->type != CONFIG_NODE_MAP) return;

    for (size_t i = 0; i < map->pair_count; ++i) {
        const char* key = map->pairs[i].key;
        const ConfigNode* val = map->pairs[i].value;
        if (!key || !val) continue;

        const MetaField* field = meta_find_field(meta, key);
        if (!field) {
            LOG_WARN("UiParser: Unknown field '%s' in struct '%s'", key, meta->name);
            continue;
        }
        
        parse_field_value(instance, field, val, asset);
    }
}



// --- Recursive Loader ---

static SceneNodeSpec* load_recursive(SceneAsset* asset, const ConfigNode* node) {
    if (!node || node->type != CONFIG_NODE_MAP) return NULL;

    SceneNodeSpec* spec = NULL;

    // 1. Determine Base (Template or Kind)
    const ConfigNode* type_node = config_node_map_get(node, "type");
    if (type_node && type_node->scalar) {
        if (strcmp(type_node->scalar, "instance") == 0) {
            const ConfigNode* inst_node = config_node_map_get(node, "instance");
            if (inst_node && inst_node->scalar) {
                SceneNodeSpec* template_spec = scene_asset_get_template(asset, inst_node->scalar);
                if (template_spec) spec = ui_node_spec_copy(asset, template_spec);
            }
        } else {
            SceneNodeSpec* template_spec = scene_asset_get_template(asset, type_node->scalar);
            if (template_spec) spec = ui_node_spec_copy(asset, template_spec);
        }
    }

    if (!spec) {
        spec = scene_asset_push_node(asset);
        // Default values for new nodes
        spec->layout.width = -1.0f;
        spec->layout.height = -1.0f;
        spec->style.color = (Vec4){1,1,1,1};
        spec->style.text_color = (Vec4){1,1,1,1};
        spec->style.caret_color = (Vec4){1,1,1,1};
    }

    const MetaStruct* meta = meta_get_struct("SceneNodeSpec");
    
    // Temporary Binding Storage (Max 64 per node to be safe)
    SceneBindingSpec temp_bindings[64];
    size_t temp_binding_count = 0;
    
    // Copy inherited bindings if any (from template)
    if (spec->binding_count > 0 && spec->bindings) {
        for (size_t i = 0; i < spec->binding_count && temp_binding_count < 64; ++i) {
            temp_bindings[temp_binding_count++] = spec->bindings[i];
        }
    }

    // Iterate all pairs in the YAML map to apply overrides
    for (size_t i = 0; i < node->pair_count; ++i) {
        const char* key = node->pairs[i].key;
        const ConfigNode* val = node->pairs[i].value;
        if (!key || !val) continue;

        if (strcmp(key, "import") == 0) {
            LOG_ERROR("UiParser: 'import' is not supported inside children (Node ID:%u). Use a Template and 'type: instance' instead.", 
                      spec->id);
            continue;
        }

        if (strcmp(key, "type") == 0) {
             if (scene_asset_get_template(asset, val->scalar) == NULL) {
                 spec->kind = parse_kind(val->scalar);
             }
             continue;
        }

        if (strcmp(key, "instance") == 0) continue;


        
        // --- Bindings V2 Parsing ---
        if (strcmp(key, "bindings") == 0) {
            if (val->type == CONFIG_NODE_SEQUENCE) {
                for (size_t k = 0; k < val->item_count && temp_binding_count < 64; ++k) {
                    ConfigNode* b_node = val->items[k];
                    if (b_node->type == CONFIG_NODE_MAP) {
                        const ConfigNode* t_node = config_node_map_get(b_node, "target");
                        const ConfigNode* s_node = config_node_map_get(b_node, "source");
                        if (t_node && s_node && t_node->scalar && s_node->scalar) {
                             temp_bindings[temp_binding_count].target = arena_push_string(&asset->arena, t_node->scalar);
                             temp_bindings[temp_binding_count].source = arena_push_string(&asset->arena, s_node->scalar);
                             temp_binding_count++;
                        }
                    }
                }
            }
            continue;
        }
        
        // --- Legacy / Shorthand Binding Handling (REMOVED) ---

        if (strcmp(key, "children") == 0) {
            if (val->type == CONFIG_NODE_SEQUENCE) {
                spec->child_count = val->item_count;
                spec->children = (SceneNodeSpec**)arena_alloc_zero(&asset->arena, spec->child_count * sizeof(SceneNodeSpec*));
                for (size_t k = 0; k < spec->child_count; ++k) {
                    spec->children[k] = load_recursive(asset, val->items[k]);
                }
            }
            continue;
        }
        
        if (strcmp(key, "item_template") == 0) {
            if (val->type == CONFIG_NODE_SCALAR) {
                SceneNodeSpec* t = scene_asset_get_template(asset, val->scalar);
                if (t) spec->item_template = ui_node_spec_copy(asset, t);
                else LOG_ERROR("UiParser: Template '%s' not found for item_template", val->scalar);
            } else {
                spec->item_template = load_recursive(asset, val);
            }
            continue;
        }
        
        // --- Generic Reflection ---
        const MetaField* field = meta_find_field(meta, key);

        if (field) {
            // Special handling for 'text' field to support Binding Syntax "{...}"
            if (strcmp(key, "text") == 0 && val->scalar && val->scalar[0] == '{' && temp_binding_count < 64) {
                 size_t len = strlen(val->scalar);
                 if (len > 2) {
                     char* buf = arena_push_string_n(&asset->arena, val->scalar + 1, len - 2);
                     // Convert to binding
                     temp_bindings[temp_binding_count].target = "text";
                     temp_bindings[temp_binding_count].source = buf;
                     temp_binding_count++;
                     spec->text = NULL; 
                     continue;
                 }
            }

            parse_field_value(spec, field, val, asset);

        } else if (strcmp(key, "provider") == 0) {
             if (val->scalar) {
                 spec->provider_id = str_id(val->scalar);
             }
        } else {
            LOG_WARN("UiParser: Unknown field '%s' in SceneNodeSpec (Node ID:%u). Check indentation or spelling.", key, spec->id);
        }
    }

    // Finalize Bindings
    if (temp_binding_count > 0) {
        spec->binding_count = temp_binding_count;
        spec->bindings = (SceneBindingSpec*)arena_alloc_zero(&asset->arena, spec->binding_count * sizeof(SceneBindingSpec));
        for (size_t k = 0; k < spec->binding_count; ++k) {
            spec->bindings[k] = temp_bindings[k];
        }
    } else {
        spec->binding_count = 0;
        spec->bindings = NULL;
    }

    return spec;
}

// --- Generic Reflection for Scalars ---

static ConfigNode* resolve_import(MemoryArena* scratch, const ConfigNode* node) {
    if (node->type == CONFIG_NODE_MAP) {
        const ConfigNode* import_val = config_node_map_get(node, "import");
        if (import_val && import_val->scalar) {
            char* text = fs_read_text(scratch, import_val->scalar);
            if (text) {
                ConfigNode* imported_root = NULL;
                ConfigError err;
                if (simple_yaml_parse(scratch, text, &imported_root, &err)) {
                    return imported_root;
                }
            }
        }
    }
    return NULL;
}

// --- Validation ---

static void validate_node(SceneNodeSpec* spec, const char* path) {
    if (!spec) return;
    
    if (spec->layout.type == SCENE_LAYOUT_SPLIT_H || spec->layout.type == SCENE_LAYOUT_SPLIT_V) {
        if (spec->child_count != 2) {
            LOG_ERROR("UiParser: Split container ID:%u MUST have exactly 2 children (has %zu).", spec->id, spec->child_count);
        }
    }
    
    for (size_t i = 0; i < spec->child_count; ++i) {
        validate_node(spec->children[i], path);
    }
}

SceneAsset* scene_internal_asset_load_from_file(const char* path) {
    if (!path) return NULL;

    LOG_TRACE("UiParser: Loading UI definition from file: %s", path);

    // Scratch Arena for parsing (2MB should be plenty for config files)
    MemoryArena scratch;
    if (!arena_init(&scratch, 2 * 1024 * 1024)) {
        LOG_ERROR("UiParser: Failed to init scratch arena");
        return NULL;
    }

    char* text = fs_read_text(&scratch, path);
    if (!text) {
        LOG_ERROR("UiParser: Failed to read file %s", path);
        arena_destroy(&scratch);
        return NULL;
    }

    ConfigNode* root = NULL;
    ConfigError err = {0};
    if (!simple_yaml_parse(&scratch, text, &root, &err)) {
        LOG_ERROR("UiParser: YAML Parse error in %s (line %d, col %d): %s", path, err.line, err.column, err.message);
        arena_destroy(&scratch);
        return NULL;
    }

    // Create Asset (Owner)
    SceneAsset* asset = scene_asset_create(64 * 1024);
    if (!asset) {
        arena_destroy(&scratch);
        return NULL;
    }

    // Parse Templates (if any)
    const ConfigNode* templates_node = config_node_map_get(root, "templates");
    if (templates_node && templates_node->type == CONFIG_NODE_MAP) {
        for (size_t i = 0; i < templates_node->pair_count; ++i) {
            const char* t_name = templates_node->pairs[i].key;
            const ConfigNode* t_val = templates_node->pairs[i].value;
            
            ConfigNode* t_actual = resolve_import(&scratch, t_val);
            
            SceneNodeSpec* spec = load_recursive(asset, t_actual ? t_actual : t_val);
            if (spec) {
                SceneTemplate* t = (SceneTemplate*)arena_alloc_zero(&asset->arena, sizeof(SceneTemplate));
                t->name = arena_push_string(&asset->arena, t_name);
                t->spec = spec;
                t->next = asset->templates;
                asset->templates = t;
                LOG_TRACE("UiParser: Registered template '%s'", t->name);
            }
        }
    }

    ConfigNode* root_actual = resolve_import(&scratch, root);
    asset->root = load_recursive(asset, root_actual ? root_actual : root);
    
    validate_node(asset->root, path);
    
    arena_destroy(&scratch);
    return asset;
}


==================================================
FILE START: src/engine/scene/internal/scene_loader.h
==================================================
#ifndef SCENE_LOADER_H
#define SCENE_LOADER_H

#include "../scene.h"

SceneAsset* scene_internal_asset_load_from_file(const char* path);

#endif // SCENE_LOADER_H


==================================================
FILE START: src/engine/scene/internal/scene_tree_internal.h
==================================================
#ifndef SCENE_TREE_INTERNAL_H
#define SCENE_TREE_INTERNAL_H

#include "../scene.h"
#include "foundation/memory/arena.h"
#include "foundation/memory/pool.h"

// --- COMPONENTS ---

// Component: Transform (Shared with 3D)
typedef struct SceneTransformSpec {
    Vec3 local_position;    // REFLECT
    Vec3 local_rotation;    // REFLECT
    Vec3 local_scale;       // REFLECT
} SceneTransformSpec;

// Component: UI Layout (Shared with 2D)
typedef struct UiLayoutSpec {
    int type;               // REFLECT (SceneLayoutStrategy)
    int layer;              // REFLECT (SceneLayer)
    float width;            // REFLECT
    float height;           // REFLECT
    float padding;          // REFLECT
    float spacing;          // REFLECT
    float split_ratio;      // REFLECT
    float x;                // REFLECT
    float y;                // REFLECT
} UiLayoutSpec;

// Component: UI Styling
typedef struct UiStyleSpec {
    int render_mode;        // REFLECT (SceneRenderMode)
    Vec4 color;             // REFLECT
    Vec4 hover_color;       // REFLECT
    Vec4 active_color;      // REFLECT
    Vec4 text_color;        // REFLECT
    Vec4 caret_color;       // REFLECT
    float active_tint;      // REFLECT
    float hover_tint;       // REFLECT
    float text_scale;       // REFLECT
    float caret_width;      // REFLECT
    float caret_height;     // REFLECT
    float animation_speed;  // REFLECT
    float border_l;         // REFLECT
    float border_t;         // REFLECT
    float border_r;         // REFLECT
    float border_b;         // REFLECT
    float corner_radius;    // REFLECT
    float tex_w;            // REFLECT
    float tex_h;            // REFLECT
    StringId texture;       // REFLECT
} UiStyleSpec;

// Component: 3D Mesh
typedef struct SceneMeshSpec {
    StringId mesh_id;     // REFLECT
    StringId material_id; // REFLECT
} SceneMeshSpec;

// Data Binding V2
typedef struct SceneBindingSpec {
    char* target; // REFLECT
    char* source; // REFLECT
} SceneBindingSpec;

// --- SPECIFICATION ---

struct SceneNodeSpec {
    // 1. Identity
    StringId id;            // REFLECT
    int kind;               // REFLECT (SceneNodeKind)
    uint32_t flags;         // REFLECT (SceneFlags)
    uint32_t interaction_flags; // REFLECT (SceneInteractionFlags)
    uint32_t ui_flags;      // REFLECT (UiFlags)
    
    // 2. Components (Fat Spec for now to support parser)
    SceneTransformSpec transform; // REFLECT
    UiLayoutSpec layout;          // REFLECT
    UiStyleSpec style;            // REFLECT
    SceneMeshSpec mesh;           // REFLECT
    
    // 3. Data Bindings
    SceneBindingSpec* bindings;   // REFLECT
    size_t binding_count;         // REFLECT
    
    // 4. Content & Collections
    char* collection;             // REFLECT
    char* template_selector;      // REFLECT
    char* text;                   // REFLECT
    char* text_source;            // REFLECT

    // 5. Hierarchy
    struct SceneNodeSpec* item_template; // REFLECT
    struct SceneNodeSpec** children;     // REFLECT
    size_t child_count;                  // REFLECT
    
    // 6. Commands
    StringId on_click;            // REFLECT
    StringId on_change;           // REFLECT
    
    // 7. Misc
    StringId provider_id;         // REFLECT
    
    // Extensibility
    void* system_spec; 
};

// --- RUNTIME NODE ---

struct SceneNode {
    const SceneNodeSpec* spec; // The DNA
    
    // Hierarchy
    struct SceneNode* parent;
    struct SceneNode* first_child;
    struct SceneNode* last_child;
    struct SceneNode* next_sibling;
    struct SceneNode* prev_sibling;
    size_t child_count;
    
    // Data Context
    void* data_ptr;         // Pointer to C struct
    const struct MetaStruct* meta; // Type info

    // --- TRANSFORM SYSTEM ---
    Mat4 local_matrix;    // T * R * S
    Mat4 world_matrix;    // ParentWorld * Local
    
    // --- UI / INTERACTION ---
    Rect rect;            // Computed layout relative to parent
    Rect screen_rect;     // Computed screen space
    Vec4 render_color;    // Animated color
    
    StringId on_click_cmd_id;
    StringId on_change_cmd_id;

    bool is_hovered;
    bool is_active;
    bool is_focused;
    float hover_t;
    int cursor_idx;

    // Scrolling & Content
    float scroll_x;
    float scroll_y;
    float content_w;
    float content_h;

    // Data Binding (Runtime Cache)
    void* ui_bindings; 
    size_t ui_binding_count;
    char cached_text[128];

    // State
    uint32_t flags;             // Runtime flags (SceneFlags)
    uint32_t interaction_flags; // Runtime flags (SceneInteractionFlags)
    uint32_t ui_flags;          // Runtime flags (UiFlags)
};

// --- SCENE TREE ---

struct SceneTree {
    MemoryArena arena;
    MemoryPool* node_pool; 
    SceneNode* root;
    SceneAsset* assets;
};

// --- ASSET ---

typedef struct SceneTemplate {
    char* name;
    SceneNodeSpec* spec;
    struct SceneTemplate* next;
} SceneTemplate;

struct SceneAsset {
    MemoryArena arena;
    SceneNodeSpec* root;
    SceneTemplate* templates;
};

#endif // SCENE_TREE_INTERNAL_H


==================================================
FILE START: src/engine/scene/render_packet.h
==================================================
#ifndef RENDER_PACKET_H
#define RENDER_PACKET_H

#include "foundation/math/coordinate_systems.h"
#include <stddef.h> // size_t
#include <stdint.h> // uint64_t

// --- Basic Types ---

// Simple mesh descriptor for the Unified Scene
typedef struct Mesh {
    float *positions; // xyz triplets
    size_t position_count;
    float *uvs; // uv pairs
    size_t uv_count;
    unsigned int *indices;
    size_t index_count;
    float aabb_min[3];
    float aabb_max[3];
} Mesh;

typedef enum RenderLayer {
    LAYER_WORLD_OPAQUE = 0,
    LAYER_WORLD_TRANSPARENT,
    LAYER_UI_BACKGROUND,
    LAYER_UI_CONTENT,
    LAYER_UI_OVERLAY,
    LAYER_COUNT
} RenderLayer;

typedef enum ScenePrimitiveType {
    SCENE_PRIM_QUAD = 0, // Standard Mesh/Quad
    SCENE_PRIM_CURVE = 1 // SDF Bezier Curve
} ScenePrimitiveType;

// Standard Rendering Modes for UI/2D Shader
typedef enum SceneShaderMode {
    SCENE_MODE_SOLID        = 0, // Solid Color
    SCENE_MODE_TEXTURED     = 1, // Font/Bitmap
    SCENE_MODE_USER_TEXTURE = 2, // Compute Result/Image
    SCENE_MODE_9_SLICE      = 3, // UI Panel
    SCENE_MODE_SDF_BOX      = 4  // Rounded Box
} SceneShaderMode;

// --- Scene Components ---

typedef struct SceneCamera {
    Mat4 view_matrix;
    Mat4 proj_matrix;
} SceneCamera;

typedef struct SceneObject {
    // --- Identification & Classification ---
    int id;
    RenderLayer layer;
    ScenePrimitiveType prim_type;
    
    // --- Transform ---
    Vec3 position;
    Vec3 rotation; 
    Vec3 scale;
    
    // --- Rendering ---
    const Mesh* mesh; 

    // --- Material & Styling ---
    Vec4 color; 
    Vec4 uv_rect; // Texture Subset (xy=off, zw=scale)

    // --- Advanced / Generic Shader Data ---
    // Domain-specific data accessed via union to save memory and improve semantics
    union {
        // UI Context
        struct {
            Vec4 style_params; // x=type, y=radius, z=width, w=height
            Vec4 extra_params; // Borders etc.
            Vec4 clip_rect;    // Scissor bounds (x,y,w,h)
        } ui;

        // PBR / 3D Context (Reserved)
        struct {
            Vec4 pbr_data;     // x=roughness, y=metal, z=ao
            Vec4 user_data;
            Vec4 emission;
        } pbr;

        // Raw Access
        struct {
            Vec4 params_0; // Maps to style_params
            Vec4 params_1; // Maps to extra_params
            Vec4 params_2; // Maps to clip_rect
        } raw;
    };

    // --- Instancing (Data-Driven Visualization) ---
    void* instance_buffer; // Pointer to GpuBuffer (if massive instancing)
    size_t instance_count;
} SceneObject;

// --- The Scene Container ---

typedef struct Scene Scene;

// --- API ---

// Lifecycle
Scene* scene_create(void);
void scene_destroy(Scene* scene);

void scene_clear(Scene* scene);

// Adds an object to the scene. 
// Uses a fast linear allocator (MemoryArena), so this is very cheap.
void scene_add_object(Scene* scene, SceneObject obj); 

// Accessors
void scene_set_camera(Scene* scene, SceneCamera camera);
SceneCamera scene_get_camera(const Scene* scene);

void scene_set_frame_number(Scene* scene, uint64_t frame_number);
uint64_t scene_get_frame_number(const Scene* scene);

// Returns pointer to internal linear array and sets out_count. 
// Do not free or persist this pointer across frames.
const SceneObject* scene_get_all_objects(const Scene* scene, size_t* out_count);

// --- High-Level Drawing API ---

void scene_push_rect_sdf(Scene* scene, Vec3 pos, Vec2 size, Vec4 color, float radius, float border, Vec4 clip_rect);
void scene_push_circle_sdf(Scene* scene, Vec3 center, float radius, Vec4 color, Vec4 clip_rect);
void scene_push_curve(Scene* scene, Vec3 start, Vec3 end, float thickness, Vec4 color, Vec4 clip_rect);

// New Basic Primitives
void scene_push_quad(Scene* scene, Vec3 pos, Vec2 size, Vec4 color, Vec4 clip_rect);
void scene_push_quad_textured(Scene* scene, Vec3 pos, Vec2 size, Vec4 color, Vec4 uv_rect, Vec4 clip_rect);
void scene_push_quad_9slice(Scene* scene, Vec3 pos, Vec2 size, Vec4 color, Vec4 uv_rect, Vec2 texture_size, Vec4 borders, Vec4 clip_rect);

#endif // RENDER_PACKET_H


==================================================
FILE START: src/engine/scene/scene.c
==================================================
#include "scene.h"
#include "render_packet.h"
#include "internal/render_packet_internal.h"
#include "internal/scene_tree_internal.h"
#include "internal/scene_graph.h"
#include "foundation/memory/arena.h"
#include "foundation/string/string_id.h"
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <math.h>

#define SCENE_ARENA_SIZE (4 * 1024 * 1024)

// --- System Lifecycle ---

void scene_system_init(void) {
    // Core system init
}

void scene_system_shutdown(void) {
    // Core system shutdown
}

// --- Scene Lifecycle ---

Scene* scene_create(void) {
    Scene* scene = (Scene*)malloc(sizeof(Scene));
    if (scene) {
        memset(scene, 0, sizeof(Scene));
        if (!arena_init(&scene->arena, SCENE_ARENA_SIZE)) {
            free(scene);
            return NULL;
        }
        scene->objects = (SceneObject*)scene->arena.base;
    }
    return scene;
}

void scene_destroy(Scene* scene) {
    if (!scene) return;
    arena_destroy(&scene->arena);
    free(scene);
}

void scene_add_object(Scene* scene, SceneObject obj) {
    if (!scene) return;
    SceneObject* new_slot = (SceneObject*)arena_alloc(&scene->arena, sizeof(SceneObject));
    if (new_slot) {
        *new_slot = obj;
        scene->object_count++;
    }
}

void scene_clear(Scene* scene) {
    if (!scene) return;
    arena_reset(&scene->arena);
    scene->object_count = 0;
    scene->objects = (SceneObject*)scene->arena.base;
}

void scene_set_camera(Scene* scene, SceneCamera camera) {
    if (scene) scene->camera = camera;
}

SceneCamera scene_get_camera(const Scene* scene) {
    if (scene) return scene->camera;
    SceneCamera empty = {0};
    return empty;
}

void scene_set_frame_number(Scene* scene, uint64_t frame_number) {
    if (scene) scene->frame_number = frame_number;
}

uint64_t scene_get_frame_number(const Scene* scene) {
    return scene ? scene->frame_number : 0;
}

const SceneObject* scene_get_all_objects(const Scene* scene, size_t* out_count) {
    if (!scene) {
        if (out_count) *out_count = 0;
        return NULL;
    }
    if (out_count) *out_count = scene->object_count;
    return scene->objects;
}

// --- High-Level Drawing API ---

void scene_push_rect_sdf(Scene* scene, Vec3 pos, Vec2 size, Vec4 color, float radius, float border, Vec4 clip_rect) {
    SceneObject obj = {0};
    obj.prim_type = SCENE_PRIM_QUAD;
    obj.position = pos;
    obj.scale = (Vec3){size.x, size.y, 1.0f};
    obj.color = color;
    obj.ui.clip_rect = clip_rect;
    obj.uv_rect = (Vec4){0.0f, 0.0f, 1.0f, 1.0f}; 
    obj.ui.style_params.x = (float)SCENE_MODE_SDF_BOX;
    obj.ui.style_params.y = radius;
    obj.ui.style_params.z = border;
    scene_add_object(scene, obj);
}

void scene_push_circle_sdf(Scene* scene, Vec3 center, float radius, Vec4 color, Vec4 clip_rect) {
    scene_push_rect_sdf(scene, 
        (Vec3){center.x - radius, center.y - radius, center.z}, 
        (Vec2){radius * 2.0f, radius * 2.0f}, 
        color, radius, 1.0f, clip_rect
    );
}

void scene_push_curve(Scene* scene, Vec3 start, Vec3 end, float thickness, Vec4 color, Vec4 clip_rect) {
    float min_x = start.x < end.x ? start.x : end.x;
    float max_x = start.x > end.x ? start.x : end.x;
    float min_y = start.y < end.y ? start.y : end.y;
    float max_y = start.y > end.y ? start.y : end.y;
    float padding = 50.0f;
    min_x -= padding; min_y -= padding;
    max_x += padding; max_y += padding;
    float width = max_x - min_x;
    float height = max_y - min_y;
    if (width < 1.0f) width = 1.0f;
    if (height < 1.0f) height = 1.0f;

    float u1 = (start.x - min_x) / width;
    float v1 = (start.y - min_y) / height;
    float u2 = (end.x - min_x) / width;
    float v2 = (end.y - min_y) / height;

    SceneObject wire = {0};
    wire.prim_type = SCENE_PRIM_CURVE;
    wire.position = (Vec3){min_x + width * 0.5f, min_y + height * 0.5f, start.z};
    wire.scale = (Vec3){width, height, 1.0f};
    wire.color = color;
    wire.ui.clip_rect = clip_rect;
    wire.uv_rect = (Vec4){0.0f, 0.0f, 1.0f, 1.0f};
    wire.ui.style_params.y = 1.0f; 
    wire.ui.extra_params = (Vec4){u1, v1, u2, v2};
    wire.ui.style_params.z = thickness / height; 
    wire.ui.style_params.w = width / height; 
    scene_add_object(scene, wire);
}

void scene_push_quad(Scene* scene, Vec3 pos, Vec2 size, Vec4 color, Vec4 clip_rect) {
    SceneObject obj = {0};
    obj.prim_type = SCENE_PRIM_QUAD;
    obj.position = pos;
    obj.scale = (Vec3){size.x, size.y, 1.0f};
    obj.color = color;
    obj.ui.clip_rect = clip_rect;
    obj.ui.style_params.x = (float)SCENE_MODE_SOLID;
    obj.uv_rect = (Vec4){0.0f, 0.0f, 1.0f, 1.0f}; 
    scene_add_object(scene, obj);
}

void scene_push_quad_textured(Scene* scene, Vec3 pos, Vec2 size, Vec4 color, Vec4 uv_rect, Vec4 clip_rect) {
    SceneObject obj = {0};
    obj.prim_type = SCENE_PRIM_QUAD;
    obj.position = pos;
    obj.scale = (Vec3){size.x, size.y, 1.0f};
    obj.color = color;
    obj.ui.clip_rect = clip_rect;
    obj.uv_rect = uv_rect;
    obj.ui.style_params.x = (float)SCENE_MODE_TEXTURED;
    scene_add_object(scene, obj);
}

void scene_push_quad_9slice(Scene* scene, Vec3 pos, Vec2 size, Vec4 color, Vec4 uv_rect, Vec2 texture_size, Vec4 borders, Vec4 clip_rect) {
    SceneObject obj = {0};
    obj.prim_type = SCENE_PRIM_QUAD;
    obj.position = pos;
    obj.scale = (Vec3){size.x, size.y, 1.0f};
    obj.color = color;
    obj.ui.clip_rect = clip_rect;
    obj.uv_rect = uv_rect;
    obj.ui.style_params.x = (float)SCENE_MODE_9_SLICE;
    obj.ui.style_params.z = texture_size.x; 
    obj.ui.style_params.w = texture_size.y; 
    obj.ui.extra_params = borders;
    scene_add_object(scene, obj);
}

// --- Scene Tree Wrappers ---

SceneTree* scene_tree_create(SceneAsset* assets, size_t arena_size) {
    return scene_internal_tree_create(assets, arena_size);
}

void scene_tree_destroy(SceneTree* tree) {
    scene_internal_tree_destroy(tree);
}

SceneNode* scene_tree_get_root(const SceneTree* tree) {
    return tree ? tree->root : NULL;
}

void scene_tree_set_root(SceneTree* tree, SceneNode* root) {
    if (tree) tree->root = root;
}

// --- Scene Node Wrappers ---

SceneNode* scene_node_create(SceneTree* tree, const SceneNodeSpec* spec, void* data, const struct MetaStruct* meta) {
    return scene_internal_node_create(tree, spec, data, meta);
}

void scene_node_add_child(SceneNode* parent, SceneNode* child) {
    scene_internal_node_add_child(parent, child);
}

void scene_node_remove_child(SceneNode* parent, SceneNode* child) {
    (void)parent; (void)child;
}

void scene_node_clear_children(SceneNode* parent, SceneTree* tree) {
    scene_internal_node_clear_children(parent, tree);
}

void scene_node_update_transforms(SceneNode* node, const Mat4* parent_world) {
    scene_internal_node_update_transforms(node, parent_world);
}

SceneNode* scene_node_find_by_id(SceneNode* root, const char* id) {
    return scene_internal_node_find_by_id(root, id);
}

// --- Accessors ---

StringId scene_node_get_id(const SceneNode* node) {
    return (node && node->spec) ? node->spec->id : 0;
}

void* scene_node_get_data(const SceneNode* node) {
    return node ? node->data_ptr : NULL;
}

SceneNode* scene_node_get_parent(const SceneNode* node) {
    return node ? node->parent : NULL;
}

const struct MetaStruct* scene_node_get_meta(const SceneNode* node) {
    return node ? node->meta : NULL;
}

==================================================
FILE START: src/engine/scene/scene.h
==================================================
#ifndef SCENE_H
#define SCENE_H

#include "foundation/math/coordinate_systems.h"
#include "foundation/string/string_id.h"
#include "scene_asset.h" 
#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

// Forward Declarations
typedef struct SceneNode SceneNode;
typedef struct SceneTree SceneTree;
typedef struct MetaStruct MetaStruct;

// --- SCENE CORE API ---

// Lifecycle
void scene_system_init(void);
void scene_system_shutdown(void);

SceneTree* scene_tree_create(SceneAsset* assets, size_t arena_size);
void scene_tree_destroy(SceneTree* tree);

SceneNode* scene_tree_get_root(const SceneTree* tree);
void scene_tree_set_root(SceneTree* tree, SceneNode* root);

// Node Management
SceneNode* scene_node_create(SceneTree* tree, const SceneNodeSpec* spec, void* data, const MetaStruct* meta);
void scene_node_add_child(SceneNode* parent, SceneNode* child);
void scene_node_remove_child(SceneNode* parent, SceneNode* child);
void scene_node_clear_children(SceneNode* parent, SceneTree* tree);

// Transform & Update
void scene_node_update_transforms(SceneNode* node, const Mat4* parent_world);

// Accessors
StringId scene_node_get_id(const SceneNode* node);
SceneNode* scene_node_find_by_id(SceneNode* root, const char* id);
void* scene_node_get_data(const SceneNode* node);
SceneNode* scene_node_get_parent(const SceneNode* node);
const struct MetaStruct* scene_node_get_meta(const SceneNode* node);

#endif // SCENE_H

==================================================
FILE START: src/engine/scene/scene_asset.c
==================================================
#include "scene_asset.h"
#include "internal/scene_tree_internal.h"
#include "internal/scene_loader.h"
#include "foundation/memory/arena.h"
#include <stdlib.h>
#include <string.h>

SceneAsset* scene_asset_create(size_t arena_size) {
    SceneAsset* asset = (SceneAsset*)calloc(1, sizeof(SceneAsset));
    if (!asset) return NULL;
    if (!arena_init(&asset->arena, arena_size)) {
        free(asset);
        return NULL;
    }
    return asset;
}

void scene_asset_destroy(SceneAsset* asset) {
    if (!asset) return;
    arena_destroy(&asset->arena);
    free(asset);
}

SceneAsset* scene_asset_load_from_file(const char* path) {
    return scene_internal_asset_load_from_file(path);
}

SceneNodeSpec* scene_asset_push_node(SceneAsset* asset) {
    if (!asset) return NULL;
    return (SceneNodeSpec*)arena_alloc_zero(&asset->arena, sizeof(SceneNodeSpec));
}

SceneNodeSpec* scene_asset_get_template(SceneAsset* asset, const char* name) {
    if (!asset || !name) return NULL;
    SceneTemplate* t = asset->templates;
    while (t) {
        if (t->name && strcmp(t->name, name) == 0) return t->spec;
        t = t->next;
    }
    return NULL;
}

SceneNodeSpec* scene_asset_get_root(const SceneAsset* asset) {
    return asset ? asset->root : NULL;
}


==================================================
FILE START: src/engine/scene/scene_asset.h
==================================================
#ifndef SCENE_ASSET_H
#define SCENE_ASSET_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

// --- Forward Declarations ---
typedef struct SceneAsset SceneAsset;
typedef struct SceneNodeSpec SceneNodeSpec;

// --- Enums & Flags (The Schema) ---

typedef enum SceneFlags {
    SCENE_FLAG_NONE        = 0,
    SCENE_FLAG_HIDDEN      = 1 << 0,
    SCENE_FLAG_DIRTY       = 1 << 1, // Transform needs update
    SCENE_FLAG_CLIPPED     = 1 << 2,
    
    SCENE_FLAG_SYSTEM_BIT  = 1 << 8
} SceneFlags; // REFLECT

typedef enum SceneInteractionFlags {
    SCENE_INTERACTION_NONE       = 0,
    SCENE_INTERACTION_CLICKABLE  = 1 << 0,
    SCENE_INTERACTION_DRAGGABLE  = 1 << 1,
    SCENE_INTERACTION_FOCUSABLE  = 1 << 3,
    SCENE_INTERACTION_HOVERABLE  = 1 << 4
} SceneInteractionFlags; // REFLECT

typedef enum UiFlags {
    UI_FLAG_NONE       = 0,
    UI_FLAG_SCROLLABLE = 1 << 0,
    UI_FLAG_EDITABLE   = 1 << 1
} UiFlags; // REFLECT

typedef enum SceneNodeKind {
    SCENE_NODE_KIND_CONTAINER,
    SCENE_NODE_KIND_TEXT,
    SCENE_NODE_KIND_VIEWPORT
} SceneNodeKind; // REFLECT

typedef enum SceneLayoutStrategy {
    SCENE_LAYOUT_FLEX_COLUMN,
    SCENE_LAYOUT_FLEX_ROW,
    SCENE_LAYOUT_CANVAS,
    SCENE_LAYOUT_SPLIT_H,
    SCENE_LAYOUT_SPLIT_V
} SceneLayoutStrategy; // REFLECT

typedef enum SceneLayer {
    SCENE_LAYER_NORMAL = 0,
    SCENE_LAYER_OVERLAY
} SceneLayer; // REFLECT

typedef enum SceneRenderMode {
    SCENE_RENDER_MODE_DEFAULT = 0,
    SCENE_RENDER_MODE_BOX,
    SCENE_RENDER_MODE_TEXT,
    SCENE_RENDER_MODE_IMAGE,
    SCENE_RENDER_MODE_BEZIER
} SceneRenderMode; // REFLECT

// --- Scene Asset API ---

SceneAsset* scene_asset_create(size_t arena_size);
void scene_asset_destroy(SceneAsset* asset);
SceneAsset* scene_asset_load_from_file(const char* path);

SceneNodeSpec* scene_asset_push_node(SceneAsset* asset);
SceneNodeSpec* scene_asset_get_template(SceneAsset* asset, const char* name);
SceneNodeSpec* scene_asset_get_root(const SceneAsset* asset);

#endif // SCENE_ASSET_H


==================================================
FILE START: src/engine/text/font.c
==================================================
#include "font.h"
#include "internal/font_internal.h"
#include "stb_truetype.h"
#include "foundation/platform/platform.h"
#include "foundation/logger/logger.h"
#include "foundation/memory/arena.h"
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#define ATLAS_WIDTH 1024
#define ATLAS_HEIGHT 1024
#define FONT_SIZE_PIXELS 32.0f
#define UI_RECT_SIZE 32
#define UI_RECT_X 8
#define UI_RECT_Y 0
#define FONT_ARENA_SIZE (4 * 1024 * 1024) // 4MB

static float smoothstep(float edge0, float edge1, float x) {
    float t = (x - edge0) / (edge1 - edge0);
    if (t < 0.0f) t = 0.0f;
    if (t > 1.0f) t = 1.0f;
    return t * t * (3.0f - 2.0f * t);
}

Font* font_create(const void* ttf_data, size_t ttf_size) {
    if (!ttf_data || ttf_size == 0) {
        LOG_ERROR("Font data is null or empty");
        return NULL;
    }

    Font* font = (Font*)calloc(1, sizeof(Font));
    if (!font) {
        LOG_FATAL("Failed to allocate Font struct");
        return NULL;
    }

    if (!arena_init(&font->arena, FONT_ARENA_SIZE)) {
        LOG_FATAL("Failed to initialize Font Arena");
        free(font);
        return NULL;
    }

    // Copy TTF data to our arena to ensure persistence
    font->ttf_buffer = arena_alloc(&font->arena, ttf_size);
    if (!font->ttf_buffer) {
        LOG_FATAL("Failed to allocate font buffer in arena");
        arena_destroy(&font->arena);
        free(font);
        return NULL;
    }
    memcpy(font->ttf_buffer, ttf_data, ttf_size);

    if (!stbtt_InitFont(&font->fontinfo, font->ttf_buffer, 0)) {
        LOG_ERROR("Failed to init stb_truetype");
        arena_destroy(&font->arena);
        free(font);
        return NULL;
    }

    // Build Atlas
    font->width = ATLAS_WIDTH;
    font->height = ATLAS_HEIGHT;
    // Use arena_alloc_zero to clear memory automatically
    font->pixels = arena_alloc_zero(&font->arena, font->width * font->height);
    memset(font->glyph_valid, 0, sizeof(font->glyph_valid));

    font->font_scale = stbtt_ScaleForPixelHeight(&font->fontinfo, FONT_SIZE_PIXELS);
    
    // Reserve space for white pixel at (0,0) and UI rect at (2,0)
    // We will start glyphs at y=32 to be safe
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 4; ++j) {
            font->pixels[i * font->width + j] = 255;
        }
    }
    
    // Generate a simple 9-slice rounded rect
    int ui_x = UI_RECT_X, ui_y = UI_RECT_Y, ui_sz = UI_RECT_SIZE;
    for (int j = 0; j < ui_sz; ++j) {
        for (int i = 0; i < ui_sz; ++i) {
            float dx = (float)i - (ui_sz-1)*0.5f;
            float dy = (float)j - (ui_sz-1)*0.5f;
            float d = sqrtf(dx*dx + dy*dy);
            float radius = (ui_sz-1)*0.5f - 2.0f;
            
            // Outer shape
            float alpha = 1.0f - smoothstep(radius, radius + 1.0f, d);
            
            // Border (2px)
            // float inner = radius - 2.0f; // Unused
            
            unsigned char val;
            // We want it to be a bit thicker at borders for visibility
            // if (d > inner) ... else ... -> Combined since both are solid now
            val = (unsigned char)(alpha * 255);
            
            font->pixels[(ui_y + j) * font->width + (ui_x + i)] = val;
        }
    }

    int raw_ascent = 0, raw_descent = 0;
    stbtt_GetFontVMetrics(&font->fontinfo, &raw_ascent, &raw_descent, NULL);
    font->ascent = (int)roundf(raw_ascent * font->font_scale);
    font->descent = (int)roundf(raw_descent * font->font_scale);

    static const int ranges[][2] = { {32, 126}, {0x0400, 0x04FF} }; // ASCII + Cyrillic
    int range_count = (int)(sizeof(ranges) / sizeof(ranges[0]));

    int x = 0, y = 40, rowh = 0; // Start below UI placeholders
    int glyph_count = 0;
    
    for (int r = 0; r < range_count; r++) {
        for (int c = ranges[r][0]; c <= ranges[r][1] && c < GLYPH_CAPACITY; c++) {
            int aw, ah, bx, by;
            unsigned char* bitmap = stbtt_GetCodepointBitmap(&font->fontinfo, 0, font->font_scale, c, &aw, &ah, &bx, &by);
            
            if (x + aw >= font->width) { 
                x = 0; 
                y += rowh; 
                rowh = 0; 
            }
            
            if (y + ah >= font->height) { 
                LOG_ERROR("Font atlas too small!"); 
                stbtt_FreeBitmap(bitmap, NULL); 
                break; 
            }
            
            for (int yy = 0; yy < ah; yy++) {
                for (int xx = 0; xx < aw; xx++) {
                    font->pixels[(y + yy) * font->width + (x + xx)] = bitmap[yy * aw + xx];
                }
            }
            stbtt_FreeBitmap(bitmap, NULL);
            
            int advance, lsb;
            stbtt_GetCodepointHMetrics(&font->fontinfo, c, &advance, &lsb);
            
            int box_x0, box_y0, box_x1, box_y1;
            stbtt_GetCodepointBitmapBox(&font->fontinfo, c, font->font_scale, font->font_scale, &box_x0, &box_y0, &box_x1, &box_y1);
            
            font->glyphs[c].advance = advance * font->font_scale;
            font->glyphs[c].xoff = (float)box_x0;
            font->glyphs[c].yoff = (float)box_y0;
            font->glyphs[c].w = (float)(box_x1 - box_x0);
            font->glyphs[c].h = (float)(box_y1 - box_y0);
            
            font->glyphs[c].u0 = (float)x / (float)font->width;
            font->glyphs[c].v0 = (float)y / (float)font->height;
            font->glyphs[c].u1 = (float)(x + aw) / (float)font->width;
            font->glyphs[c].v1 = (float)(y + ah) / (float)font->height;
            
            font->glyph_valid[c] = true;
            glyph_count++;
            
            x += aw + 1;
            if (ah > rowh) rowh = ah;
        }
    }
    
    LOG_INFO("Font Module: Atlas Built %dx%d, Glyphs: %d, Scale: %.4f", 
        font->width, font->height, glyph_count, font->font_scale);

    return font;
}

void font_destroy(Font* font) {
    if (font) {
        arena_destroy(&font->arena);
        free(font);
    }
}

void font_get_atlas_data(const Font* font, int* width, int* height, unsigned char** pixels) {
    if (!font) {
        if (width) *width = 0;
        if (height) *height = 0;
        if (pixels) *pixels = NULL;
        return;
    }
    if (width) *width = font->width;
    if (height) *height = font->height;
    if (pixels) *pixels = font->pixels;
}

bool font_get_glyph(const Font* font, uint32_t codepoint, Glyph* out_glyph) {
    if (!font || codepoint >= GLYPH_CAPACITY || !font->glyph_valid[codepoint]) {
        return false;
    }
    if (out_glyph) {
        *out_glyph = font->glyphs[codepoint];
    }
    return true;
}

float font_measure_text(const Font* font, const char* text) {
    if (!font || !text) return 0.0f;
    
    float width = 0.0f;
    const char* ptr = text;
    while (*ptr) {
        int advance = 0, lsb = 0;
        stbtt_GetCodepointHMetrics(&((Font*)font)->fontinfo, *ptr, &advance, &lsb);
        width += advance * font->font_scale;
        ptr++;
    }
    return width;
}

void font_get_white_pixel_uv(const Font* font, float* u, float* v) {
    if (font) {
        if (u) *u = 1.0f / (float)font->width;
        if (v) *v = 1.0f / (float)font->height;
    }
}

void font_get_ui_rect_uv(const Font* font, float* u0, float* v0, float* u1, float* v1) {
    if (font) {
        if (u0) *u0 = (float)UI_RECT_X / (float)font->width;
        if (v0) *v0 = (float)UI_RECT_Y / (float)font->height;
        if (u1) *u1 = (float)(UI_RECT_X + UI_RECT_SIZE) / (float)font->width;
        if (v1) *v1 = (float)(UI_RECT_Y + UI_RECT_SIZE) / (float)font->height;
    }
}


==================================================
FILE START: src/engine/text/font.h
==================================================
#ifndef FONT_H
#define FONT_H

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

typedef struct Font Font;

// Initialize the font module using TTF data from memory.
// Returns a new Font instance or NULL on failure.
Font* font_create(const void* ttf_data, size_t ttf_size);

// Clean up resources (pixels, etc.)
void font_destroy(Font* font);

// Get the current atlas texture data (R8 format).
// Used by the renderer backend to upload the texture.
void font_get_atlas_data(const Font* font, int* width, int* height, unsigned char** pixels);

// Measure the width of a text string.
float font_measure_text(const Font* font, const char* text);

// Special UVs
void font_get_white_pixel_uv(const Font* font, float* u, float* v);
void font_get_ui_rect_uv(const Font* font, float* u0, float* v0, float* u1, float* v1);

#endif // FONT_H


==================================================
FILE START: src/engine/text/internal/font_internal.h
==================================================
#ifndef FONT_INTERNAL_H
#define FONT_INTERNAL_H

#include "../font.h"
#include "foundation/memory/arena.h"
#include "stb_truetype.h"

#define GLYPH_CAPACITY 2048

typedef struct {
    float u0, v0, u1, v1; // Texture coordinates in atlas
    float xoff, yoff;     // Offset from cursor to top-left of glyph
    float w, h;           // Glyph size in pixels
    float advance;        // Horizontal advance
} Glyph;

struct Font {
    MemoryArena arena;
    int width;
    int height;
    unsigned char* pixels; // R8 format (alpha/intensity only)
    
    Glyph glyphs[GLYPH_CAPACITY];
    bool glyph_valid[GLYPH_CAPACITY];
    
    stbtt_fontinfo fontinfo;
    unsigned char* ttf_buffer;
    float font_scale;
    int ascent;
    int descent;
};

// Internal function to get a glyph. 
// This is used by text_renderer.c but shouldn't be exposed to the App or other systems.
bool font_get_glyph(const Font* font, uint32_t codepoint, Glyph* out_glyph);

#endif // FONT_INTERNAL_H


==================================================
FILE START: src/engine/text/internal/stb_impl.c
==================================================
#define STB_TRUETYPE_IMPLEMENTATION
#include "stb_truetype.h"


==================================================
FILE START: src/engine/text/text_renderer.c
==================================================
#include "text_renderer.h"
#include "engine/scene/render_packet.h"
#include "engine/text/font.h"
#include "internal/font_internal.h"
#include "foundation/logger/logger.h"
#include <string.h>
#include <stdint.h>

void scene_add_text_clipped(Scene* scene, const Font* font, const char* text, Vec3 pos, float scale, Vec4 color, Vec4 clip_rect) {
    if (!scene || !text || !font) return;

    float cursor_x = pos.x;
    // Shift cursor down to baseline because 'pos' is top-left, 
    // but glyph offsets are relative to baseline.
    float cursor_y = pos.y + (font->ascent * scale);
    
    const char* ptr = text;
    while (*ptr) {
        uint32_t c = (uint32_t)(*ptr);
        Glyph g;
        // Check if font is initialized and has glyph
        if (font_get_glyph(font, c, &g)) {
            // Calculate dimensions
            float scaled_w = g.w * scale;
            float scaled_h = g.h * scale;
            float scaled_xoff = g.xoff * scale;
            float scaled_yoff = g.yoff * scale;
            float scaled_advance = g.advance * scale;

            // Create Scene Object
            SceneObject obj;
            memset(&obj, 0, sizeof(SceneObject));
            
            // Position
            // Assuming Top-Left origin for Quad and Screen
            obj.position.x = cursor_x + scaled_xoff;
            obj.position.y = cursor_y + scaled_yoff;
            obj.position.z = pos.z;
            
            // Scale
            obj.scale.x = scaled_w;
            obj.scale.y = scaled_h;
            obj.scale.z = 1.0f;
            
            // Color
            obj.color = color;
            
            // Texture Params (1.0 = use texture)
            obj.raw.params_0.x = (float)SCENE_MODE_TEXTURED;
            
            // UVs
            obj.uv_rect.x = g.u0;
            obj.uv_rect.y = g.v0;
            obj.uv_rect.z = g.u1 - g.u0; // Width
            obj.uv_rect.w = g.v1 - g.v0; // Height
            
            // Clipping
            obj.ui.clip_rect = clip_rect;
            
            scene_add_object(scene, obj);
            
            cursor_x += scaled_advance;
        }
        ptr++;
    }
}

void scene_add_text(Scene* scene, const Font* font, const char* text, Vec3 pos, float scale, Vec4 color) {
    // Default to infinite clip
    Vec4 infinite_clip = {-10000.0f, -10000.0f, 20000.0f, 20000.0f};
    scene_add_text_clipped(scene, font, text, pos, scale, color, infinite_clip);
    
    static bool logged = false;
    if (!logged) {
        LOG_INFO("Added text '%s' at (%.1f, %.1f)", text, pos.x, pos.y);
        logged = true;
    }
}


==================================================
FILE START: src/engine/text/text_renderer.h
==================================================
#ifndef TEXT_RENDERER_H
#define TEXT_RENDERER_H

#include "foundation/math/coordinate_systems.h" // Needed for Vec3, Vec4 by value

// Forward Declarations
typedef struct Scene Scene;
typedef struct Font Font;

void scene_add_text(Scene* scene, const Font* font, const char* text, Vec3 pos, float scale, Vec4 color);
void scene_add_text_clipped(Scene* scene, const Font* font, const char* text, Vec3 pos, float scale, Vec4 color, Vec4 clip_rect);

#endif // TEXT_RENDERER_H


==================================================
FILE START: src/engine/ui/internal/ui_binding.c
==================================================
#include "../ui_core.h"
#include "ui_internal.h"
#include "foundation/meta/reflection.h"
#include "engine/scene/scene.h"
#include <string.h>
#include <stdio.h>

// --- Binding Target Resolution ---

UiBindingTarget ui_resolve_target_enum(const char* target) {
    if (!target) return BINDING_TARGET_NONE;
    if (strcmp(target, "text") == 0) return BINDING_TARGET_TEXT;
    if (strcmp(target, "visible") == 0) return BINDING_TARGET_VISIBLE;
    
    // Layout
    if (strcmp(target, "layout.x") == 0) return BINDING_TARGET_LAYOUT_X;
    if (strcmp(target, "layout.y") == 0) return BINDING_TARGET_LAYOUT_Y;
    if (strcmp(target, "layout.width") == 0) return BINDING_TARGET_LAYOUT_WIDTH;
    if (strcmp(target, "layout.height") == 0) return BINDING_TARGET_LAYOUT_HEIGHT;
    
    // Style
    if (strcmp(target, "style.color") == 0) return BINDING_TARGET_STYLE_COLOR;
    
    // Transform
    if (strcmp(target, "transform.position.x") == 0) return BINDING_TARGET_TRANSFORM_POS_X;
    if (strcmp(target, "transform.position.y") == 0) return BINDING_TARGET_TRANSFORM_POS_Y;
    if (strcmp(target, "transform.position.z") == 0) return BINDING_TARGET_TRANSFORM_POS_Z;
    
    // Legacy support
    if (strcmp(target, "x") == 0) return BINDING_TARGET_LAYOUT_X;
    if (strcmp(target, "y") == 0) return BINDING_TARGET_LAYOUT_Y;
    if (strcmp(target, "w") == 0) return BINDING_TARGET_LAYOUT_WIDTH;
    if (strcmp(target, "h") == 0) return BINDING_TARGET_LAYOUT_HEIGHT;

    return BINDING_TARGET_NONE;
}

void ui_apply_binding_value(SceneNode* el, UiBinding* b) {
    void* ptr = (char*)scene_node_get_data(el) + b->source_offset;
    const MetaField* f = b->source_field;
    if (!ptr || !f) return;
    
    switch (b->target) {
        case BINDING_TARGET_TEXT: {
            char buf[128];
            buf[0] = '\0';
            
            if (f->type == META_TYPE_STRING) {
                char* s = *(char**)ptr;
                if (s) strncpy(buf, s, 127);
            } else if (f->type == META_TYPE_STRING_ARRAY) {
                strncpy(buf, (char*)ptr, 127);
            } else if (f->type == META_TYPE_FLOAT) {
                snprintf(buf, 128, "%.2f", *(float*)ptr);
            } else if (f->type == META_TYPE_INT) {
                snprintf(buf, 128, "%d", *(int*)ptr);
            } else if (f->type == META_TYPE_BOOL) {
                snprintf(buf, 128, "%s", (*(bool*)ptr) ? "true" : "false");
            }
            
            if (strncmp(el->cached_text, buf, 128) != 0) {
                strncpy(el->cached_text, buf, 127);
                el->cached_text[127] = '\0';
            }
            break;
        }
        case BINDING_TARGET_VISIBLE: {
            bool vis = false;
            if (f->type == META_TYPE_BOOL) vis = *(bool*)ptr;
            else if (f->type == META_TYPE_INT) vis = (*(int*)ptr) != 0;
            
            if (vis) el->flags &= ~SCENE_FLAG_HIDDEN;
            else el->flags |= SCENE_FLAG_HIDDEN;
            break;
        }
        case BINDING_TARGET_LAYOUT_X:
            if (f->type == META_TYPE_FLOAT) el->rect.x = *(float*)ptr;
            break;
        case BINDING_TARGET_LAYOUT_Y:
            if (f->type == META_TYPE_FLOAT) el->rect.y = *(float*)ptr;
            break;
        case BINDING_TARGET_LAYOUT_WIDTH:
            if (f->type == META_TYPE_FLOAT) el->rect.w = *(float*)ptr;
            break;
        case BINDING_TARGET_LAYOUT_HEIGHT:
            if (f->type == META_TYPE_FLOAT) el->rect.h = *(float*)ptr;
            break;
        case BINDING_TARGET_STYLE_COLOR:
            if (f->type == META_TYPE_VEC4) el->render_color = *(Vec4*)ptr;
            break;
        default: break;
    }
}

// --- Collection Resolution ---

int ui_resolve_count(void* data, const MetaStruct* meta, const char* field_name) {
    if (!data || !meta || !field_name) return 0;
    
    char count_name[128];
    snprintf(count_name, sizeof(count_name), "%s_count", field_name);
    const MetaField* f = meta_find_field(meta, count_name);
    if (f && f->type == META_TYPE_INT) return meta_get_int(data, f);
    
    f = meta_find_field(meta, "count");
    if (f && f->type == META_TYPE_INT) return meta_get_int(data, f);
    
    return 0;
}

void ui_node_rebuild_children(SceneNode* el, SceneTree* tree) {
    if (!el || !tree || !el->spec) return;
    
    scene_node_clear_children(el, tree);

    const SceneNodeSpec* spec = el->spec;
    if (!spec->collection || !el->meta || !el->data_ptr) return;

    const MetaField* collection_field = meta_find_field(el->meta, spec->collection);
    if (!collection_field) return;

    int dynamic_count = ui_resolve_count(el->data_ptr, el->meta, spec->collection);
    if (dynamic_count <= 0) return;

    const MetaStruct* item_meta = meta_get_struct(collection_field->type_name);
    if (!item_meta) return;

    void* base_ptr = *(void**)((char*)el->data_ptr + collection_field->offset);
    if (!base_ptr) return;

    bool is_pointer_array = (collection_field->type == META_TYPE_POINTER_ARRAY);

    for (size_t i = 0; i < (size_t)dynamic_count; ++i) {
        void* item_ptr = is_pointer_array ? ((void**)base_ptr)[i] : (char*)base_ptr + (i * item_meta->size);
        if (!item_ptr) continue;

        const SceneNodeSpec* child_spec = spec->item_template;
        // Template selector logic (Omitted for brevity in this step, but should be added back)

        SceneNode* child = ui_node_create(tree, child_spec, item_ptr, item_meta);
        if (child) {
            scene_node_add_child(el, child);
        }
    }
}

void ui_bind_read_string(void* data, const MetaField* field, char* out_buf, size_t buf_size) {
    if (!data || !field || !out_buf || buf_size == 0) return;
    
    out_buf[0] = '\0';

    if (field->type == META_TYPE_STRING || field->type == META_TYPE_STRING_ARRAY) {
        const char* current = meta_get_string(data, field);
        if (current) strncpy(out_buf, current, buf_size - 1);
        out_buf[buf_size - 1] = '\0';
    } else if (field->type == META_TYPE_FLOAT) {
        float val = meta_get_float(data, field);
        snprintf(out_buf, buf_size, "%.2f", val);
    } else if (field->type == META_TYPE_INT) {
        int val = meta_get_int(data, field);
        snprintf(out_buf, buf_size, "%d", val);
    }
}

const UiBinding* ui_node_get_binding(const SceneNode* node, UiBindingTarget target) {
    if (!node || !node->ui_bindings) return NULL;
    const UiBinding* bindings = (const UiBinding*)node->ui_bindings;
    for (size_t i = 0; i < node->ui_binding_count; ++i) {
        if (bindings[i].target == target) return &bindings[i];
    }
    return NULL;
}

void ui_node_write_binding_float(SceneNode* node, UiBindingTarget target, float value) {
    const UiBinding* b = ui_node_get_binding(node, target);
    if (b && b->source_field && node->data_ptr) {
        void* ptr = (char*)node->data_ptr + b->source_offset;
        if (b->source_field->type == META_TYPE_FLOAT) {
            *(float*)ptr = value;
        } else if (b->source_field->type == META_TYPE_INT) {
            *(int*)ptr = (int)value;
        }
    }
}

void ui_node_write_binding_string(SceneNode* node, UiBindingTarget target, const char* value) {
    const UiBinding* b = ui_node_get_binding(node, target);
    if (b && b->source_field && node->data_ptr) {
        void* parent = (char*)node->data_ptr + (b->source_offset - b->source_field->offset);
        meta_set_string(parent, b->source_field, value);
    }
}


==================================================
FILE START: src/engine/ui/internal/ui_binding.h
==================================================
#ifndef UI_BINDING_H
#define UI_BINDING_H

#include "../ui_core.h" 
#include "foundation/meta/reflection.h"

// --- Binding Struct ---

typedef struct UiBinding {
    UiBindingTarget target;
    const struct MetaField* source_field;
    size_t source_offset;
} UiBinding;

// --- Binding Functions ---

void ui_bind_read_string(void* data, const struct MetaField* field, char* out_buf, size_t buf_size);
UiBindingTarget ui_resolve_target_enum(const char* target);
void ui_apply_binding_value(SceneNode* el, UiBinding* b);
int ui_resolve_count(void* data, const struct MetaStruct* meta, const char* field_name);

#endif // UI_BINDING_H


==================================================
FILE START: src/engine/ui/internal/ui_command_system.c
==================================================
#include "ui_command_system.h"
#include "../ui_input.h"
#include "foundation/logger/logger.h"
#include <string.h>
#include <stdlib.h>

#define MAX_COMMANDS 128

typedef struct UiCommand {
    StringId id;
    char* name; // Debug only
    UiCommandCallback callback;
    void* user_data;
} UiCommand;

static UiCommand g_commands[MAX_COMMANDS];
static int g_command_count = 0;

void ui_command_init(void) {
    memset(g_commands, 0, sizeof(g_commands));
    g_command_count = 0;
}

void ui_command_shutdown(void) {
    for (int i = 0; i < g_command_count; ++i) {
        if (g_commands[i].name) {
            free(g_commands[i].name);
            g_commands[i].name = NULL;
        }
    }
    g_command_count = 0;
}

void ui_command_register(const char* name, UiCommandCallback callback, void* user_data) {
    if (g_command_count >= MAX_COMMANDS) {
        LOG_ERROR("CommandSystem: Max commands reached (%d)", MAX_COMMANDS);
        return;
    }
    
    StringId id = str_id(name);

    // Check if already exists
    for (int i = 0; i < g_command_count; ++i) {
        if (g_commands[i].id == id) {
            g_commands[i].callback = callback;
            g_commands[i].user_data = user_data;
            return;
        }
    }
    
    g_commands[g_command_count].id = id;
    g_commands[g_command_count].name = strdup(name);
    g_commands[g_command_count].callback = callback;
    g_commands[g_command_count].user_data = user_data;
    g_command_count++;
    
    LOG_DEBUG("CommandSystem: Registered command '%s' (Hash: %u)", name, id);
}

void ui_command_execute_id(StringId id, SceneNode* target) {
    if (id == 0) return;
    
    for (int i = 0; i < g_command_count; ++i) {
        if (g_commands[i].id == id) {
            if (g_commands[i].callback) {
                g_commands[i].callback(g_commands[i].user_data, target);
            }
            return;
        }
    }
    
    // Warn only on first fail? No, just warn.
    // LOG_WARN("CommandSystem: Command ID %u not found", id);
}


==================================================
FILE START: src/engine/ui/internal/ui_command_system.h
==================================================
#ifndef UI_COMMAND_SYSTEM_H
#define UI_COMMAND_SYSTEM_H

#include "../ui_core.h"

// Internal Initialization
void ui_command_init(void);
void ui_command_shutdown(void);

// Implementation handles these
// void ui_command_register(const char* name, UiCommandCallback callback, void* user_data);
// void ui_command_execute_id(StringId id, SceneNode* target);

#endif // UI_COMMAND_SYSTEM_H


==================================================
FILE START: src/engine/ui/internal/ui_input.c
==================================================
#include "ui_input.h"
#include "ui_command_system.h"
#include "ui_internal.h"
#include "foundation/logger/logger.h"
#include "foundation/meta/reflection.h"
#include "engine/input/input.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>

#define UI_MAX_EVENTS 64
#define UI_SCROLL_SPEED 20.0f
#define UI_DRAG_THRESHOLD_SQ 9.0f

// ... Helper Functions ...

static void push_event(UiInputContext* ctx, UiEventType type, SceneNode* target) {
    if (ctx->event_count < UI_MAX_EVENTS) {
        ctx->events[ctx->event_count].type = type;
        ctx->events[ctx->event_count].target = target;
        ctx->event_count++;
    }
}

// --- Public API ---

void ui_input_init(UiInputContext* ctx) {
    memset(ctx, 0, sizeof(UiInputContext));
}

UiInputContext* ui_input_create(void) {
    UiInputContext* ctx = (UiInputContext*)calloc(1, sizeof(UiInputContext));
    if (ctx) ui_input_init(ctx);
    return ctx;
}

void ui_input_destroy(UiInputContext* ctx) {
    free(ctx);
}

bool ui_input_pop_event(UiInputContext* ctx, UiEvent* out_event) {
    if (!ctx || ctx->event_count == 0) return false;
    *out_event = ctx->events[0];
    // Shift remaining events
    for (int i = 0; i < ctx->event_count - 1; ++i) {
        ctx->events[i] = ctx->events[i+1];
    }
    ctx->event_count--;
    return true;
}

// --- Internal Logic Breakdown ---

static SceneNode* hit_test_recursive(SceneNode* el, float x, float y) {
    if (!el || !el->spec) return NULL;
    
    // Skip hidden or non-interactive (unless specifically handled)
    if (el->flags & SCENE_FLAG_HIDDEN) return NULL;
    
    // Check clipping
    if ((el->flags & SCENE_FLAG_CLIPPED)) {
        if (x < el->screen_rect.x || x > el->screen_rect.x + el->screen_rect.w ||
            y < el->screen_rect.y || y > el->screen_rect.y + el->screen_rect.h) {
            return NULL;
        }
    }

    // Check children first (reverse order for Z-sorting: last drawn is top)
    for (SceneNode* child = el->last_child; child; child = child->prev_sibling) {
        SceneNode* hit = hit_test_recursive(child, x, y);
        if (hit) return hit;
    }

    // Check Self
    if (x >= el->screen_rect.x && x <= el->screen_rect.x + el->screen_rect.w &&
        y >= el->screen_rect.y && y <= el->screen_rect.y + el->screen_rect.h) {
        return el;
    }

    return NULL;
}

static void update_hover_state(UiInputContext* ctx, SceneNode* root, const InputSystem* input) {
    SceneNode* prev_hovered = ctx->hovered;
    float mx = input_get_mouse_x(input);
    float my = input_get_mouse_y(input);
    
    ctx->hovered = hit_test_recursive(root, mx, my);

    if (prev_hovered && prev_hovered != ctx->hovered) {
        prev_hovered->is_hovered = false;
    }
    if (ctx->hovered) {
        ctx->hovered->is_hovered = true;
    }
}

static void handle_scroll_event(UiInputContext* ctx, const InputEvent* event) {
    if (event->type != INPUT_EVENT_SCROLL) return;
    float dx = event->data.scroll.dx;
    float dy = event->data.scroll.dy;

    SceneNode* target = ctx->hovered;
    while (target) {
    // 3. Scroll
    if (target->ui_flags & UI_FLAG_SCROLLABLE) {
            target->scroll_y -= dy * UI_SCROLL_SPEED; 
            target->scroll_x += dx * UI_SCROLL_SPEED;

            // Clamp Y
            float max_scroll_y = target->content_h - (target->rect.h - target->spec->layout.padding * 2);
            if (max_scroll_y < 0) max_scroll_y = 0;
            if (target->scroll_y < 0) target->scroll_y = 0;
            if (target->scroll_y > max_scroll_y) target->scroll_y = max_scroll_y;

            // Clamp X
            float max_scroll_x = target->content_w - (target->rect.w - target->spec->layout.padding * 2);
            if (max_scroll_x < 0) max_scroll_x = 0;
            if (target->scroll_x < 0) target->scroll_x = 0;
            if (target->scroll_x > max_scroll_x) target->scroll_x = max_scroll_x;
            
            break; // Handled
        }
        target = target->parent;
    }
}

static void handle_mouse_press_event(UiInputContext* ctx, const InputEvent* event) {
    if (event->type != INPUT_EVENT_MOUSE_PRESSED) return;
    if (event->data.mouse_button.button != 0) return; // Left click only for now

    float mx = event->data.mouse_button.x;
    float my = event->data.mouse_button.y;

    if (ctx->hovered) {
        ctx->active = ctx->hovered;
        ctx->possible_drag = true;
        ctx->drag_start_mouse_x = mx;
        ctx->drag_start_mouse_y = my;
        
        // Cache start values for potential drag
        if (ctx->active->ui_flags & UI_FLAG_SCROLLABLE) {
             ctx->drag_start_elem_x = ctx->active->scroll_x;
             ctx->drag_start_elem_y = ctx->active->scroll_y;
        } else if (ctx->active->interaction_flags & SCENE_INTERACTION_DRAGGABLE) {
             // Cache bound values
             if (ctx->active->data_ptr) {
                 const UiBinding* bind_x = ui_node_get_binding(ctx->active, BINDING_TARGET_LAYOUT_X);
                 const UiBinding* bind_y = ui_node_get_binding(ctx->active, BINDING_TARGET_LAYOUT_Y);
                 
                 if (bind_x) {
                     void* ptr = (char*)ctx->active->data_ptr + bind_x->source_offset;
                     if (bind_x->source_field->type == META_TYPE_FLOAT) ctx->drag_start_elem_x = *(float*)ptr;
                 }
                 if (bind_y) {
                     void* ptr = (char*)ctx->active->data_ptr + bind_y->source_offset;
                     if (bind_y->source_field->type == META_TYPE_FLOAT) ctx->drag_start_elem_y = *(float*)ptr;
                 }
             }
        }

        // Handle Focus
        if (ctx->hovered && (ctx->hovered->interaction_flags & SCENE_INTERACTION_FOCUSABLE)) {
            if (ctx->focused && ctx->focused != ctx->hovered) {
                ctx->focused->is_focused = false;
            }
            ctx->focused = ctx->hovered;
            ctx->focused->is_focused = true;
        } else {
            if (ctx->focused) {
                ctx->focused->is_focused = false;
            }
            ctx->focused = NULL;
        }
    } else {
        // Clicked void
        if (ctx->focused) {
            ctx->focused->is_focused = false;
        }
        ctx->focused = NULL;
    }
    
    if (ctx->active) {
        ctx->active->is_active = true;
    }
}

static void handle_char_event(UiInputContext* ctx, const InputEvent* event) {
    if (!ctx->focused) return;
    SceneNode* el = ctx->focused;
    if (!(el->ui_flags & UI_FLAG_EDITABLE)) return;

    if (event->type == INPUT_EVENT_CHAR) {
         char buf[256] = {0};
         const UiBinding* bind_text = ui_node_get_binding(el, BINDING_TARGET_TEXT);
         
         if (el->data_ptr && bind_text) {
             // Read current value
             ui_bind_read_string(el->data_ptr, bind_text->source_field, buf, sizeof(buf));
             
             size_t len = strlen(buf);
             if (len < 255) {
                 buf[len] = (char)event->data.character.codepoint;
                 buf[len+1] = '\0';
                 
                 ui_node_write_binding_string(el, BINDING_TARGET_TEXT, buf);
                 el->cursor_idx++;
                 
                 push_event(ctx, UI_EVENT_VALUE_CHANGE, el);
                 if (el->on_change_cmd_id) {
                     ui_command_execute_id(el->on_change_cmd_id, el);
                 }
             }
         }
    }
}

static void handle_key_event(UiInputContext* ctx, const InputEvent* event) {
    if (!ctx->focused) return;
    SceneNode* el = ctx->focused;
    if (!(el->ui_flags & UI_FLAG_EDITABLE)) return;

    if (event->type == INPUT_EVENT_KEY_PRESSED || event->type == INPUT_EVENT_KEY_REPEAT) {
        if (event->data.key.key == INPUT_KEY_BACKSPACE) {
             char buf[256] = {0};
             const UiBinding* bind_text = ui_node_get_binding(el, BINDING_TARGET_TEXT);
             
             if (el->data_ptr && bind_text) {
                 ui_bind_read_string(el->data_ptr, bind_text->source_field, buf, sizeof(buf));
                 size_t len = strlen(buf);
                 if (len > 0) {
                     buf[len-1] = '\0';
                     ui_node_write_binding_string(el, BINDING_TARGET_TEXT, buf);
                     if (el->cursor_idx > 0) el->cursor_idx--;
                     
                     push_event(ctx, UI_EVENT_VALUE_CHANGE, el);
                     if (el->on_change_cmd_id) {
                         ui_command_execute_id(el->on_change_cmd_id, el);
                     }
                 }
             }
        }
    }
}

static void handle_drag_logic(UiInputContext* ctx, const InputSystem* input) {
    if (!ctx->active || !input_is_mouse_down(input)) return;

    float mx = input_get_mouse_x(input);
    float my = input_get_mouse_y(input);

    // Check start threshold
    if (ctx->possible_drag && !ctx->is_dragging) {
        float dx = mx - ctx->drag_start_mouse_x;
        float dy = my - ctx->drag_start_mouse_y;
        if (dx*dx + dy*dy > UI_DRAG_THRESHOLD_SQ) { 
            ctx->is_dragging = true;
            push_event(ctx, UI_EVENT_DRAG_START, ctx->active);
        }
    }

    if (ctx->is_dragging) {
        float dx = mx - ctx->drag_start_mouse_x;
        float dy = my - ctx->drag_start_mouse_y;
        bool changed = false;

        // Case A: Draggable Object (updates data model)
        if (ctx->active->interaction_flags & SCENE_INTERACTION_DRAGGABLE) {
            if (ctx->active->data_ptr) {
                if (ui_node_get_binding(ctx->active, BINDING_TARGET_LAYOUT_X)) {
                    ui_node_write_binding_float(ctx->active, BINDING_TARGET_LAYOUT_X, ctx->drag_start_elem_x + dx);
                    changed = true;
                }
                if (ui_node_get_binding(ctx->active, BINDING_TARGET_LAYOUT_Y)) {
                    ui_node_write_binding_float(ctx->active, BINDING_TARGET_LAYOUT_Y, ctx->drag_start_elem_y + dy);
                    changed = true;
                }
            }
        }
        // Case B: Scrollable (internal state)
        else if (ctx->active->ui_flags & UI_FLAG_SCROLLABLE) {
             ctx->active->scroll_x = ctx->drag_start_elem_x - dx;
             ctx->active->scroll_y = ctx->drag_start_elem_y - dy;
             
             // Clamp
             float max_scroll_y = ctx->active->content_h - (ctx->active->rect.h - ctx->active->spec->layout.padding * 2);
             if (max_scroll_y < 0) max_scroll_y = 0;
             if (ctx->active->scroll_y < 0) ctx->active->scroll_y = 0;
             if (ctx->active->scroll_y > max_scroll_y) ctx->active->scroll_y = max_scroll_y;

             float max_scroll_x = ctx->active->content_w - (ctx->active->rect.w - ctx->active->spec->layout.padding * 2);
             if (max_scroll_x < 0) max_scroll_x = 0;
             if (ctx->active->scroll_x < 0) ctx->active->scroll_x = 0;
             if (ctx->active->scroll_x > max_scroll_x) ctx->active->scroll_x = max_scroll_x;
        }
        
        if (changed) {
            push_event(ctx, UI_EVENT_VALUE_CHANGE, ctx->active);
            if (ctx->active->on_change_cmd_id) {
                ui_command_execute_id(ctx->active->on_change_cmd_id, ctx->active);
            }
        }
    }
}

static void handle_mouse_release_event(UiInputContext* ctx, const InputEvent* event) {
    if (event->type != INPUT_EVENT_MOUSE_RELEASED) return;

    if (ctx->active) {
        // Click?
        if (ctx->active == ctx->hovered && !ctx->is_dragging) {
            push_event(ctx, UI_EVENT_CLICK, ctx->active);
            if (ctx->active->on_click_cmd_id) {
                ui_command_execute_id(ctx->active->on_click_cmd_id, ctx->active);
            }
        }
        // Drag End?
        if (ctx->is_dragging) {
            push_event(ctx, UI_EVENT_DRAG_END, ctx->active);
        }
        
        ctx->active->is_active = false;
        ctx->active = NULL;
    }
    ctx->is_dragging = false;
    ctx->possible_drag = false;
}

// --- Main Update Loop ---

void ui_input_update(UiInputContext* ctx, SceneNode* root, const InputSystem* input) {
    if (!ctx || !root || !input) return;

    update_hover_state(ctx, root, input);
    
    // Process Events
    int count = input_get_event_count(input);
    for (int i = 0; i < count; ++i) {
        const InputEvent* e = input_get_event(input, i);
        if (!e) continue;

        switch (e->type) {
            case INPUT_EVENT_SCROLL: handle_scroll_event(ctx, e); break;
            case INPUT_EVENT_MOUSE_PRESSED: handle_mouse_press_event(ctx, e); break;
            case INPUT_EVENT_MOUSE_RELEASED: handle_mouse_release_event(ctx, e); break;
            case INPUT_EVENT_CHAR: handle_char_event(ctx, e); break;
            case INPUT_EVENT_KEY_PRESSED: 
            case INPUT_EVENT_KEY_REPEAT: 
                handle_key_event(ctx, e); 
                break;
            default: break;
        }
    }
    
    // Continuous Drag Logic
    handle_drag_logic(ctx, input);
}


==================================================
FILE START: src/engine/ui/internal/ui_input.h
==================================================
#ifndef UI_INPUT_INTERNAL_H
#define UI_INPUT_INTERNAL_H

#include "../ui_input.h" // Public definition of UiEvent
#include "../ui_core.h"

// --- UI Input Context ---
// Stores the persistent state of interaction across frames.

struct UiInputContext {
    // Current Frame State
    SceneNode* hovered;      // Element currently under mouse
    SceneNode* active;       // Element being pressed (mouse down)
    SceneNode* focused;      // Element with keyboard focus

    // Dragging State
    bool is_dragging;
    float drag_start_mouse_x;
    float drag_start_mouse_y;
    float drag_start_elem_x; // Element's cached value at start of drag
    float drag_start_elem_y;

    // Helper to detect click vs drag
    bool possible_drag; 

    // Event Queue
    UiEvent events[64];
    int event_count;
};

#endif // UI_INPUT_INTERNAL_H


==================================================
FILE START: src/engine/ui/internal/ui_internal.h
==================================================
#ifndef UI_INTERNAL_H
#define UI_INTERNAL_H

#include "../ui_core.h"
#include "../ui_input.h"
#include "../ui_renderer.h"
#include "engine/scene/scene.h"
#include "engine/scene/internal/scene_tree_internal.h"
#include "foundation/memory/arena.h"
#include "foundation/memory/pool.h"
#include "foundation/string/string_id.h"
#include "foundation/math/coordinate_systems.h"

#include "ui_binding.h"

// Note: UiLayoutSpec and UiStyleSpec are now in scene_tree_internal.h
// Note: UiNodeSpec and UiBindingSpec have been merged into SceneNodeSpec (scene_tree_internal.h)

#endif // UI_INTERNAL_H


==================================================
FILE START: src/engine/ui/internal/ui_layout.c
==================================================
#include "ui_layout.h"
#include "../ui_core.h"
#include "ui_internal.h"
#include "foundation/logger/logger.h"
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#define UI_DEFAULT_WIDTH 100.0f
#define UI_DEFAULT_HEIGHT 30.0f
#define UI_CHAR_WIDTH_EST 10.0f
#define UI_INFINITY 10000.0f

static float calculate_width(SceneNode* el, float available_w, UiTextMeasureFunc measure_func, void* measure_data) {
    const SceneNodeSpec* spec = el->spec;
    float w = spec->layout.width;
    if (ui_node_get_binding(el, BINDING_TARGET_LAYOUT_WIDTH)) w = el->rect.w; // updated by ui_core

    if (w < 0) {
        bool parent_is_row = (el->parent && el->parent->spec->layout.type == SCENE_LAYOUT_FLEX_ROW);
        
    // If size is Auto, we need to calculate content size
    // For text, it's the glyph bounds. For container, it's the sum of children.
    // Hack: If container is CLICKABLE, treat it as having content even if empty? No.
    if (parent_is_row || spec->kind == SCENE_NODE_KIND_TEXT || (el->interaction_flags & SCENE_INTERACTION_CLICKABLE)) {
             const char* text = el->cached_text;
             if (!text || text[0] == '\0') text = spec->text;

             if (text && text[0] != '\0') {
                 if (measure_func) {
                     w = measure_func(text, 0.5f, measure_data).x + spec->layout.padding * 2;
                 } else {
                     w = strlen(text) * UI_CHAR_WIDTH_EST + spec->layout.padding * 2 + UI_CHAR_WIDTH_EST;
                 }
             } else {
                 w = UI_DEFAULT_WIDTH;
             }
        } else {
             w = available_w; // Fill
        }
    }
    return w;
}

static float calculate_height(SceneNode* el, float available_h) {
    const SceneNodeSpec* spec = el->spec;
    float h = spec->layout.height;
    if (ui_node_get_binding(el, BINDING_TARGET_LAYOUT_HEIGHT)) h = el->rect.h;

    if (h < 0) {
        if (el->child_count > 0 && spec->layout.type == SCENE_LAYOUT_FLEX_COLUMN) {
            h = spec->layout.padding * 2;
             for (SceneNode* child = el->first_child; child; child = child->next_sibling) {
                if (child->flags & SCENE_FLAG_HIDDEN) continue;
                float child_h = child->spec->layout.height;
                if (child_h < 0) child_h = UI_DEFAULT_HEIGHT; 
                h += child_h + spec->layout.spacing;
            }
            if (el->child_count > 0) h -= spec->layout.spacing;
            
            if (available_h > 0 && available_h < UI_INFINITY && h < available_h) {
                h = available_h;
            }
        } else {
             h = (available_h > 0 && available_h < UI_INFINITY) ? available_h : UI_DEFAULT_HEIGHT;
        }
    }
    return h;
}

static void layout_column(SceneNode* el, float start_x, float start_y, float* out_max_x, float* out_max_y) {
    float cursor_y = start_y;
    for (SceneNode* child = el->first_child; child; child = child->next_sibling) {
        if (child->flags & SCENE_FLAG_HIDDEN) continue;
        child->rect.x = start_x;
        child->rect.y = cursor_y;
        cursor_y += child->rect.h + el->spec->layout.spacing;
        
        float child_right = child->rect.x + child->rect.w;
        if (child_right > *out_max_x) *out_max_x = child_right;
    }
    if (el->child_count > 0) cursor_y -= el->spec->layout.spacing;
    *out_max_y = cursor_y;
}

static void layout_row(SceneNode* el, float start_x, float start_y, float* out_max_x, float* out_max_y) {
    float cursor_x = start_x;
    for (SceneNode* child = el->first_child; child; child = child->next_sibling) {
        if (child->flags & SCENE_FLAG_HIDDEN) continue;
        child->rect.x = cursor_x;
        child->rect.y = start_y;
        cursor_x += child->rect.w + el->spec->layout.spacing;
        
        float child_bottom = child->rect.y + child->rect.h;
        if (child_bottom > *out_max_y) *out_max_y = child_bottom;
    }
    if (el->child_count > 0) cursor_x -= el->spec->layout.spacing;
    *out_max_x = cursor_x;
}

static void layout_canvas(SceneNode* el, float* out_max_x, float* out_max_y) {
    *out_max_x = 0;
    *out_max_y = 0;
    for (SceneNode* child = el->first_child; child; child = child->next_sibling) {
    // 4. Handle Overflow / Scroll
    if (el->ui_flags & UI_FLAG_SCROLLABLE) {
            child->rect.x -= el->scroll_x;
            child->rect.y -= el->scroll_y;
        }
        
        // Calculate content bounds (using logical coordinates, reverting scroll)
        float logical_x = child->rect.x + (el->ui_flags & UI_FLAG_SCROLLABLE ? el->scroll_x : 0);
        float logical_y = child->rect.y + (el->ui_flags & UI_FLAG_SCROLLABLE ? el->scroll_y : 0);
        float right = logical_x + child->rect.w;
        float bottom = logical_y + child->rect.h;
        
        if (right > *out_max_x) *out_max_x = right;
        if (bottom > *out_max_y) *out_max_y = bottom;
    }
}

static void layout_split_h(SceneNode* el, float start_x, float start_y) {
    if (el->child_count < 2) return;
    SceneNode* c1 = el->first_child;
    if (!c1) return;
    SceneNode* c2 = c1->next_sibling;
    if (!c2) return;
    
    c1->rect.x = start_x;
    c1->rect.y = start_y;
    c2->rect.x = start_x + c1->rect.w;
    c2->rect.y = start_y;
}

static void layout_split_v(SceneNode* el, float start_x, float start_y) {
    if (el->child_count < 2) return;
    SceneNode* c1 = el->first_child;
    if (!c1) return;
    SceneNode* c2 = c1->next_sibling;
    if (!c2) return;
    
    c1->rect.x = start_x;
    c1->rect.y = start_y;
    c2->rect.x = start_x;
    c2->rect.y = start_y + c1->rect.h;
}

static void layout_recursive(SceneNode* el, Rect available, uint64_t frame_number, bool log_debug, UiTextMeasureFunc measure_func, void* measure_data) {
    if (!el || !el->spec) return;
    
    if (el->flags & SCENE_FLAG_HIDDEN) {
        el->rect.w = 0;
        el->rect.h = 0;
    }

    const SceneNodeSpec* spec = el->spec;

    // 1. Self Size
    el->rect.w = calculate_width(el, available.w, measure_func, measure_data);
    el->rect.h = calculate_height(el, available.h);

    if (log_debug) {
        LOG_DEBUG("[Frame %llu] Layout Node id='%u': Rect(%.1f, %.1f, %.1f, %.1f)", 
            (unsigned long long)frame_number, spec->id,
            el->rect.x, el->rect.y, el->rect.w, el->rect.h);
    }

    // 2. Prepare Children Layout
    Rect content = {
        spec->layout.padding, spec->layout.padding,
        el->rect.w - spec->layout.padding * 2, el->rect.h - spec->layout.padding * 2
    };
    
    // Recurse First (Depth-first sizing)
    int i = 0;
    for (SceneNode* child = el->first_child; child; child = child->next_sibling) {
        Rect child_avail = { 0, 0, content.w, content.h };
        
        if (spec->layout.type == SCENE_LAYOUT_SPLIT_H && el->child_count >= 2) {
             float ratio = spec->layout.split_ratio > 0 ? spec->layout.split_ratio : 0.5f;
             if (i == 0) child_avail.w = content.w * ratio;
             else child_avail.w = content.w * (1.0f - ratio);
        } else if (spec->layout.type == SCENE_LAYOUT_SPLIT_V && el->child_count >= 2) {
             float ratio = spec->layout.split_ratio > 0 ? spec->layout.split_ratio : 0.5f;
             if (i == 0) child_avail.h = content.h * ratio;
             else child_avail.h = content.h * (1.0f - ratio);
        }

        layout_recursive(child, child_avail, frame_number, log_debug, measure_func, measure_data);
        i++;
    }

    // 3. Position Children
    float start_x = content.x - el->scroll_x;
    float start_y = content.y - el->scroll_y;
    
    float max_x = start_x; // Use absolute max coordinate tracking
    float max_y = start_y;
    
    switch (spec->layout.type) {
        case SCENE_LAYOUT_FLEX_COLUMN:
            layout_column(el, start_x, start_y, &max_x, &max_y);
            // Convert absolute max back to content relative size
            el->content_w = max_x - start_x;
            el->content_h = max_y - start_y;
            break;
        case SCENE_LAYOUT_FLEX_ROW:
            layout_row(el, start_x, start_y, &max_x, &max_y);
            el->content_w = max_x - start_x;
            el->content_h = max_y - start_y;
            break;
        case SCENE_LAYOUT_CANVAS:
            layout_canvas(el, &max_x, &max_y);
            el->content_w = max_x;
            el->content_h = max_y;
            break;
        case SCENE_LAYOUT_SPLIT_H:
            layout_split_h(el, start_x, start_y);
            el->content_w = el->rect.w;
            el->content_h = el->rect.h;
            break;
        case SCENE_LAYOUT_SPLIT_V:
            layout_split_v(el, start_x, start_y);
            el->content_w = el->rect.w;
            el->content_h = el->rect.h;
            break;
        default: break;
    }
}

static void update_screen_rects(SceneNode* el, float parent_x, float parent_y) {
    if (!el) return;
    
    el->screen_rect.x = parent_x + el->rect.x;
    el->screen_rect.y = parent_y + el->rect.y;
    el->screen_rect.w = el->rect.w;
    el->screen_rect.h = el->rect.h;

    for (SceneNode* child = el->first_child; child; child = child->next_sibling) {
        update_screen_rects(child, el->screen_rect.x, el->screen_rect.y);
    }
}

void ui_layout_root(SceneNode* root, float window_w, float window_h, uint64_t frame_number, bool log_debug, UiTextMeasureFunc measure_func, void* measure_data) {
    if (!root) return;
    
    if (root->spec->layout.width < 0) root->rect.w = window_w;
    if (root->spec->layout.height < 0) root->rect.h = window_h;
    
    Rect initial_avail = {0, 0, window_w, window_h};
    layout_recursive(root, initial_avail, frame_number, log_debug, measure_func, measure_data);
    update_screen_rects(root, 0, 0);
}


==================================================
FILE START: src/engine/ui/internal/ui_layout.h
==================================================
#ifndef UI_LAYOUT_H
#define UI_LAYOUT_H

// --- INTERNAL HEADER: Do not include in public API ---
// Use ui_core.h (ui_instance_layout) instead.

#include "../ui_core.h"
#include "../ui_renderer.h"

#include <stdint.h>
#include <stdbool.h>

void ui_layout_root(SceneNode* root, float window_w, float window_h, uint64_t frame_number, bool log_debug, UiTextMeasureFunc measure_func, void* measure_data);

#endif // UI_LAYOUT_H


==================================================
FILE START: src/engine/ui/internal/ui_renderer.c
==================================================
#include "ui_renderer.h"
#include "../ui_core.h"
#include "ui_internal.h"
#include "engine/scene/render_packet.h"
#include "engine/graphics/layer_constants.h"
#include "foundation/logger/logger.h"
#include "engine/text/text_renderer.h" 
#include "engine/text/font.h" 
#include "engine/assets/assets.h"
#include "foundation/memory/arena.h"
#include "foundation/meta/reflection.h"
#include <string.h> 

// --- Provider Registry ---
#define MAX_UI_PROVIDERS 32

typedef struct {
    StringId id;
    SceneObjectProvider callback;
} SceneProviderEntry;

static SceneProviderEntry s_providers[MAX_UI_PROVIDERS];
static int s_provider_count = 0;

void scene_register_provider(const char* name, SceneObjectProvider callback) {
    if (s_provider_count >= MAX_UI_PROVIDERS) {
        LOG_ERROR("SceneBuilder: Max providers reached");
        return;
    }
    s_providers[s_provider_count].id = str_id(name);
    s_providers[s_provider_count].callback = callback;
    s_provider_count++;
    LOG_INFO("SceneBuilder: Registered provider '%s'", name);
}

static SceneObjectProvider scene_find_provider(StringId id) {
    for(int i=0; i<s_provider_count; ++i) {
        if (s_providers[i].id == id) return s_providers[i].callback;
    }
    return NULL;
}

typedef struct OverlayNode {
    const SceneNode* el;
    struct OverlayNode* next;
} OverlayNode;

// Internal Render Context to avoid passing too many args
typedef struct SceneBuilderContext {
    Scene* scene;
    const Assets* assets;
    const Font* font;
    MemoryArena* arena;
    OverlayNode* overlay_head;
    OverlayNode* overlay_tail;
} SceneBuilderContext;

// Helper: Intersection
static Rect rect_intersect(Rect a, Rect b) {
    float x1 = (a.x > b.x) ? a.x : b.x;
    float y1 = (a.y > b.y) ? a.y : b.y;
    float x2 = (a.x + a.w < b.x + b.w) ? (a.x + a.w) : (b.x + b.w);
    float y2 = (a.y + a.h < b.y + b.h) ? (a.y + a.h) : (b.y + b.h);
    
    if (x2 < x1) x2 = x1;
    if (y2 < y1) y2 = y1;
    
    return (Rect){x1, y1, x2 - x1, y2 - y1};
}

static void render_background(const SceneNode* el, SceneBuilderContext* ctx, Vec4 clip_vec, float z) {
    bool is_input = (el->ui_flags & UI_FLAG_EDITABLE);
    int mode = el->spec->style.render_mode;

    // Default / Compatibility Logic resolution
    if (mode == SCENE_RENDER_MODE_DEFAULT) {
        // By default, TEXT kind (non-input) has no background
        if (el->spec->kind == SCENE_NODE_KIND_TEXT && !is_input) {
             return; 
        }
        
        // Infer mode from texture existence
        if (el->spec->style.texture != 0) mode = SCENE_RENDER_MODE_IMAGE;
        else mode = SCENE_RENDER_MODE_BOX;
    }

    // Explicit Text mode means no background
    if (mode == SCENE_RENDER_MODE_TEXT) return;

    // Resolve base color
    Vec4 color = el->render_color;
    if (color.w == 0) color = (Vec4){0.1f, 0.1f, 0.1f, 0.8f}; // Fallback

    // Apply Hover/Active tints
    if (el->is_active) {
        if (el->spec->style.active_color.w > 0.0f) {
            color = el->spec->style.active_color;
        } else {
            float tint = el->spec->style.active_tint > 0.0f ? el->spec->style.active_tint : 0.5f;
            color.x *= tint; color.y *= tint; color.z *= tint;
        }
    } else if (el->is_hovered) {
        if (el->spec->style.hover_color.w > 0.0f) {
            color = el->spec->style.hover_color;
        } else {
            float tint = el->spec->style.hover_tint > 0.0f ? el->spec->style.hover_tint : 1.2f;
            color.x *= tint; color.y *= tint; color.z *= tint;
        }
    } else if (is_input) {
         // Default style for inputs: slightly lighter when idle
         color.x *= 1.1f; color.y *= 1.1f; color.z *= 1.1f;
    }

    // Render based on Resolved Mode
    switch (mode) {
        case SCENE_RENDER_MODE_BEZIER: {
            Vec2 start = {el->screen_rect.x, el->screen_rect.y};
            Vec2 end = {el->screen_rect.x + el->screen_rect.w, el->screen_rect.y + el->screen_rect.h};
            float thickness = 2.0f;
            
            // Try to read from data binding if available
            if (el->data_ptr && el->meta) {
                const MetaField* f_start = meta_find_field(el->meta, "start");
                const MetaField* f_end = meta_find_field(el->meta, "end");
                const MetaField* f_thick = meta_find_field(el->meta, "thickness");
                
                if (f_start && f_start->type == META_TYPE_VEC2) {
                    float* v = (float*)meta_get_field_ptr(el->data_ptr, f_start);
                    // Convert Local -> Screen
                    start = (Vec2){el->screen_rect.x + v[0], el->screen_rect.y + v[1]};
                }
                if (f_end && f_end->type == META_TYPE_VEC2) {
                    float* v = (float*)meta_get_field_ptr(el->data_ptr, f_end);
                    // Convert Local -> Screen
                    end = (Vec2){el->screen_rect.x + v[0], el->screen_rect.y + v[1]};
                }
                if (f_thick && f_thick->type == META_TYPE_FLOAT) {
                    thickness = *(float*)meta_get_field_ptr(el->data_ptr, f_thick);
                }
            }
            
            scene_push_curve(ctx->scene, 
                (Vec3){start.x, start.y, z}, 
                (Vec3){end.x, end.y, z}, 
                thickness, 
                color, 
                clip_vec
            );
            break;
        }

        case SCENE_RENDER_MODE_IMAGE: {
            // Use 9-Slice or Textured Quad
            float u0, v0, u1, v1;
            font_get_ui_rect_uv(ctx->font, &u0, &v0, &u1, &v1);
            Vec4 uv_rect = {u0, v0, u1 - u0, v1 - v0};
            
            float tex_w = el->spec->style.tex_w > 0 ? el->spec->style.tex_w : 32.0f;
            float tex_h = el->spec->style.tex_h > 0 ? el->spec->style.tex_h : 32.0f;
            
            // extra_params: borders (top, right, bottom, left)
            Vec4 borders = {
                el->spec->style.border_t,
                el->spec->style.border_r,
                el->spec->style.border_b,
                el->spec->style.border_l
            };
            
            scene_push_quad_9slice(ctx->scene, 
                (Vec3){el->screen_rect.x, el->screen_rect.y, z}, 
                (Vec2){el->screen_rect.w, el->screen_rect.h}, 
                color, 
                uv_rect, 
                (Vec2){tex_w, tex_h}, 
                borders, 
                clip_vec
            );
            break;
        }

        case SCENE_RENDER_MODE_BOX: {
            // SDF Rounded Box
            scene_push_rect_sdf(ctx->scene,
                (Vec3){el->screen_rect.x, el->screen_rect.y, z},
                (Vec2){el->screen_rect.w, el->screen_rect.h},
                color,
                el->spec->style.corner_radius,
                el->spec->style.border_t,
                clip_vec
            );
            break;
        }
        
        default: break;
    }
}

static void render_content(const SceneNode* el, SceneBuilderContext* ctx, Vec4 clip_vec, float z) {
    // Resolve Text (Use Cache)
    const char* text = el->cached_text;
    if (!text || text[0] == '\0') {
        text = el->spec->text;
    }
    
                bool is_input = (el->ui_flags & UI_FLAG_EDITABLE);    if (is_input && !text) text = "";

    // Skip if nothing to draw
    if ((!text || text[0] == '\0') && !is_input) return;

    if (text) {
        Vec3 pos = {el->screen_rect.x + el->spec->layout.padding, el->screen_rect.y + el->spec->layout.padding, z + RENDER_DEPTH_STEP_CONTENT};
        
        float txt_scale = el->spec->style.text_scale > 0.0f ? el->spec->style.text_scale : 0.5f;
        Vec4 txt_color = el->spec->style.text_color.w > 0.0f ? el->spec->style.text_color : (Vec4){1.0f, 1.0f, 1.0f, 1.0f};
        
        scene_add_text_clipped(ctx->scene, ctx->font, text, pos, txt_scale, txt_color, clip_vec);

        // Draw Caret
        if (is_input && el->is_focused) {
            char temp[256];
            int len = (int)strlen(text);
            int c_idx = el->cursor_idx;
            if (c_idx > len) c_idx = len;
            if (c_idx < 0) c_idx = 0;
            
            int copy_len = c_idx < 255 ? c_idx : 255;
            memcpy(temp, text, copy_len);
            temp[copy_len] = '\0';
            
            float text_width = font_measure_text(ctx->font, temp) * txt_scale; 
            
            float cw = el->spec->style.caret_width > 0.0f ? el->spec->style.caret_width : 2.0f;
            float ch = el->spec->style.caret_height > 0.0f ? el->spec->style.caret_height : 20.0f;
            
            Vec4 cc = el->spec->style.caret_color.w > 0.0f ? el->spec->style.caret_color : (Vec4){1.0f, 1.0f, 1.0f, 1.0f};

            scene_push_quad(ctx->scene, 
                (Vec3){pos.x + text_width, pos.y, z + (RENDER_DEPTH_STEP_CONTENT * 2)}, 
                (Vec2){cw, ch}, 
                cc, 
                clip_vec
            );
        }
    }
}

static void push_overlay(SceneBuilderContext* ctx, const SceneNode* el) {
    if (!ctx || !ctx->arena) return;
    OverlayNode* node = arena_alloc_zero(ctx->arena, sizeof(OverlayNode));
    if (!node) return;
    
    node->el = el;
    node->next = NULL;
    
    if (!ctx->overlay_head) {
        ctx->overlay_head = node;
        ctx->overlay_tail = node;
    } else {
        ctx->overlay_tail->next = node;
        ctx->overlay_tail = node;
    }
}

static void process_node(const SceneNode* el, SceneBuilderContext* ctx, Rect current_clip, float base_z, bool is_overlay_pass) {
    if (!el || !el->spec) return;

    // Skip hidden
    if (el->flags & SCENE_FLAG_HIDDEN) return;

    // Check Overlay Logic
    bool is_node_overlay = (el->spec->layout.layer == SCENE_LAYER_OVERLAY);
    
    // If we are in the Normal pass, and encounter an Overlay node -> Defer it
    if (!is_overlay_pass && is_node_overlay) {
        push_overlay(ctx, el);
        return; 
    }

    // Determine Clip
    Rect effective_clip = current_clip;
    
    // If this node IS an overlay root (and we are likely in overlay pass or processing it), reset clip
    // Note: If we are recursively inside an overlay, we respect the parent clip, 
    // but the root of the overlay resets it.
    if (is_node_overlay) {
        effective_clip = (Rect){-10000.0f, -10000.0f, 20000.0f, 20000.0f};
    }
    
    // Apply Standard Clipping
    // 2. Clip
    if (el->flags & SCENE_FLAG_CLIPPED) {
        effective_clip = rect_intersect(effective_clip, el->screen_rect);
    }
    
    Vec4 clip_vec = {effective_clip.x, effective_clip.y, effective_clip.w, effective_clip.h};

    // 1. Draw Background
    render_background(el, ctx, clip_vec, base_z);

    // 1.5 Draw Mesh (3D)
    if (el->spec->mesh.mesh_id != 0) {
        const Mesh* mesh = assets_get_unit_quad(ctx->assets);
        if (mesh) {
            Vec4 color = el->render_color;
            if (color.w == 0.0f) color = (Vec4){1,1,1,1};

            SceneObject obj = {0};
            obj.id = (int)scene_node_get_id(el);
            obj.layer = LAYER_WORLD_OPAQUE; 
            obj.prim_type = SCENE_PRIM_QUAD; 
            obj.mesh = mesh;
            
            // Extract Translation from World Matrix
            obj.position.x = el->world_matrix.m[12];
            obj.position.y = el->world_matrix.m[13];
            obj.position.z = el->world_matrix.m[14];
            
            // Use Local Rotation/Scale (Parent rotation/scale not fully inherited in decomposed form)
            obj.rotation = el->spec->transform.local_rotation;
            obj.scale = el->spec->transform.local_scale;
            
            obj.color = color;
            scene_add_object(ctx->scene, obj);
        }
    }

    // 2. Viewport Delegation
    if (el->spec->kind == SCENE_NODE_KIND_VIEWPORT && el->spec->provider_id) {
         SceneObjectProvider cb = scene_find_provider(el->spec->provider_id);
         if (cb) {
             // Invoke provider (e.g. Graph Editor) to inject scene objects
             // Z-Depth: slightly above background
             cb(el->data_ptr, el->screen_rect, base_z + RENDER_DEPTH_STEP_UI, ctx->scene, ctx->arena);
         }
    }

    // 3. Draw Content
    render_content(el, ctx, clip_vec, base_z);

    // 4. Recurse
    for (SceneNode* child = el->first_child; child; child = child->next_sibling) {
        process_node(child, ctx, effective_clip, base_z + RENDER_DEPTH_STEP_UI, is_overlay_pass);
    }
}

void scene_tree_render(SceneTree* instance, Scene* scene, const Assets* assets, MemoryArena* arena) {
    if (!instance || !instance->root || !arena) return;
    const SceneNode* root = instance->root;

    Rect infinite_clip = {-10000.0f, -10000.0f, 20000.0f, 20000.0f};
    
    SceneBuilderContext ctx = {0};
    ctx.scene = scene;
    ctx.assets = assets;
    ctx.font = assets_get_font(assets);
    ctx.arena = arena;
    
    // Pass 1: Draw Normal, Defer Overlays
    process_node(root, &ctx, infinite_clip, RENDER_LAYER_UI_BASE, false);
    
    // Pass 2: Draw Overlays
    OverlayNode* curr = ctx.overlay_head;
    while (curr) {
        process_node(curr->el, &ctx, infinite_clip, RENDER_LAYER_UI_OVERLAY, true);
        curr = curr->next;
    }
}


==================================================
FILE START: src/engine/ui/internal/ui_renderer.h
==================================================
#ifndef UI_RENDERER_INTERNAL_H
#define UI_RENDERER_INTERNAL_H

// --- INTERNAL HEADER: Do not include in public API ---
// Use ui_core.h (ui_instance_render) instead.

#include <stddef.h> // for NULL, size_t, etc. if needed (though strictly not needed for opaque pointers, good practice)

// Forward Declarations
typedef struct SceneNode SceneNode;
typedef struct Scene Scene;
typedef struct Assets Assets;
typedef struct MemoryArena MemoryArena;

// Traverses the SceneNode tree and populates the Scene with renderable objects.
void scene_builder_build(const SceneNode* root, Scene* scene, const Assets* assets, MemoryArena* arena);

#endif // UI_RENDERER_INTERNAL_H


==================================================
FILE START: src/engine/ui/ui_core.c
==================================================
#include "ui_core.h"
#include "ui_renderer.h"
#include "ui_input.h"
#include "internal/ui_internal.h"
#include "internal/ui_command_system.h"
#include "internal/ui_layout.h"
#include "foundation/logger/logger.h"
#include "foundation/memory/arena.h"
#include "foundation/memory/pool.h"
#include "foundation/meta/reflection.h"
#include "engine/scene/scene.h"
#include "engine/scene/internal/scene_tree_internal.h"
#include <string.h>
#include <stdio.h>
#include <math.h>

static bool s_ui_initialized = false;

void ui_system_init(void) {
    if (s_ui_initialized) return;
    s_ui_initialized = true;
    LOG_INFO("UI System Initialized");
}

void ui_system_shutdown(void) {
    ui_command_shutdown();
}

SceneNode* ui_node_create(SceneTree* tree, const SceneNodeSpec* spec, void* data, const MetaStruct* meta) {
    if (!tree || !spec) return NULL;

    // 1. Basic Scene Node
    SceneNode* el = scene_node_create(tree, spec, data, meta);
    if (!el) return NULL;

    // 2. UI-specific init
    el->render_color = spec->style.color;
    el->rect.x = spec->layout.x;
    el->rect.y = spec->layout.y;
    el->on_click_cmd_id = spec->on_click;
    el->on_change_cmd_id = spec->on_change;

    // Cache Bindings
    if (meta && spec->binding_count > 0) {
        el->ui_bindings = arena_alloc_zero(&tree->arena, spec->binding_count * sizeof(UiBinding));
        el->ui_binding_count = spec->binding_count;
        UiBinding* bindings = (UiBinding*)el->ui_bindings;
        
        for (size_t i = 0; i < spec->binding_count; ++i) {
             SceneBindingSpec* b_spec = &spec->bindings[i];
             size_t total_offset = 0;
             const MetaField* f = meta_find_field_by_path(meta, b_spec->source, &total_offset);
             
             if (f) {
                 bindings[i].source_field = f;
                 bindings[i].source_offset = total_offset;
                 bindings[i].target = ui_resolve_target_enum(b_spec->target);
             }
        }
    }

    // Populate Children (UI-way handles collections)
    ui_node_rebuild_children(el, tree);
    
    return el;
}

void ui_node_update(SceneNode* element, float dt) {
    if (!element || !element->spec) return;
    
    // 1. Data Binding Sync
    UiBinding* bindings = (UiBinding*)element->ui_bindings;
    if (element->data_ptr && bindings) {
        for (size_t i = 0; i < element->ui_binding_count; ++i) {
             ui_apply_binding_value(element, &bindings[i]);
        }
    }

    // 2. Animation Interpolation
    const SceneNodeSpec* spec = element->spec;
    float target_t = element->is_hovered ? 1.0f : 0.0f;
    float speed = spec->style.animation_speed > 0 ? spec->style.animation_speed : 10.0f;
    
    if (element->hover_t != target_t) {
        float diff = target_t - element->hover_t;
        float step = speed * dt;
        if (fabsf(diff) < step) element->hover_t = target_t;
        else element->hover_t += (diff > 0 ? 1.0f : -1.0f) * step;
        
        // Update Animated Color
        if (spec->style.hover_color.w > 0) {
            element->render_color.x = spec->style.color.x + (spec->style.hover_color.x - spec->style.color.x) * element->hover_t;
            element->render_color.y = spec->style.color.y + (spec->style.hover_color.y - spec->style.color.y) * element->hover_t;
            element->render_color.z = spec->style.color.z + (spec->style.hover_color.z - spec->style.color.z) * element->hover_t;
            element->render_color.w = spec->style.color.w + (spec->style.hover_color.w - spec->style.color.w) * element->hover_t;
        }
    }

    // 3. Recurse
    for (SceneNode* child = element->first_child; child; child = child->next_sibling) {
        ui_node_update(child, dt);
    }
}

void ui_system_layout(SceneTree* tree, float window_w, float window_h, uint64_t frame_number, UiTextMeasureFunc measure_func, void* measure_data) {
    if (!tree || !tree->root) return;
    ui_layout_root(tree->root, window_w, window_h, frame_number, false, measure_func, measure_data);
}

void ui_system_render(SceneTree* tree, struct Scene* scene, const struct Assets* assets, struct MemoryArena* arena) {
    if (!tree || !tree->root) return;
    scene_tree_render(tree, scene, assets, arena);
}

Rect ui_node_get_screen_rect(const SceneNode* node) {
    return node ? node->screen_rect : (Rect){0};
}


==================================================
FILE START: src/engine/ui/ui_core.h
==================================================
#ifndef UI_CORE_H
#define UI_CORE_H

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include "foundation/string/string_id.h"
#include "foundation/math/coordinate_systems.h"
#include "engine/scene/scene.h"

// --- UI CONSTANTS & FLAGS ---

typedef enum UiBindingTarget {
    BINDING_TARGET_NONE = 0,
    BINDING_TARGET_TEXT,
    BINDING_TARGET_VISIBLE,
    BINDING_TARGET_LAYOUT_X,
    BINDING_TARGET_LAYOUT_Y,
    BINDING_TARGET_LAYOUT_WIDTH,
    BINDING_TARGET_LAYOUT_HEIGHT,
    BINDING_TARGET_STYLE_COLOR,
    BINDING_TARGET_TRANSFORM_POS_X,
    BINDING_TARGET_TRANSFORM_POS_Y,
    BINDING_TARGET_TRANSFORM_POS_Z
} UiBindingTarget;

typedef struct UiBinding UiBinding;

// --- UI SYSTEM API ---

void ui_system_init(void);
void ui_system_shutdown(void);

// UI Node Management
SceneNode* ui_node_create(SceneTree* tree, const SceneNodeSpec* spec, void* data, const MetaStruct* meta);
void ui_node_rebuild_children(SceneNode* el, SceneTree* tree);

// UI Update loop (handles animations, data binding sync)
void ui_node_update(SceneNode* element, float dt);

// Layout & Render
typedef Vec2 (*UiTextMeasureFunc)(const char* text, float scale, void* user_data);
void ui_system_layout(SceneTree* tree, float window_w, float window_h, uint64_t frame_number, UiTextMeasureFunc measure_func, void* measure_data);

// Use render_packet.h for Scene*
struct Scene; 
struct Assets;
struct MemoryArena;
void ui_system_render(SceneTree* tree, struct Scene* scene, const struct Assets* assets, struct MemoryArena* arena);

// Helpers
Rect ui_node_get_screen_rect(const SceneNode* node);

// Data Binding API
typedef enum UiBindingTarget UiBindingTarget;
typedef struct UiBinding UiBinding;
const UiBinding* ui_node_get_binding(const SceneNode* node, UiBindingTarget target);
void ui_node_write_binding_float(SceneNode* node, UiBindingTarget target, float value);
void ui_node_write_binding_string(SceneNode* node, UiBindingTarget target, const char* value);

#endif // UI_CORE_H


==================================================
FILE START: src/engine/ui/ui_input.h
==================================================
#ifndef UI_INPUT_H
#define UI_INPUT_H

#include <stdbool.h>
#include "foundation/string/string_id.h"

// Forward Declarations
typedef struct SceneNode SceneNode;
typedef struct InputSystem InputSystem;

typedef enum UiEventType {
    UI_EVENT_NONE = 0,
    UI_EVENT_CLICK,         // Triggered on mouse up (if active)
    UI_EVENT_VALUE_CHANGE,  // Triggered when input modifies data
    UI_EVENT_DRAG_START,
    UI_EVENT_DRAG_END
} UiEventType;

typedef struct UiEvent {
    UiEventType type;
    SceneNode* target;
} UiEvent;

// --- Command System ---
typedef void (*UiCommandCallback)(void* user_data, SceneNode* target);

#if defined(__GNUC__) || defined(__clang__)
#define UI_UNUSED __attribute__((unused))
#else
#define UI_UNUSED
#endif

/**
 * @brief Macro to define a typesafe UI command callback.
 * 
 * Usage:
 * UI_COMMAND(MyCommandName, MyContextType) {
 *     // 'ctx' is (MyContextType*)
 *     // 'target' is (SceneNode*)
 *     my_context_do_something(ctx);
 * }
 */
#define UI_COMMAND(CmdName, ContextType) \
    static void CmdName##_impl(ContextType* ctx UI_UNUSED, SceneNode* target UI_UNUSED); /* NOLINT(bugprone-macro-parentheses) */ \
    static void CmdName(void* user_data, SceneNode* target) { \
        CmdName##_impl((ContextType*)user_data, target); \
    } \
    static void CmdName##_impl(ContextType* ctx UI_UNUSED, SceneNode* target UI_UNUSED) // NOLINT(bugprone-macro-parentheses)

/**
 * @brief Macro to register a typesafe UI command.
 * 
 * Usage:
 * UI_REGISTER_COMMAND("MyCommand", MyCommandName, my_context_ptr);
 */
#define UI_REGISTER_COMMAND(NameStr, CmdFunc, ContextPtr) \
    ui_command_register((NameStr), (CmdFunc), (void*)(ContextPtr))

void ui_command_register(const char* name, UiCommandCallback callback, void* user_data);
void ui_command_execute_id(StringId id, SceneNode* target);

// --- Input System ---
typedef struct UiInputContext UiInputContext;

UiInputContext* ui_input_create(void);
void ui_input_destroy(UiInputContext* ctx);
void ui_input_init(UiInputContext* ctx);
void ui_input_update(UiInputContext* ctx, SceneNode* root, const InputSystem* input);
bool ui_input_pop_event(UiInputContext* ctx, UiEvent* out_event);

#endif // UI_INPUT_H


==================================================
FILE START: src/engine/ui/ui_renderer.h
==================================================
#ifndef UI_RENDERER_H
#define UI_RENDERER_H

#include <stdint.h>
#include "foundation/math/coordinate_systems.h"
#include "ui_core.h"

// Forward Declarations
typedef struct SceneTree SceneTree;
typedef struct Scene Scene;
typedef struct Assets Assets;
typedef struct MemoryArena MemoryArena;

// --- High-Level Pipeline API ---

// Layout & Render Pipeline

// Generates render commands into the Scene.
void scene_tree_render(SceneTree* instance, Scene* scene, const Assets* assets, MemoryArena* arena);

// --- Viewport Provider ---
// Callback for Viewport Rendering (dynamic 3D/custom content inside UI)
typedef void (*SceneObjectProvider)(void* instance_data, Rect screen_rect, float z_depth, Scene* scene, MemoryArena* frame_arena);

// Register a provider globally (e.g., "GraphNetwork" -> math_graph_view_provider)
void scene_register_provider(const char* name, SceneObjectProvider callback);

#endif // UI_RENDERER_H


==================================================
FILE START: src/features/math_engine/internal/emitters/glsl_emitter.c
==================================================
#include "glsl_emitter.h"
#include "foundation/memory/arena.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

// --- Helper: Simple Arena String Builder (Duplicated for now to avoid massive foundation refactor) ---
// TODO: Move this to foundation/string_utils.h

typedef struct {
    MemoryArena* arena;
    char* cursor;
    size_t capacity_left;
} EmitterStream;

static void stream_init(EmitterStream* stream, MemoryArena* arena) {
    stream->arena = arena;
    stream->cursor = (char*)(arena->base + arena->offset);
    stream->capacity_left = arena->size - arena->offset;
    if (stream->capacity_left > 0) *stream->cursor = '\0';
}

static void stream_printf(EmitterStream* stream, const char* fmt, ...) {
    if (stream->capacity_left == 0) return;

    va_list args;
    va_start(args, fmt);
    
    va_list args_copy;
    va_copy(args_copy, args);
    int len = vsnprintf(NULL, 0, fmt, args_copy);
    va_end(args_copy);
    
    if (len < 0 || (size_t)len + 1 > stream->capacity_left) {
        va_end(args);
        return; 
    }
    
    vsnprintf(stream->cursor, stream->capacity_left, fmt, args);
    stream->cursor += len;
    stream->capacity_left -= len;
    
    // Update arena offset manually since we are writing directly to memory
    stream->arena->offset += len;

    va_end(args);
}

// --- GLSL Generation Logic ---

char* ir_to_glsl(const ShaderIR* ir, TranspilerMode mode) {
    if (!ir) return NULL;

    // Estimate size: 4KB should be enough for simple shaders
    MemoryArena arena;
    if (!arena_init(&arena, 16 * 1024)) return NULL;

    EmitterStream stream;
    stream_init(&stream, &arena);

    // Header
    stream_printf(&stream, "#version 450\n");

    if (mode == TRANSPILE_MODE_IMAGE_2D) {
        stream_printf(&stream, "layout(local_size_x = 16, local_size_y = 16) in;\n\n");
        stream_printf(&stream, "layout(set=0, binding=0, rgba8) writeonly uniform image2D outImg;\n\n");
        
        stream_printf(&stream, "layout(push_constant) uniform Params {\n");
        stream_printf(&stream, "    float time;\n");
        stream_printf(&stream, "    float width;\n");
        stream_printf(&stream, "    float height;\n");
        stream_printf(&stream, "} params;\n\n");
    } else {
        stream_printf(&stream, "layout(local_size_x = 1) in;\n\n");
        stream_printf(&stream, "layout(set=0, binding=0) buffer OutBuf {\n");
        stream_printf(&stream, "    float result;\n");
        stream_printf(&stream, "} b_out;\n\n");
        
        stream_printf(&stream, "struct Params { float time; float width; float height; };\n");
        stream_printf(&stream, "const Params params = Params(0.0, 1.0, 1.0);\n\n");
    }

    stream_printf(&stream, "void main() {\n");

    // Setup UV/Coordinates
    if (mode == TRANSPILE_MODE_IMAGE_2D) {
        stream_printf(&stream, "    ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);\n");
        stream_printf(&stream, "    if (storePos.x >= int(params.width) || storePos.y >= int(params.height)) return;\n\n");
        stream_printf(&stream, "    vec2 uv = vec2(storePos) / vec2(params.width, params.height);\n\n");
    } else {
        stream_printf(&stream, "    vec2 uv = vec2(0.0, 0.0);\n\n");
    }

    // Body (Emit Instructions)
    uint32_t final_result_id = 0;
    bool has_result = false;

    for (uint32_t i = 0; i < ir->instruction_count; ++i) {
        IrInstruction* inst = &ir->instructions[i];
        
        switch (inst->op) {
            case IR_OP_CONST_FLOAT:
                stream_printf(&stream, "    float v_%d = %f;\n", inst->id, inst->float_val);
                break;
            case IR_OP_LOAD_PARAM_TIME:
                stream_printf(&stream, "    float v_%d = params.time;\n", inst->id);
                break;
            case IR_OP_LOAD_PARAM_UV:
                 stream_printf(&stream, "    float v_%d = uv.x;\n", inst->id);
                 break;
            case IR_OP_ADD:
                stream_printf(&stream, "    float v_%d = v_%d + v_%d;\n", inst->id, inst->op1_id, inst->op2_id);
                break;
            case IR_OP_SUB:
                stream_printf(&stream, "    float v_%d = v_%d - v_%d;\n", inst->id, inst->op1_id, inst->op2_id);
                break;
            case IR_OP_MUL:
                stream_printf(&stream, "    float v_%d = v_%d * v_%d;\n", inst->id, inst->op1_id, inst->op2_id);
                break;
            case IR_OP_DIV:
                stream_printf(&stream, "    float v_%d = v_%d / (v_%d + 0.0001);\n", inst->id, inst->op1_id, inst->op2_id);
                break;
            case IR_OP_SIN:
                stream_printf(&stream, "    float v_%d = sin(v_%d);\n", inst->id, inst->op1_id);
                break;
            case IR_OP_COS:
                stream_printf(&stream, "    float v_%d = cos(v_%d);\n", inst->id, inst->op1_id);
                break;
            case IR_OP_RETURN:
                final_result_id = inst->op1_id;
                has_result = true;
                break;
            default:
                break;
        }
    }

    // Output Writing
    if (has_result) {
        if (mode == TRANSPILE_MODE_IMAGE_2D) {
            stream_printf(&stream, "    float res = v_%d;\n", final_result_id);
            stream_printf(&stream, "    imageStore(outImg, storePos, vec4(res, res, res, 1.0));\n");
        } else {
            stream_printf(&stream, "    b_out.result = v_%d;\n", final_result_id);
        }
    } else {
        // Default 0
        if (mode == TRANSPILE_MODE_IMAGE_2D) {
            stream_printf(&stream, "    imageStore(outImg, storePos, vec4(0,0,0,1));\n");
        } else {
            stream_printf(&stream, "    b_out.result = 0.0;\n");
        }
    }

    stream_printf(&stream, "}\n");

    // Copy to heap and free arena
    char* result = strdup((char*)arena.base);
    arena_destroy(&arena);
    return result;
}


==================================================
FILE START: src/features/math_engine/internal/emitters/glsl_emitter.h
==================================================
#ifndef GLSL_EMITTER_H
#define GLSL_EMITTER_H

#include "../shader_ir.h"
#include "../transpiler.h" // For TranspilerMode

// Generates GLSL source code from the Shader IR.
// Returns a heap-allocated string (caller must free).
char* ir_to_glsl(const ShaderIR* ir, TranspilerMode mode);

#endif // GLSL_EMITTER_H


==================================================
FILE START: src/features/math_engine/internal/math_editor_internal.h
==================================================
#ifndef MATH_EDITOR_INTERNAL_H
#define MATH_EDITOR_INTERNAL_H

#include "engine/ui/ui_core.h"
#include "engine/ui/ui_input.h"
#include "engine/ui/ui_renderer.h"
#include "features/math_engine/math_graph.h"

// --- Layout Constants ---
#define NODE_WIDTH          150.0f
#define NODE_HEADER_HEIGHT  32.0f
#define NODE_PORT_SPACING   25.0f
#define NODE_PORT_SIZE      10.0f

// --- ViewModel for a Node in the Editor
typedef struct MathPortView {
    int index;              // REFLECT
} MathPortView;

typedef struct MathNodeView {
    MathNodeId node_id;     // REFLECT
    float x;                // REFLECT
    float y;                // REFLECT
    
    // Cached Data for UI Binding (ViewModel pattern)
    char name[32];          // REFLECT
    float value;            // REFLECT (Input/Output preview)

    MathPortView input_ports[4];  // REFLECT
    int input_ports_count;        // REFLECT

    MathPortView output_ports[1]; // REFLECT
    int output_ports_count;       // REFLECT
} MathNodeView;

typedef struct MathWireView {
    Vec2 start;            // REFLECT
    Vec2 end;              // REFLECT
    Vec4 color;            // REFLECT
    float thickness;       // REFLECT
} MathWireView;

// --- Serialization DTOs (Strict Separation) ---

typedef struct MathNodeLogicBP {
    MathNodeType type;      // REFLECT
    float value;            // REFLECT (Default value)
    
    // Connections: Indices in the blueprint array (-1 = none)
    int input_0;            // REFLECT 
    int input_1;            // REFLECT
    int input_2;            // REFLECT
    int input_3;            // REFLECT
} MathNodeLogicBP;

typedef struct MathNodeLayoutBP {
    float x;                // REFLECT
    float y;                // REFLECT
    char name[32];          // REFLECT
} MathNodeLayoutBP;

typedef struct MathNodeBlueprint {
    MathNodeLogicBP logic;   // REFLECT
    MathNodeLayoutBP layout; // REFLECT
} MathNodeBlueprint;

typedef struct MathGraphBlueprint {
    MathNodeBlueprint** nodes;  // REFLECT
    size_t node_count;          // REFLECT
} MathGraphBlueprint;

typedef struct MathNodePaletteItem {
    char label[32];         // REFLECT
    int type;               // REFLECT (MathNodeType)
} MathNodePaletteItem;

// --- Graph View (The "V" in MVC) ---
typedef struct MathGraphView {
    // ViewModel Data
    MathNodeView* node_views;   // REFLECT
    uint32_t node_views_count;  // REFLECT
    uint32_t node_view_cap;

    MathWireView* wires;        // REFLECT
    uint32_t wires_count;       // REFLECT
    uint32_t wires_cap;
    
    // UI State (Owned by View)
    SceneAsset* ui_asset;
    SceneTree* ui_instance; // Manages UI Element memory
    UiInputContext* input_ctx;

    // Selection
    MathNodeId selected_node_id;
    bool selection_dirty;

    // UI Binding for Inspector (Polymorphic List of 0 or 1 item)
    MathNode** selected_nodes;   // REFLECT
    int selected_nodes_count;    // REFLECT
    
    bool has_selection;          // REFLECT (helper for UI visibility)
    bool no_selection;           // REFLECT (helper for UI visibility)
} MathGraphView;

// The State of the Graph Editor Feature (The "C" in MVC)
typedef struct MathEditor {
    MathGraph* graph;
    MemoryArena graph_arena;
    
    MathGraphView* view; // REFLECT
    
    // Palette Data (Logic/Toolbox)
    MathNodePaletteItem** palette_items; // REFLECT
    size_t palette_items_count;          // REFLECT

    bool graph_dirty;
    uint32_t current_pipeline; // Vulkan Compute Pipeline ID
} MathEditor;

#endif // MATH_EDITOR_INTERNAL_H


==================================================
FILE START: src/features/math_engine/internal/math_editor_view.c
==================================================
#include "math_editor_view.h"
#include "math_editor_internal.h"
#include "math_graph_internal.h"
#include "engine/scene/render_packet.h"
#include "foundation/logger/logger.h"
#include <string.h>

// --- View Model Management ---

MathNodeView* math_editor_add_view(MathEditor* editor, MathNodeId id, float x, float y) {
    if (editor->view->node_views_count >= editor->view->node_view_cap) {
        uint32_t new_cap = editor->view->node_view_cap ? editor->view->node_view_cap * 2 : 16;
        MathNodeView* new_arr = arena_alloc_zero(&editor->graph_arena, new_cap * sizeof(MathNodeView));
        if (editor->view->node_views) {
            memcpy(new_arr, editor->view->node_views, editor->view->node_views_count * sizeof(MathNodeView));
        }
        editor->view->node_views = new_arr;
        editor->view->node_view_cap = new_cap;
    }
    MathNodeView* view = &editor->view->node_views[editor->view->node_views_count++];
    view->node_id = id;
    view->x = x;
    view->y = y;
    return view;
}

MathNodeView* math_editor_find_view(MathEditor* editor, MathNodeId id) {
    for(uint32_t i=0; i<editor->view->node_views_count; ++i) {
        if (editor->view->node_views[i].node_id == id) {
            return &editor->view->node_views[i];
        }
    }
    return NULL;
}

static int get_node_input_count(MathNodeType type) {
    switch (type) {
        case MATH_NODE_ADD: 
        case MATH_NODE_SUB: 
        case MATH_NODE_MUL: 
        case MATH_NODE_DIV: return 2;
        case MATH_NODE_SIN: 
        case MATH_NODE_COS: 
        case MATH_NODE_OUTPUT: return 1;
        case MATH_NODE_UV:  
        case MATH_NODE_VALUE: 
        case MATH_NODE_TIME: 
        default: return 0;
    }
}

void math_editor_sync_view_data(MathEditor* editor) {
    for(uint32_t i=0; i<editor->view->node_views_count; ++i) {
        MathNodeView* view = &editor->view->node_views[i];
        // Use internal accessor (visible via math_graph_internal.h)
        MathNode* node = math_graph_get_node(editor->graph, view->node_id);
        if(node) {
            // One-way binding: Logic -> View
            strncpy(view->name, node->name, 31);
            view->value = node->value;

            // Sync Inputs
            int input_count = get_node_input_count(node->type);
            view->input_ports_count = input_count;
            for(int k=0; k<input_count; ++k) {
                view->input_ports[k].index = k;
            }

            // Sync Outputs (Most nodes have 1 output, except OUTPUT node)
            if (node->type != MATH_NODE_OUTPUT) {
                view->output_ports_count = 1;
                view->output_ports[0].index = -1; 
            } else {
                view->output_ports_count = 0;
            }
        }
    }
}

// --- UI Sync ---

void math_editor_refresh_graph_view(MathEditor* editor) {
    SceneNode* root = scene_tree_get_root(editor->view->ui_instance);
    if (!root) return;
    
    // Sync data before rebuild
    math_editor_sync_view_data(editor);

    SceneNode* canvas = scene_node_find_by_id(root, "canvas_area");
    if (canvas) {
        // Declarative Refresh
        ui_node_rebuild_children(canvas, editor->view->ui_instance);
    }
}

void math_editor_update_selection(MathEditor* editor) {
    if (!editor) return;

    // 1. Update ViewModel (Selection Array)
    editor->view->selected_nodes_count = 0;
    if (editor->view->selected_node_id != MATH_NODE_INVALID_ID) {
        MathNode* node = math_graph_get_node(editor->graph, editor->view->selected_node_id);
        if (node) {
            editor->view->selected_nodes[0] = node;
            editor->view->selected_nodes_count = 1;
        }
    }
    
    editor->view->has_selection = (editor->view->selected_nodes_count > 0);
    editor->view->no_selection = !editor->view->has_selection;

    // 2. Trigger UI Rebuild for Inspector
    SceneNode* root = scene_tree_get_root(editor->view->ui_instance);
    if (root) {
        SceneNode* inspector = scene_node_find_by_id(root, "inspector_area");
        if (inspector) {
             ui_node_rebuild_children(inspector, editor->view->ui_instance);
        }
    }
}

// --- Rendering Logic ---

// Z-Layer Offsets
#define LAYER_OFFSET_WIRE    0.005f
#define LAYER_OFFSET_PORT    0.020f

void math_editor_sync_wires(MathEditor* editor) {
    if (!editor || !editor->view->wires) return;

    editor->view->wires_count = 0;

    for (uint32_t i = 0; i < editor->graph->node_count; ++i) {
        MathNode* target_node = math_graph_get_node(editor->graph, i);
        if (!target_node || target_node->type == MATH_NODE_NONE) continue;
        
        MathNodeView* target_view = math_editor_find_view(editor, target_node->id);
        if (!target_view) continue;

        for (int k = 0; k < MATH_NODE_MAX_INPUTS; ++k) {
            MathNodeId source_id = target_node->inputs[k];
            if (source_id == MATH_NODE_INVALID_ID) continue;
            
            MathNodeView* source_view = math_editor_find_view(editor, source_id);
            if (!source_view) continue;

            if (editor->view->wires_count >= editor->view->wires_cap) break;

            MathWireView* wire = &editor->view->wires[editor->view->wires_count++];
            
            // Output Port is usually on the right side of the node
            float start_x = source_view->x + NODE_WIDTH + NODE_PORT_SIZE * 0.5f;
            float start_y = source_view->y + NODE_HEADER_HEIGHT + NODE_PORT_SIZE * 0.5f;

            // Input Port is on the left side, offset by index K
            float end_x = target_view->x + NODE_PORT_SIZE * 0.5f;
            float end_y = target_view->y + NODE_HEADER_HEIGHT + (k * NODE_PORT_SPACING) + NODE_PORT_SIZE * 0.5f;
            
            wire->start = (Vec2){start_x, start_y};
            wire->end = (Vec2){end_x, end_y};
            wire->thickness = 3.0f;
            wire->color = (Vec4){0.8f, 0.8f, 0.8f, 1.0f};
        }
    }
}


==================================================
FILE START: src/features/math_engine/internal/math_editor_view.h
==================================================
#ifndef MATH_EDITOR_VIEW_H
#define MATH_EDITOR_VIEW_H

#include "math_editor_internal.h"
#include "engine/scene/render_packet.h"
#include "foundation/memory/arena.h"

// --- View Model Management ---

MathNodeView* math_editor_add_view(MathEditor* editor, MathNodeId id, float x, float y);
MathNodeView* math_editor_find_view(MathEditor* editor, MathNodeId id);

void math_editor_sync_view_data(MathEditor* editor);
void math_editor_sync_wires(MathEditor* editor);

// --- UI / Rendering ---

// Triggers UI rebuild for the Canvas and Inspector
void math_editor_refresh_graph_view(MathEditor* editor);

// Updates selection state and rebuilds Inspector UI
void math_editor_update_selection(MathEditor* editor);

#endif // MATH_EDITOR_VIEW_H


==================================================
FILE START: src/features/math_engine/internal/math_graph_internal.h
==================================================
#ifndef MATH_GRAPH_INTERNAL_H
#define MATH_GRAPH_INTERNAL_H

#include "../math_graph.h"
#include "foundation/memory/pool.h"
#include "foundation/math/coordinate_systems.h"

// --- Internal Types ---

struct MathNode {
    MathNodeId id;          // REFLECT
    MathNodeType type;      // REFLECT
    
    // Logic Data
    float value;            // REFLECT
    bool dirty;             // REFLECT
    float cached_output;    // REFLECT
    
    // Connections (Dependencies)
    // Stores the IDs of the nodes connected to input slots.
    MathNodeId inputs[MATH_NODE_MAX_INPUTS]; 
    
    // UI / Editor Data (Moved to MathNodeView in Editor)
    char name[32];          // REFLECT
};

struct MathGraph {
    struct MemoryPool* node_pool; // From foundation/memory/pool.h
    
    // Indirection table: ID -> MathNode*
    // This array grows, but the nodes themselves stay stable in the pool.
    MathNode** node_ptrs;    // REFLECT
    uint32_t node_count;     // REFLECT
    uint32_t node_capacity;  // Capacity
};

// --- Internal API ---

// Get a pointer to the node data.
// Exposed internally for the Editor/Feature implementation, but hidden from public API.
MathNode* math_graph_get_node(MathGraph* graph, MathNodeId id);

#endif // MATH_GRAPH_INTERNAL_H


==================================================
FILE START: src/features/math_engine/internal/shader_ir.h
==================================================
#ifndef SHADER_IR_H
#define SHADER_IR_H

#include <stdint.h>
#include <stdbool.h>

// Intermediate Representation OpCodes
typedef enum IrOpCode {
    IR_OP_NOP = 0,
    
    // Values & Parameters
    IR_OP_CONST_FLOAT,      // res = float_val
    IR_OP_LOAD_PARAM_TIME,  // res = time
    IR_OP_LOAD_PARAM_UV,    // res = uv.x (or uv vector in future)
    
    // Arithmetic
    IR_OP_ADD,              // res = op1 + op2
    IR_OP_SUB,              // res = op1 - op2
    IR_OP_MUL,              // res = op1 * op2
    IR_OP_DIV,              // res = op1 / op2
    
    // Math Functions
    IR_OP_SIN,              // res = sin(op1)
    IR_OP_COS,              // res = cos(op1)

    // Output
    IR_OP_RETURN            // result = op1 (Final output of the shader)
} IrOpCode;

typedef struct IrInstruction {
    IrOpCode op;
    uint32_t id;            // Result ID (Virtual Register)
    uint32_t op1_id;        // Operand 1 ID (0 if unused)
    uint32_t op2_id;        // Operand 2 ID (0 if unused)
    float float_val;        // For IR_OP_CONST_FLOAT
} IrInstruction;

typedef struct ShaderIR {
    IrInstruction* instructions;
    uint32_t instruction_count;
    uint32_t instruction_capacity;
} ShaderIR;

#endif // SHADER_IR_H


==================================================
FILE START: src/features/math_engine/internal/transpiler.c
==================================================
#include "transpiler.h"
#include "math_graph_internal.h"
#include "shader_ir.h"
#include "emitters/glsl_emitter.h"
#include "foundation/memory/arena.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// --- IR Generation Logic ---

static bool is_visited(int* visited, int count, int id) {
    for (int i = 0; i < count; ++i) {
        if (visited[i] == id) return true;
    }
    return false;
}

static void generate_ir_node(const MathGraph* graph, MathNodeId id, ShaderIR* ir, int* visited, int* visited_count) {
    if (id == MATH_NODE_INVALID_ID) return;
    if (is_visited(visited, *visited_count, (int)id)) return; 
    
    // Access node
    const MathNode* node = math_graph_get_node((MathGraph*)graph, id);
    if (!node) return;
    if (node->type == MATH_NODE_NONE) return;

    // Visit inputs first (Post-order traversal)
    for (int i = 0; i < MATH_NODE_MAX_INPUTS; ++i) {
        if (node->inputs[i] != MATH_NODE_INVALID_ID) {
            generate_ir_node(graph, node->inputs[i], ir, visited, visited_count);
        }
    }
    
    // Generate IR instruction
    IrInstruction inst = { .op = IR_OP_NOP, .id = node->id, .op1_id = 0, .op2_id = 0, .float_val = 0.0f };

    switch (node->type) {
        case MATH_NODE_VALUE:
            inst.op = IR_OP_CONST_FLOAT;
            inst.float_val = node->value;
            break;
        
        case MATH_NODE_TIME:
            inst.op = IR_OP_LOAD_PARAM_TIME;
            break;

        case MATH_NODE_UV:
             inst.op = IR_OP_LOAD_PARAM_UV;
             break;
            
        case MATH_NODE_ADD:
            inst.op = IR_OP_ADD;
            inst.op1_id = node->inputs[0];
            inst.op2_id = node->inputs[1];
            break;
            
        case MATH_NODE_SUB:
            inst.op = IR_OP_SUB;
            inst.op1_id = node->inputs[0];
            inst.op2_id = node->inputs[1];
            break;

        case MATH_NODE_MUL:
            inst.op = IR_OP_MUL;
            inst.op1_id = node->inputs[0];
            inst.op2_id = node->inputs[1];
            break;

        case MATH_NODE_DIV:
            inst.op = IR_OP_DIV;
            inst.op1_id = node->inputs[0];
            inst.op2_id = node->inputs[1];
            break;
            
        case MATH_NODE_SIN:
            inst.op = IR_OP_SIN;
            inst.op1_id = node->inputs[0];
            break;

        case MATH_NODE_COS:
            inst.op = IR_OP_COS;
            inst.op1_id = node->inputs[0];
            break;

        default:
            // Unknown node type
            break;
    }

    if (inst.op != IR_OP_NOP) {
        if (ir->instruction_count < ir->instruction_capacity) {
            ir->instructions[ir->instruction_count++] = inst;
        }
    }
    
    visited[(*visited_count)++] = node->id;
}

static ShaderIR math_graph_to_ir(const MathGraph* graph) {
    ShaderIR ir;
    ir.instruction_capacity = 256; // Fixed max instructions for now
    ir.instructions = (IrInstruction*)calloc(ir.instruction_capacity, sizeof(IrInstruction));
    ir.instruction_count = 0;

    int* visited = (int*)calloc(graph->node_count, sizeof(int));
    int visited_count = 0;

    // Traverse all nodes
    // Note: In a real compiler, we would only traverse from the "Output" node.
    // Here we traverse everything, similar to the previous implementation.
    for (uint32_t i = 0; i < graph->node_count; ++i) {
        const MathNode* n = math_graph_get_node((MathGraph*)graph, i);
        if (n && n->type != MATH_NODE_NONE) {
            generate_ir_node(graph, i, &ir, visited, &visited_count);
        }
    }
    
    // Determine Output Node (Last non-free node)
    int last_id = -1;
    for (int i = (int)graph->node_count - 1; i >= 0; --i) {
        const MathNode* n = math_graph_get_node((MathGraph*)graph, i);
        if (n && n->type != MATH_NODE_NONE) {
            last_id = i;
            break;
        }
    }

    if (last_id != -1) {
        if (ir.instruction_count < ir.instruction_capacity) {
            IrInstruction ret_inst = { .op = IR_OP_RETURN, .id = 0, .op1_id = last_id };
            ir.instructions[ir.instruction_count++] = ret_inst;
        }
    }

    free(visited);
    return ir;
}

static void free_ir(ShaderIR* ir) {
    if (ir->instructions) {
        free(ir->instructions);
    }
}

char* math_graph_transpile(const MathGraph* graph, TranspilerMode mode, ShaderTarget target) {
    if (!graph) return NULL; 

    // Phase 1: Generate IR
    ShaderIR ir = math_graph_to_ir(graph);

    // Phase 2: Emit Code based on Target
    char* result = NULL;
    switch (target) {
        case SHADER_TARGET_GLSL_VULKAN:
            result = ir_to_glsl(&ir, mode);
            break;
        default:
            // Fallback or error
            break;
    }

    // Cleanup
    free_ir(&ir);

    return result;
}


==================================================
FILE START: src/features/math_engine/internal/transpiler.h
==================================================
#ifndef TRANSPILER_H
#define TRANSPILER_H

#include "features/math_engine/math_graph.h"
#include <stdbool.h>

typedef enum TranspilerMode {
    TRANSPILE_MODE_BUFFER_1D = 0, // Output: float result (Compute Buffer)
    TRANSPILE_MODE_IMAGE_2D   // Output: image2D (Storage Image)
} TranspilerMode;

typedef enum ShaderTarget {
    SHADER_TARGET_GLSL_VULKAN,
    // Future: SHADER_TARGET_WGSL_WEBGPU,
    // Future: SHADER_TARGET_MSL_METAL
} ShaderTarget;

// Generates shader source code for the specified target.
// Returns a heap-allocated string that must be freed by the caller.
char* math_graph_transpile(const MathGraph* graph, TranspilerMode mode, ShaderTarget target);

#endif // TRANSPILER_H


==================================================
FILE START: src/features/math_engine/math_editor.c
==================================================
#include "math_editor.h"
#include "engine/core/engine.h"
#include "internal/math_editor_internal.h"
#include "internal/math_editor_view.h"

#include "foundation/logger/logger.h"
#include "foundation/platform/platform.h"
#include "foundation/platform/fs.h"
#include "foundation/meta/reflection.h"
#include "foundation/config/simple_yaml.h"
#include "foundation/config/config_system.h"
#include "features/math_engine/internal/transpiler.h"
#include "features/math_engine/internal/math_graph_internal.h" // Access to internal Graph/Node structs
#include "engine/graphics/internal/renderer_backend.h"
#include "engine/graphics/layer_constants.h"
#include "engine/text/font.h"
#include "engine/assets/assets.h"
#include "engine/graphics/render_system.h"
#include "engine/input/input.h"
#include "engine/scene/render_packet.h"

#include "engine/ui/ui_core.h"
#include "engine/ui/ui_input.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// --- Helper: Text Measurement for UI Layout ---
static Vec2 text_measure_wrapper(const char* text, float scale, void* user_data) {
    const Font* font = (const Font*)user_data;
    float w = font_measure_text(font, text) * scale;
    return (Vec2){w, 20.0f * scale}; // Fixed height for now
}

// --- Recompilation Logic ---

static void math_editor_recompile_graph(MathEditor* editor, RenderSystem* rs) {
    if (!editor || !rs) return;

    LOG_INFO("Editor: Recompiling Math Graph...");

    // 1. Transpile to GLSL
    char* glsl = math_graph_transpile(editor->graph, TRANSPILE_MODE_IMAGE_2D, SHADER_TARGET_GLSL_VULKAN);
    if (!glsl) {
        LOG_ERROR("Transpilation failed.");
        return;
    }

    // 2. Create Pipeline (Compiles internally)
    uint32_t new_pipe = render_system_create_compute_pipeline_from_source(rs, glsl);
    free(glsl);

    if (new_pipe == 0) {
        LOG_ERROR("Failed to create compute pipeline");
        return;
    }

    // 3. Swap
    if (editor->current_pipeline > 0) {
        render_system_destroy_compute_pipeline(rs, editor->current_pipeline);
    }
    editor->current_pipeline = new_pipe;
    render_system_set_compute_pipeline(rs, new_pipe);
    
    LOG_INFO("Editor: Graph Recompiled Successfully (ID: %u)", new_pipe);
}

// --- Commands ---

UI_COMMAND(cmd_add_node, MathEditor) {
    LOG_INFO("Command: Graph.AddNode");
    
    MathNodeType type = MATH_NODE_VALUE;

    // Try to extract type from PaletteItem data bound to the UI element
    if (target) {
        void* data = scene_node_get_data(target);
        const MetaStruct* meta = scene_node_get_meta(target);
        
        // If the button itself doesn't have data, check parent
        if (!data) {
             SceneNode* p = scene_node_get_parent(target);
             if(p) {
                 data = scene_node_get_data(p);
                 meta = scene_node_get_meta(p);
             }
        }

        if (data && meta && strcmp(meta->name, "MathNodePaletteItem") == 0) {
            MathNodePaletteItem* item = (MathNodePaletteItem*)data;
            type = (MathNodeType)item->type;
        }
    }
    
    MathNodeId id = math_graph_add_node(ctx->graph, type);
    // Center roughly or use mouse pos if available (future)
    math_editor_add_view(ctx, id, 100, 100); 
    
    math_editor_refresh_graph_view(ctx);
}

UI_COMMAND(cmd_clear_graph, MathEditor) {
    LOG_INFO("Command: Graph.Clear");
    
    // 1. Clear Logic
    math_graph_clear(ctx->graph);
    
    // 2. Clear View
    // We don't free node_views memory, just reset count. 
    // The memory will be reused.
    ctx->view->node_views_count = 0;
    
    // 3. Clear Selection
    ctx->view->selected_node_id = MATH_NODE_INVALID_ID;
    ctx->view->selection_dirty = true; // Trigger inspector clear
    
    // 4. Trigger UI Refresh
    math_editor_refresh_graph_view(ctx);
    
    // 5. Trigger Compute Recompile (empty graph)
    ctx->graph_dirty = true;
}

UI_COMMAND(cmd_recompile, MathEditor) {
    ctx->graph_dirty = true;
}

// --- Lifecycle ---

static void math_editor_load_graph(MathEditor* editor, const char* path) {
    LOG_INFO("Editor: Loading graph from %s", path);
    char* content = fs_read_text(NULL, path);
    if (!content) {
        LOG_WARN("Failed to load graph: %s. Using fallback.", path);
        // Fallback: simple UV node
        MathNodeId uv_id = math_graph_add_node(editor->graph, MATH_NODE_UV);
        math_editor_add_view(editor, uv_id, 100, 100);
        return;
    }

    ConfigNode* root = NULL;
    ConfigError err = {0};
    
    // Parse into the graph arena
    if (!simple_yaml_parse(&editor->graph_arena, content, &root, &err)) {
        LOG_ERROR("YAML Error in %s: %s", path, err.message);
        free(content);
        return;
    }
    free(content);

    const ConfigNode* nodes_list = config_node_map_get(root, "nodes");
    if (!nodes_list || nodes_list->type != CONFIG_NODE_SEQUENCE) return;

    size_t count = nodes_list->item_count;
    if (count == 0) return;

    MathNodeBlueprint* bps = arena_alloc_zero(&editor->graph_arena, count * sizeof(MathNodeBlueprint));
    const MetaStruct* meta_bp = meta_get_struct("MathNodeBlueprint");
    if (!meta_bp) {
        LOG_ERROR("MathNodeBlueprint meta not found!");
        return;
    }

    // 1. Load Blueprints
    for(size_t i=0; i<count; ++i) {
        // Init Defaults
        bps[i].logic.input_0 = -1;
        bps[i].logic.input_1 = -1;
        bps[i].logic.input_2 = -1;
        bps[i].logic.input_3 = -1;
        
        config_load_struct(nodes_list->items[i], meta_bp, &bps[i], &editor->graph_arena);
    }

    // 2. Create Nodes
    MathNodeId* id_map = arena_alloc(&editor->graph_arena, count * sizeof(MathNodeId)); 
    
    for(size_t i=0; i<count; ++i) {
        MathNodeBlueprint* bp = &bps[i];
        
        // Ensure type is valid (defaults to 0 which might be MATH_NODE_NONE)
        if (bp->logic.type == 0) bp->logic.type = MATH_NODE_VALUE; 

        MathNodeId id = math_graph_add_node(editor->graph, bp->logic.type);
        id_map[i] = id;
        
        // Logic Properties
        math_graph_set_value(editor->graph, id, bp->logic.value);
        math_graph_set_name(editor->graph, id, bp->layout.name); 
        
        // View Properties
        math_editor_add_view(editor, id, bp->layout.x, bp->layout.y);
    }

    // 3. Connect Nodes
    for(size_t i=0; i<count; ++i) {
        MathNodeBlueprint* bp = &bps[i];
        MathNodeId target_id = id_map[i];

        int inputs[4] = {bp->logic.input_0, bp->logic.input_1, bp->logic.input_2, bp->logic.input_3};
        
        for(int k=0; k<4; ++k) {
            int source_idx = inputs[k];
            if (source_idx >= 0 && source_idx < (int)count) {
                math_graph_connect(editor->graph, target_id, k, id_map[source_idx]);
            }
        }
    }
    
    math_editor_sync_view_data(editor);
}

static void math_editor_load_palette(MathEditor* editor, const char* path) {
    char* content = fs_read_text(NULL, path);
    if (!content) {
        LOG_WARN("Failed to load palette config: %s", path);
        return;
    }
    
    ConfigNode* root = NULL;
    ConfigError err = {0};
    
    // Parse into the graph arena (persists until editor destroy)
    if (!simple_yaml_parse(&editor->graph_arena, content, &root, &err)) {
        LOG_ERROR("YAML Parse Error in %s line %d: %s", path, err.line, err.message);
        free(content);
        return;
    }
    
    free(content); // Raw text no longer needed
    
    if (!root || root->type != CONFIG_NODE_MAP) {
        return;
    }
    
    const ConfigNode* items_node = config_node_map_get(root, "items");
    if (items_node) {
        const MetaStruct* meta = meta_get_struct("MathNodePaletteItem");
        if (meta) {
            config_load_struct_array(items_node, meta, (void***)&editor->palette_items, &editor->palette_items_count, &editor->graph_arena);
            LOG_INFO("Editor: Loaded %zu palette items from %s", editor->palette_items_count, path);
        } else {
            LOG_ERROR("MathNodePaletteItem meta not found! Check codegen.");
        }
    }
}

MathEditor* math_editor_create(Engine* engine) {
    MathEditor* editor = (MathEditor*)calloc(1, sizeof(MathEditor));
    if (!editor) return NULL;

    // 1. Init Memory
    arena_init(&editor->graph_arena, 1024 * 1024); // 1MB for Graph Data
    // Use factory function (Heap alloc via Arena)
    editor->graph = math_graph_create(&editor->graph_arena);

    // Init View
    editor->view = arena_alloc_zero(&editor->graph_arena, sizeof(MathGraphView));
    
    // Allocate selection array (Capacity 1 for now)
    editor->view->selected_nodes = (MathNode**)calloc(1, sizeof(MathNode*));
    
    // Wires Buffer
    editor->view->wires_cap = 1024;
    editor->view->wires = arena_alloc_zero(&editor->graph_arena, editor->view->wires_cap * sizeof(MathWireView));

    editor->view->node_views = NULL;
    editor->view->node_views_count = 0;
    editor->view->node_view_cap = 0;
    
    editor->view->selected_node_id = MATH_NODE_INVALID_ID;
    editor->view->has_selection = false;
    editor->view->no_selection = true;
    
    // 2. Setup Default Data
    math_editor_load_graph(editor, "assets/ui/default_graph.yaml");
    math_editor_load_palette(editor, "assets/ui/palette_config.yaml");

    // Sync View Models (Nodes & Wires) before UI creation
    math_editor_sync_view_data(editor);
    math_editor_sync_wires(editor);

    // 3. Init UI System
    // ui_command_init(); // Managed by Engine Core
    UI_REGISTER_COMMAND("Graph.AddNode", cmd_add_node, editor);
    UI_REGISTER_COMMAND("Graph.Clear", cmd_clear_graph, editor);
    UI_REGISTER_COMMAND("Graph.Recompile", cmd_recompile, editor);
    
    // ui_register_provider("GraphNetwork", math_graph_view_provider); // Removed: All UI is declarative now

    editor->view->input_ctx = ui_input_create();

    // 4. Load UI Asset
    const char* ui_path_raw = engine_get_config(engine)->ui_path; 
    const char* assets_root = assets_get_root_dir(engine_get_assets(engine));
    
    // Normalize path: if it starts with "assets/", strip it to get relative path for the Asset System
    const char* ui_rel_path = ui_path_raw;
    if (ui_path_raw && assets_root) {
        size_t root_len = strlen(assets_root);
        if (strncmp(ui_path_raw, assets_root, root_len) == 0) {
            if (ui_path_raw[root_len] == '/' || ui_path_raw[root_len] == '\\') {
                ui_rel_path = ui_path_raw + root_len + 1;
            }
        }
    }

    if (ui_rel_path) {
        editor->view->ui_asset = assets_load_scene(engine_get_assets(engine), ui_rel_path);
        if (!editor->view->ui_asset) {
             LOG_ERROR("Failed to load UI asset: %s (Raw: %s)", ui_rel_path, ui_path_raw);
        }
    } else {
        editor->view->ui_asset = NULL;
    }

    editor->view->ui_instance = scene_tree_create(editor->view->ui_asset, 1024 * 1024); // 1MB for UI Elements

    if (editor->view->ui_asset) {
            // NOTE: We now bind MathEditor, not MathGraph!
            const MetaStruct* editor_meta = meta_get_struct("MathEditor");
            if (!editor_meta) {
                 LOG_ERROR("MathEditor meta not found! Did you run codegen?");
            }
            
            // Build Static UI from Asset into Instance
            SceneNode* root = ui_node_create(editor->view->ui_instance, scene_asset_get_root(editor->view->ui_asset), editor, editor_meta);
            scene_tree_set_root(editor->view->ui_instance, root);
            
            // Initial Select
            if (editor->view->node_views_count > 0) {
                editor->view->selected_node_id = editor->view->node_views[0].node_id;
                math_editor_update_selection(editor);
            }
    }

    // 5. Initial Compute Compile
    engine_set_show_compute(engine, true);
    render_system_set_show_compute(engine_get_render_system(engine), true);
    math_editor_recompile_graph(editor, engine_get_render_system(engine));

    // 6. Input Mappings
    InputSystem* input = engine_get_input_system(engine);
    if (input) {
        input_map_action(input, "ToggleCompute", INPUT_KEY_C, INPUT_MOD_NONE);
    }
    
    return editor;
}

#include "engine/scene/render_packet.h"

void math_editor_render(MathEditor* editor, Scene* scene, const struct Assets* assets, MemoryArena* arena) {
    if (!editor || !scene || !editor->view->ui_instance) return;

    // Delegate entire rendering to UI system.
    ui_system_render(editor->view->ui_instance, scene, assets, arena);
}

void math_editor_update(MathEditor* editor, Engine* engine) {
    if (!editor) return;
    
    // Sync Logic -> View (one way binding for visual updates)
    math_editor_sync_view_data(editor);

    // Toggle Visualizer (Hotkey C) - Action Based
    if (input_is_action_just_pressed(engine_get_input_system(engine), "ToggleCompute")) {
         bool show = !engine_get_show_compute(engine);
         engine_set_show_compute(engine, show);
         render_system_set_show_compute(engine_get_render_system(engine), show);
         if (show) {
             editor->graph_dirty = true; 
         }
    }

    SceneNode* root = scene_tree_get_root(editor->view->ui_instance);

    // UI Update Loop
    if (root) {
        // Animation / Logic Update
        ui_node_update(root, engine_get_dt(engine));
        
        // Input Handling
        ui_input_update(editor->view->input_ctx, root, engine_get_input_system(engine));
        
        // Sync Wires AFTER input (so they attach to new node positions)
        math_editor_sync_wires(editor);
        
        // Process Events
        UiEvent evt;
        while (ui_input_pop_event(editor->view->input_ctx, &evt)) {
            switch (evt.type) {
                case UI_EVENT_VALUE_CHANGE:
                case UI_EVENT_DRAG_END:
                    editor->graph_dirty = true;
                    // If drag end was on a view node, update its x/y is automatic via UI binding,
                    // but we don't need to sync back to logic because logic doesn't have x/y anymore!
                    // This is the beauty of separation.
                    break;
                case UI_EVENT_CLICK: {
                    // Selection Logic
                    SceneNode* hit = evt.target;
                    while (hit) {
                        // Check for MathNodeView
                        void* data = scene_node_get_data(hit);
                        const MetaStruct* meta = scene_node_get_meta(hit);

                        if (data && meta && strcmp(meta->name, "MathNodeView") == 0) {
                            MathNodeView* v = (MathNodeView*)data;
                            editor->view->selected_node_id = v->node_id;
                            editor->view->selection_dirty = true;
                            LOG_INFO("Selected Node: %d", v->node_id);
                            break;
                        }
                        hit = scene_node_get_parent(hit);
                    }
                } break;
                default: break;
            }
        }
        
        // Lazy Inspector Rebuild
        if (editor->view->selection_dirty) {
            math_editor_update_selection(editor);
            editor->view->selection_dirty = false;
        }
        
        // Layout
        PlatformWindowSize size = platform_get_framebuffer_size(engine_get_window(engine));
        ui_system_layout(editor->view->ui_instance, (float)size.width, (float)size.height, render_system_get_frame_count(engine_get_render_system(engine)), text_measure_wrapper, (void*)assets_get_font(engine_get_assets(engine)));
    }

    // Graph Evaluation (Naive interpretation on CPU for debugging/node values)
    if (editor->graph && (editor->graph_dirty || editor->view->selection_dirty)) { 
        for (uint32_t i = 0; i < editor->graph->node_count; ++i) { 
            const MathNode* n = math_graph_get_node(editor->graph, i);
            if (n && n->type != MATH_NODE_NONE) {
                math_graph_evaluate(editor->graph, i);
            }
        }
    }

    // Recompile Compute Shader if dirty
    if (editor->graph_dirty && engine_get_show_compute(engine)) {
        math_editor_recompile_graph(editor, engine_get_render_system(engine));
        editor->graph_dirty = false;
    }
}

void math_editor_destroy(MathEditor* editor) {
    if (!editor) return;
    
    if (editor->view) {
        ui_input_destroy(editor->view->input_ctx);
        scene_tree_destroy(editor->view->ui_instance);
        if (editor->view->ui_asset) scene_asset_destroy(editor->view->ui_asset);
        if (editor->view->selected_nodes) free((void*)editor->view->selected_nodes);
    }
    
    // Explicitly destroy graph resources (pool, ptrs)
    math_graph_destroy(editor->graph);
    
    arena_destroy(&editor->graph_arena);
    
    if (editor->palette_items) {
        // Items are in arena, but array pointer might be arena or heap? 
        // config_load_struct_array uses arena. So no free needed for palette_items if arena is destroyed.
        // But selected_nodes was malloc'd.
    }

    free(editor);
}


==================================================
FILE START: src/features/math_engine/math_editor.h
==================================================
#ifndef MATH_EDITOR_H
#define MATH_EDITOR_H

// Forward Declarations
typedef struct Engine Engine;
typedef struct Scene Scene;
typedef struct Assets Assets;
typedef struct MemoryArena MemoryArena;

// Opaque Handle
typedef struct MathEditor MathEditor;

// API

// Creates the editor instance (allocates memory)
MathEditor* math_editor_create(Engine* engine);

// Updates the editor state (Input, UI Layout, Transpilation)
void math_editor_update(MathEditor* editor, Engine* engine);

// Renders the editor UI to the provided scene
void math_editor_render(MathEditor* editor, Scene* scene, const Assets* assets, MemoryArena* arena);

// Shuts down the editor and frees resources
void math_editor_destroy(MathEditor* editor);

#endif // MATH_EDITOR_H


==================================================
FILE START: src/features/math_engine/math_graph.c
==================================================
#include "math_graph.h"
#include "internal/math_graph_internal.h"
#include "foundation/memory/pool.h"
#include "foundation/logger/logger.h"
#include <string.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h> // for realloc

// --- Helper: Get Node ---
MathNode* math_graph_get_node(MathGraph* graph, MathNodeId id) {
    if (!graph || !graph->node_ptrs || id >= graph->node_count) return NULL;
    MathNode* node = graph->node_ptrs[id];
    if (!node) return NULL; // Should not happen if count is correct, unless deleted?
    if (node->type == MATH_NODE_NONE) return NULL;
    return node;
}

// --- Create / Destroy ---

MathGraph* math_graph_create(MemoryArena* arena) {
    if (!arena) {
        LOG_ERROR("MathGraph: Arena required for creation.");
        return NULL;
    }
    
    MathGraph* graph = (MathGraph*)arena_alloc_zero(arena, sizeof(MathGraph));
    // memset(graph, 0, sizeof(MathGraph)); // arena_alloc_zero already clears it
    
    // Create Pool: Elements are MathNode size, 256 per block
    graph->node_pool = pool_create(sizeof(MathNode), 256);
    
    // Initial capacity for ID table
    graph->node_capacity = 32; 
    graph->node_ptrs = (MathNode**)calloc(graph->node_capacity, sizeof(MathNode*));
    graph->node_count = 0;

    return graph;
}

void math_graph_destroy(MathGraph* graph) {
    if (!graph) return;
    
    if (graph->node_ptrs) {
        free((void*)graph->node_ptrs);
        graph->node_ptrs = NULL;
    }
    
    if (graph->node_pool) {
        pool_destroy(graph->node_pool);
        graph->node_pool = NULL;
    }
    
    graph->node_count = 0;
    graph->node_capacity = 0;
    // Struct itself is in arena, so we don't free it.
}

// --- Node Management ---

MathNodeId math_graph_add_node(MathGraph* graph, MathNodeType type) {
    if (!graph || !graph->node_pool) return MATH_NODE_INVALID_ID;

    // 1. Ensure ID table capacity
    if (graph->node_count >= graph->node_capacity) {
        uint32_t new_cap = graph->node_capacity * 2;
        if (new_cap == 0) new_cap = 32;
        
        MathNode** new_ptrs = (MathNode**)realloc((void*)graph->node_ptrs, sizeof(MathNode*) * new_cap);
        if (!new_ptrs) {
            LOG_ERROR("MathGraph: Out of memory for ID table!");
            return MATH_NODE_INVALID_ID;
        }
        
        // Zero out new slots
        memset((void*)(new_ptrs + graph->node_capacity), 0, (new_cap - graph->node_capacity) * sizeof(MathNode*));
        
        graph->node_ptrs = new_ptrs;
        graph->node_capacity = new_cap;
        LOG_INFO("MathGraph: Resized ID table to %d", new_cap);
    }

    // 2. Alloc from Pool
    MathNode* node = (MathNode*)pool_alloc(graph->node_pool);
    if (!node) {
        LOG_ERROR("MathGraph: Pool exhausted (System OOM)!");
        return MATH_NODE_INVALID_ID;
    }

    MathNodeId id = graph->node_count++;
    graph->node_ptrs[id] = node;
    
    node->id = id;
    node->type = type;
    node->dirty = true;
    
    // Initialize defaults
    for(int i=0; i<MATH_NODE_MAX_INPUTS; ++i) {
        node->inputs[i] = MATH_NODE_INVALID_ID;
    }
    
    // Set default name
    char buf[32];
    snprintf(buf, 32, "Node_%d", id);
    math_graph_set_name(graph, id, buf);

    return id;
}

void math_graph_set_name(MathGraph* graph, MathNodeId id, const char* name) {
    MathNode* node = math_graph_get_node(graph, id);
    if (!node) return;
    
    if (name) {
        strncpy(node->name, name, 31);
        node->name[31] = '\0';
    } else {
        node->name[0] = '\0';
    }
}

void math_graph_remove_node(MathGraph* graph, MathNodeId id) {
    MathNode* node = math_graph_get_node(graph, id);
    if (!node) return;
    
    // Remove connections TO this node first
    for (uint32_t i = 0; i < graph->node_count; ++i) {
        // Direct pointer access for speed, skipping NULLs
        MathNode* other = graph->node_ptrs[i];
        if (!other || other->type == MATH_NODE_NONE) continue;
        
        for (int k = 0; k < MATH_NODE_MAX_INPUTS; ++k) {
            if (other->inputs[k] == id) {
                other->inputs[k] = MATH_NODE_INVALID_ID;
                other->dirty = true;
            }
        }
    }
    
    // Free memory
    pool_free(graph->node_pool, node);
    graph->node_ptrs[id] = NULL; // Mark as dead
}

void math_graph_clear(MathGraph* graph) {
    if (!graph) return;
    
    // 1. Reset Pool (Recycles all blocks)
    if (graph->node_pool) {
        pool_clear(graph->node_pool);
    }
    
    // 2. Clear ID Map
    if (graph->node_ptrs && graph->node_capacity > 0) {
        memset((void*)graph->node_ptrs, 0, graph->node_capacity * sizeof(MathNode*));
    }
    
    // 3. Reset Counters
    graph->node_count = 0;
}

void math_graph_connect(MathGraph* graph, MathNodeId target_id, int input_index, MathNodeId source_id) {
    if (input_index < 0 || input_index >= MATH_NODE_MAX_INPUTS) return;
    
    MathNode* target = math_graph_get_node(graph, target_id);
    MathNode* source = math_graph_get_node(graph, source_id); // Verify source exists
    
    if (target && source) {
        target->inputs[input_index] = source_id;
        target->dirty = true;
    } else if (target && source_id == MATH_NODE_INVALID_ID) {
        // Disconnect
        target->inputs[input_index] = MATH_NODE_INVALID_ID;
        target->dirty = true;
    }
}

void math_graph_set_value(MathGraph* graph, MathNodeId id, float value) {
    MathNode* node = math_graph_get_node(graph, id);
    if (!node) return;
    
    if (fabsf(node->value - value) > 1e-6f) {
        node->value = value;
        node->dirty = true;
    }
}

// --- Evaluation ---

float math_graph_evaluate(MathGraph* graph, MathNodeId id) {
    MathNode* node = math_graph_get_node(graph, id);
    if (!node) return 0.0f;
    
    // Simple caching could go here, checking dirty flags.
    // For now, let's just evaluate inputs recursively.
    
    float v[MATH_NODE_MAX_INPUTS] = {0};
    for(int i=0; i<MATH_NODE_MAX_INPUTS; ++i) {
        if (node->inputs[i] != MATH_NODE_INVALID_ID) {
            v[i] = math_graph_evaluate(graph, node->inputs[i]);
        }
    }
    
    float result = 0.0f;
    switch (node->type) {
        case MATH_NODE_VALUE: result = node->value; break;
        case MATH_NODE_ADD: result = v[0] + v[1]; break;
        case MATH_NODE_SUB: result = v[0] - v[1]; break;
        case MATH_NODE_MUL: result = v[0] * v[1]; break;
        case MATH_NODE_DIV: result = (v[1] != 0.0f) ? v[0] / v[1] : 0.0f; break;
        case MATH_NODE_SIN: result = sinf(v[0]); break;
        case MATH_NODE_COS: result = cosf(v[0]); break;
        case MATH_NODE_TIME: result = 0.0f; break; // Needs global context
        case MATH_NODE_UV:   result = 0.5f; break; // Needs global context
        default: break;
    }
    
    node->cached_output = result;
    node->dirty = false;
    return result;
}


==================================================
FILE START: src/features/math_engine/math_graph.h
==================================================
#ifndef MATH_GRAPH_H
#define MATH_GRAPH_H

#include "foundation/memory/arena.h"
#include <stdint.h>
#include <stdbool.h>

// --- Types ---

typedef uint32_t MathNodeId;
#define MATH_NODE_INVALID_ID 0xFFFFFFFF

typedef enum MathNodeType {
    MATH_NODE_NONE = 0, // Slot is empty/free
    MATH_NODE_VALUE,
    MATH_NODE_ADD,
    MATH_NODE_SUB,
    MATH_NODE_MUL,
    MATH_NODE_DIV,
    MATH_NODE_SIN,
    MATH_NODE_COS,
    MATH_NODE_TIME, 
    MATH_NODE_UV,   
    MATH_NODE_OUTPUT, 
    MATH_NODE_SURFACE_GRID,
    MATH_NODE_COUNT
} MathNodeType; // REFLECT

#define MATH_NODE_MAX_INPUTS 4
#define MATH_NODE_NAME_MAX 32

// Opaque Handles
typedef struct MathNode MathNode;
typedef struct MathGraph MathGraph;

// --- API ---

// Create a new graph instance.
// Allocates the MathGraph struct from the provided arena.
MathGraph* math_graph_create(MemoryArena* arena);

// Destroy the graph and free internal resources (pool, lookup tables).
// Does NOT free the MathGraph struct itself if it was allocated in an arena.
void math_graph_destroy(MathGraph* graph);

// Create a new node. Returns the ID of the created node.
MathNodeId math_graph_add_node(MathGraph* graph, MathNodeType type);

// Remove a node (marks slot as free).
void math_graph_remove_node(MathGraph* graph, MathNodeId id);

// Remove all nodes.
void math_graph_clear(MathGraph* graph);

// Connect source_node's output to target_node's input_slot.
void math_graph_connect(MathGraph* graph, MathNodeId target, int input_index, MathNodeId source);

// Set local value (for Value nodes).
void math_graph_set_value(MathGraph* graph, MathNodeId id, float value);

// Set node name (allocates string in arena).
void math_graph_set_name(MathGraph* graph, MathNodeId id, const char* name);

// Evaluate a specific node.
float math_graph_evaluate(MathGraph* graph, MathNodeId id);

#endif // MATH_GRAPH_H


==================================================
FILE START: src/foundation/config/config_system.c
==================================================
#include "config_system.h"
#include "foundation/string/string_id.h"
#include "simple_yaml.h"
#include "foundation/memory/arena.h"
#include "foundation/platform/platform.h"
#include "foundation/platform/fs.h"
#include "foundation/logger/logger.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

static struct {
    MemoryArena arena;
    ConfigNode* yaml_root;
    ConfigNode* cli_root;
    bool initialized;
} g_config;

void config_system_init(void) {
    if (g_config.initialized) return;
    arena_init(&g_config.arena, 1024 * 1024); // 1MB for config
    g_config.initialized = true;
    g_config.yaml_root = NULL;
    g_config.cli_root = NULL;
}

void config_system_shutdown(void) {
    if (!g_config.initialized) return;
    arena_destroy(&g_config.arena);
    g_config.initialized = false;
    g_config.yaml_root = NULL;
    g_config.cli_root = NULL;
}

static ConfigNode* config_node_create_map(void) {
    ConfigNode* node = arena_alloc_zero(&g_config.arena, sizeof(ConfigNode));
    node->type = CONFIG_NODE_MAP;
    return node;
}

static void config_node_add_scalar(ConfigNode* map, const char* key, const char* value) {
    if (map->type != CONFIG_NODE_MAP) return;
    
    // Resize pairs if needed
    if (map->pair_count + 1 > map->pair_capacity) {
        size_t new_cap = map->pair_capacity == 0 ? 4 : map->pair_capacity * 2;
        ConfigPair* new_pairs = arena_alloc(&g_config.arena, new_cap * sizeof(ConfigPair));
        if (map->pairs) {
            memcpy(new_pairs, map->pairs, map->pair_count * sizeof(ConfigPair));
        }
        map->pairs = new_pairs;
        map->pair_capacity = new_cap;
    }

    // Copy key and value to arena
    size_t key_len = strlen(key);
    char* key_copy = arena_alloc(&g_config.arena, key_len + 1);
    memcpy(key_copy, key, key_len + 1);

    size_t val_len = strlen(value);
    char* val_copy = arena_alloc(&g_config.arena, val_len + 1);
    memcpy(val_copy, value, val_len + 1);


    ConfigNode* val_node = arena_alloc_zero(&g_config.arena, sizeof(ConfigNode));
    val_node->type = CONFIG_NODE_SCALAR;
    val_node->scalar = val_copy;

    map->pairs[map->pair_count].key = key_copy;
    map->pairs[map->pair_count].value = val_node;
    map->pair_count++;
}

static const ConfigNode* find_node_recursive(const ConfigNode* root, const char* key) {
    if (!root || root->type != CONFIG_NODE_MAP) return NULL;
    
    // Check for dot notation
    const char* dot = strchr(key, '.');
    if (dot) {
        // Split key: "window.width" -> "window" + "width"
        size_t head_len = (size_t)(dot - key);
        char head[128];
        if (head_len >= sizeof(head)) head_len = sizeof(head) - 1;
        strncpy(head, key, head_len);
        head[head_len] = 0;

        const ConfigNode* child = config_node_map_get(root, head);
        return find_node_recursive(child, dot + 1);
    } else {
        return config_node_map_get(root, key);
    }
}

void config_system_load(int argc, char** argv) {
    if (!g_config.initialized) config_system_init();

    // 1. Create CLI root
    g_config.cli_root = config_node_create_map();

    // 2. Parse CLI args
    const char* config_path = "config.yaml"; // Default

    for (int i = 1; i < argc; ++i) {
        const char* arg = argv[i];
        if (arg[0] == '-' && arg[1] == '-') {
            const char* key_start = arg + 2;
            const char* eq = strchr(key_start, '=');
            
            if (strcmp(key_start, "config") == 0 && i + 1 < argc) {
                config_path = argv[++i];
                continue;
            }
            if (strncmp(key_start, "config=", 7) == 0) {
                config_path = eq + 1;
                continue;
            }

            char key[128];
            const char* val = NULL;

            if (eq) {
                // --key=value
                size_t klen = (size_t)(eq - key_start);
                if (klen >= sizeof(key)) klen = sizeof(key) - 1;
                strncpy(key, key_start, klen);
                key[klen] = 0;
                val = eq + 1;
            } else {
                // --key value OR --flag
                strncpy(key, key_start, sizeof(key) - 1);
                
                // Check if next arg is a value or another flag
                if (i + 1 < argc && argv[i+1][0] != '-') {
                    val = argv[++i];
                } else {
                    val = "true";
                }
            }
            
            // Normalize key: replace '-' with '_' if needed? 
            // main.c uses --log-level, but struct has log_level.
            // Let's replace '-' with '_' to match struct fields common practice?
            // User provided "log-level", key becomes "log_level".
            for(int k=0; key[k]; ++k) {
                if(key[k] == '-') key[k] = '_';
            }

            config_node_add_scalar(g_config.cli_root, key, val);
        }
    }

    // 3. Load YAML file
    char* file_content = fs_read_text(NULL, config_path);
    if (file_content) {
        ConfigError err;
        if (!simple_yaml_parse(&g_config.arena, file_content, &g_config.yaml_root, &err)) {
            LOG_WARN("Failed to parse config file '%s': Line %d: %s", config_path, err.line, err.message);
        } else {
            LOG_INFO("Loaded config from '%s'", config_path);
        }
        free(file_content); // platform_read_file uses malloc
    } else {
        // It's okay if config file doesn't exist, unless explicitly requested?
        // For now, silent fail on default, maybe warn if custom path?
        if (strcmp(config_path, "config.yaml") != 0) {
            LOG_WARN("Config file '%s' not found.", config_path);
        }
    }
}

static const char* get_value_raw(const char* key) {
    if (!g_config.initialized) return NULL;
    
    // 1. CLI Override
    const ConfigNode* node = find_node_recursive(g_config.cli_root, key);
    if (node && node->type == CONFIG_NODE_SCALAR) return node->scalar;

    // 2. YAML Config
    node = find_node_recursive(g_config.yaml_root, key);
    if (node && node->type == CONFIG_NODE_SCALAR) return node->scalar;

    return NULL;
}

const char* config_get_string(const char* key, const char* default_value) {
    const char* val = get_value_raw(key);
    return val ? val : default_value;
}

int config_get_int(const char* key, int default_value) {
    const char* val = get_value_raw(key);
    if (!val) return default_value;
    return atoi(val);
}

float config_get_float(const char* key, float default_value) {
    const char* val = get_value_raw(key);
    if (!val) return default_value;
    return (float)atof(val);
}

bool config_get_bool(const char* key, bool default_value) {
    const char* val = get_value_raw(key);
    if (!val) return default_value;
    if (strcmp(val, "true") == 0 || strcmp(val, "1") == 0 || strcmp(val, "yes") == 0) return true;
    if (strcmp(val, "false") == 0 || strcmp(val, "0") == 0 || strcmp(val, "no") == 0) return false;
    return default_value;
}

// --- Generic Deserializer Implementation ---

bool config_load_struct_array(const ConfigNode* node, const MetaStruct* meta, void*** out_array, size_t* out_count, MemoryArena* arena) {
    if (!node || node->type != CONFIG_NODE_SEQUENCE || !meta || !out_array || !out_count || !arena) return false;

    size_t count = node->item_count;
    *out_count = count;
    
    if (count == 0) {
        *out_array = NULL;
        return true;
    }

    // Allocate array of pointers
    void** array = (void**)arena_alloc(arena, count * sizeof(void*));
    *out_array = array;

    for (size_t i = 0; i < count; ++i) {
        ConfigNode* item_node = node->items[i];
        if (item_node->type != CONFIG_NODE_MAP) {
             array[i] = NULL;
             continue;
        }

        // Allocate struct instance
        void* instance = arena_alloc_zero(arena, meta->size);
        array[i] = instance;

        // Recursive load
        config_load_struct(item_node, meta, instance, arena);
    }
    return true;
}

bool config_load_struct(const ConfigNode* node, const MetaStruct* meta, void* instance, MemoryArena* arena) {
    if (!node || node->type != CONFIG_NODE_MAP || !meta || !instance || !arena) return false;

    for (size_t i = 0; i < node->pair_count; ++i) {
        const char* key = node->pairs[i].key;
        const ConfigNode* child = node->pairs[i].value;
        
        if (!key || !child) continue;

        const MetaField* field = meta_find_field(meta, key);
        if (!field) {
            LOG_WARN("Config: Unknown field '%s' in struct '%s'", key, meta->name);
            continue;
        }

        switch (field->type) {
            case META_TYPE_INT:
                if (child->type == CONFIG_NODE_SCALAR) {
                    meta_set_int(instance, field, atoi(child->scalar));
                }
                break;
            case META_TYPE_FLOAT:
                if (child->type == CONFIG_NODE_SCALAR) {
                    meta_set_float(instance, field, (float)atof(child->scalar));
                }
                break;
            case META_TYPE_BOOL:
                if (child->type == CONFIG_NODE_SCALAR) {
                    bool val = (strcmp(child->scalar, "true") == 0 || strcmp(child->scalar, "yes") == 0 || strcmp(child->scalar, "1") == 0);
                    meta_set_bool(instance, field, val);
                }
                break;
            case META_TYPE_STRING:
                if (child->type == CONFIG_NODE_SCALAR) {
                    size_t len = strlen(child->scalar);
                    char* copy = arena_alloc(arena, len + 1);
                    memcpy(copy, child->scalar, len + 1);
                    
                    char** ptr = (char**)meta_get_field_ptr(instance, field);
                    *ptr = copy;
                }
                break;
            case META_TYPE_STRING_ARRAY:
                if (child->type == CONFIG_NODE_SCALAR) {
                    char* ptr = (char*)meta_get_field_ptr(instance, field);
                    strncpy(ptr, child->scalar, 255);
                    ptr[255] = 0;
                }
                break;
            case META_TYPE_STRING_ID:
                if (child->type == CONFIG_NODE_SCALAR) {
                    StringId id = str_id(child->scalar);
                    *(StringId*)meta_get_field_ptr(instance, field) = id;
                }
                break;
            case META_TYPE_ENUM:
                if (child->type == CONFIG_NODE_SCALAR) {
                    const MetaEnum* e = meta_get_enum(field->type_name);
                    int val = 0;
                    if (e && meta_enum_get_value(e, child->scalar, &val)) {
                        meta_set_int(instance, field, val);
                    }
                }
                break;
            case META_TYPE_FLAGS:
                if (child->type == CONFIG_NODE_SCALAR) {
                    meta_set_from_string(instance, field, child->scalar);
                }
                break;
            case META_TYPE_VEC2:
            case META_TYPE_VEC3:
            case META_TYPE_VEC4: {
                if (child->type == CONFIG_NODE_SCALAR) {
                    meta_set_from_string(instance, field, child->scalar);
                } else if (child->type == CONFIG_NODE_SEQUENCE) {
                    int vec_size = field->type - META_TYPE_VEC2 + 2;
                    float* ptr = (float*)meta_get_field_ptr(instance, field);
                    for(int k=0; k < vec_size; ++k) {
                        float v = 0.0f;
                        if (k < (int)child->item_count && child->items[k]->scalar) {
                             v = (float)atof(child->items[k]->scalar);
                        } else if (k == 3) {
                             v = 1.0f; // Alpha
                        }
                        ptr[k] = v;
                    }
                }
                break;
            }
            case META_TYPE_STRUCT:
                if (child->type == CONFIG_NODE_MAP) {
                    const MetaStruct* s = meta_get_struct(field->type_name);
                    void* sub_inst = meta_get_field_ptr(instance, field);
                    if (s && sub_inst) {
                        config_load_struct(child, s, sub_inst, arena);
                    }
                }
                break;
            case META_TYPE_POINTER_ARRAY:
                if (child->type == CONFIG_NODE_SEQUENCE) {
                    const MetaStruct* elem_meta = meta_get_struct(field->type_name);
                    if (!elem_meta) continue;

                    void** array_out = NULL;
                    size_t count = 0;

                    if (config_load_struct_array(child, elem_meta, &array_out, &count, arena)) {
                        // Set array
                        void*** ptr_to_array = (void***)meta_get_field_ptr(instance, field);
                        *ptr_to_array = array_out;

                        // Set count (Heuristic)
                        char count_name[512];
                        snprintf(count_name, sizeof(count_name), "%.400s_count", field->name);
                        const MetaField* count_field = meta_find_field(meta, count_name);
                        
                        // Fallback: "children" -> "child_count"
                        if (!count_field) {
                            size_t name_len = strlen(field->name);
                            if (name_len > 1 && field->name[name_len-1] == 's') {
                                char singular[256];
                                if (name_len < sizeof(singular)) {
                                    strncpy(singular, field->name, name_len - 1);
                                    singular[name_len - 1] = 0;
                                    snprintf(count_name, sizeof(count_name), "%s_count", singular);
                                    count_field = meta_find_field(meta, count_name);
                                }
                            }
                        }
                        
                        if (!count_field && strcmp(field->name, "children") == 0) {
                             count_field = meta_find_field(meta, "child_count");
                        }

                        if (count_field && count_field->type == META_TYPE_INT) {
                            meta_set_int(instance, count_field, (int)count);
                        }
                    }
                }
                break;
            case META_TYPE_POINTER:
                 if (child->type == CONFIG_NODE_MAP) {
                    const MetaStruct* s = meta_get_struct(field->type_name);
                    if (s) {
                        void* sub_inst = arena_alloc_zero(arena, s->size);
                         if (config_load_struct(child, s, sub_inst, arena)) {
                             void** ptr = (void**)meta_get_field_ptr(instance, field);
                             *ptr = sub_inst;
                         }
                    }
                }
                break;
        }
    }
    return true;
}


==================================================
FILE START: src/foundation/config/config_system.h
==================================================
#ifndef CONFIG_SYSTEM_H
#define CONFIG_SYSTEM_H

#include <stdbool.h>

// Initialize the global config system
void config_system_init(void);

// Shutdown the config system and free resources
void config_system_shutdown(void);

// Load configuration from CLI arguments and optional config file
// 1. Scans args for --config <path>
// 2. Loads YAML from path (or "config.yaml" default)
// 3. Parses all other args as overrides (--key value or --key=value)
void config_system_load(int argc, char** argv);

// Get a string value. Returns default_value if not found.
const char* config_get_string(const char* key, const char* default_value);

// Get an integer value. Returns default_value if not found.
int config_get_int(const char* key, int default_value);

// Get a float value. Returns default_value if not found.
float config_get_float(const char* key, float default_value);

// Get a boolean value. Returns default_value if not found.
bool config_get_bool(const char* key, bool default_value);

// --- Generic Deserializer ---

#include "../meta/reflection.h"

typedef struct ConfigNode ConfigNode;
typedef struct MemoryArena MemoryArena;

// Deserializes a YAML node into a C struct using reflection.
// - node: The YAML node (must be CONFIG_NODE_MAP for structs).
// - meta: The reflection metadata for the target struct.
// - instance: Pointer to the struct instance to fill.
// - arena: Arena for allocating strings and arrays.
bool config_load_struct(const ConfigNode* node, const MetaStruct* meta, void* instance, MemoryArena* arena);

// Deserializes a YAML sequence into an array of pointers to structs.
// - node: The YAML node (must be CONFIG_NODE_SEQUENCE).
// - meta: The reflection metadata for the element type.
// - out_array: Output pointer to the array of pointers (e.g. Node***).
// - out_count: Output pointer to the element count.
// - arena: Arena for allocating the array and elements.
bool config_load_struct_array(const ConfigNode* node, const MetaStruct* meta, void*** out_array, size_t* out_count, MemoryArena* arena);

#endif // CONFIG_SYSTEM_H


==================================================
FILE START: src/foundation/config/config_types.c
==================================================
#include "config_types.h"
#include <string.h>

const ConfigNode *config_node_map_get(const ConfigNode *map, const char *key)
{
    if (!map || map->type != CONFIG_NODE_MAP) return NULL;
    for (size_t i = 0; i < map->pair_count; ++i) {
        if (map->pairs[i].key && strcmp(map->pairs[i].key, key) == 0) return map->pairs[i].value;
    }
    return NULL;
}

void config_node_free(ConfigNode *node)
{
    // No-op: Memory is managed by the Arena
    (void)node;
}


==================================================
FILE START: src/foundation/config/config_types.h
==================================================
#ifndef CONFIG_TYPES_H
#define CONFIG_TYPES_H

#include <stddef.h>

// Forward Declarations
typedef struct MemoryArena MemoryArena;

typedef enum ConfigNodeType {
    CONFIG_NODE_UNKNOWN,
    CONFIG_NODE_SCALAR,
    CONFIG_NODE_MAP,
    CONFIG_NODE_SEQUENCE,
} ConfigNodeType;

typedef struct ConfigNode ConfigNode;

typedef struct ConfigPair {
    char *key;
    ConfigNode *value;
} ConfigPair;

struct ConfigNode {
    ConfigNodeType type;
    int line;
    char *scalar;
    ConfigPair *pairs;
    size_t pair_count;
    size_t pair_capacity;
    ConfigNode **items;
    size_t item_count;
    size_t item_capacity;
};

typedef struct ConfigError {
    int line;
    int column;
    char message[128];
} ConfigError;

// Generic tree traversal
const ConfigNode *config_node_map_get(const ConfigNode *map, const char *key);

void config_node_free(ConfigNode *node);

#endif // CONFIG_TYPES_H


==================================================
FILE START: src/foundation/config/simple_yaml.c
==================================================
#include "simple_yaml.h"
#include "foundation/platform/platform.h"
#include "foundation/memory/arena.h"

#include <ctype.h>
#include <string.h>

typedef struct {
    int indent;
    ConfigNode *node;
} SimpleYamlContext;

static void set_error(ConfigError *err, int line, int column, const char *msg)
{
    if (!err) return;
    err->line = line;
    err->column = column;
    platform_strncpy(err->message, msg, sizeof(err->message) - 1);
    err->message[sizeof(err->message) - 1] = 0;
}

static char *dup_range(MemoryArena* arena, const char *begin, const char *end)
{
    size_t len = (size_t)(end - begin);
    char *out = (char *)arena_alloc(arena, len + 1);
    if (!out) return NULL;
    memcpy(out, begin, len);
    out[len] = 0;
    return out;
}

static ConfigNode *yaml_node_new(MemoryArena* arena, ConfigNodeType type, int line)
{
    ConfigNode *n = (ConfigNode *)arena_alloc_zero(arena, sizeof(ConfigNode));
    if (!n) return NULL;
    n->type = type;
    n->line = line;
    return n;
}

static int yaml_pair_append(MemoryArena* arena, ConfigNode *map, char *key, ConfigNode *value)
{
    if (map->pair_count + 1 > map->pair_capacity) {
        size_t new_cap = map->pair_capacity == 0 ? 4 : map->pair_capacity * 2;
        ConfigPair *new_pairs = (ConfigPair *)arena_alloc(arena, new_cap * sizeof(ConfigPair));
        if (!new_pairs) return 0;
        
        if (map->pairs) {
            memcpy(new_pairs, map->pairs, map->pair_count * sizeof(ConfigPair));
        }
        
        map->pairs = new_pairs;
        map->pair_capacity = new_cap;
    }
    // We take ownership of key (allocated in arena)
    map->pairs[map->pair_count].key = key; 
    map->pairs[map->pair_count].value = value;
    map->pair_count++;
    return 1;
}

static int yaml_sequence_append(MemoryArena* arena, ConfigNode *seq, ConfigNode *value)
{
    if (seq->item_count + 1 > seq->item_capacity) {
        size_t new_cap = seq->item_capacity == 0 ? 4 : seq->item_capacity * 2;
        ConfigNode **new_items = (ConfigNode **)arena_alloc(arena, new_cap * sizeof(ConfigNode *));
        if (!new_items) return 0;
        
        if (seq->items) {
            memcpy((void*)new_items, (const void*)seq->items, seq->item_count * sizeof(ConfigNode *));
        }
        
        seq->items = new_items;
        seq->item_capacity = new_cap;
    }
    seq->items[seq->item_count++] = value;
    return 1;
}

static const char *trim_left(const char *s)
{
    while (*s && isspace((unsigned char)*s)) ++s;
    return s;
}

static void rstrip(char *s)
{
    size_t len = strlen(s);
    while (len > 0 && isspace((unsigned char)s[len - 1])) {
        s[--len] = 0;
    }
}

static int parse_scalar_value(MemoryArena* arena, const char *raw, char **out_value)
{
    const char *start = trim_left(raw);
    size_t len = strlen(start);
    if (len >= 2 && ((start[0] == '"' && start[len - 1] == '"') || (start[0] == '\'' && start[len - 1] == '\''))) {
        start++;
        len -= 2;
    }
    *out_value = dup_range(arena, start, start + len);
    return *out_value != NULL;
}

int simple_yaml_parse(MemoryArena* arena, const char *text, ConfigNode **out_root, ConfigError *err)
{
    if (!arena || !text) return 0;

    ConfigNode *root = yaml_node_new(arena, CONFIG_NODE_MAP, 1);
    if (!root) return 0;

    SimpleYamlContext stack[128];
    size_t depth = 0;
    stack[depth++] = (SimpleYamlContext){-1, root};

    int line_number = 0;
    const char *cursor = text;
    while (*cursor) {
        const char *line_start = cursor;
        while (*cursor && *cursor != '\n' && *cursor != '\r') ++cursor;
        size_t line_len = (size_t)(cursor - line_start);
        
        // Use arena for line buffer (temporary, but arena is scratch so it's fine)
        char *line = (char *)arena_alloc(arena, line_len + 1);
        if (!line) {
            return 0;
        }
        memcpy(line, line_start, line_len);
        line[line_len] = 0;
        if (*cursor == '\r' && *(cursor + 1) == '\n') cursor += 2; else if (*cursor) ++cursor;

        line_number++;
        
        // Handle comments, respecting quotes
        char *c = line;
        int in_quote = 0; // 0=none, 1=', 2="
        while (*c) {
            if (*c == '\'' && in_quote != 2) in_quote = (in_quote == 1) ? 0 : 1;
            else if (*c == '"' && in_quote != 1) in_quote = (in_quote == 2) ? 0 : 2;
            else if (*c == '#' && in_quote == 0) {
                *c = 0; // Terminate at comment start
                break;
            }
            c++;
        }
        rstrip(line);

        const char *p = line;
        int indent = 0;
        while (*p == ' ') {
            ++indent;
            ++p;
        }

        p = trim_left(p);
        if (*p == 0) {
            continue;
        }

        while (depth > 0 && indent <= stack[depth - 1].indent) {
            depth--;
        }
        if (depth == 0) {
            set_error(err, line_number, 1, "Invalid indentation");
            return 0;
        }

        ConfigNode *parent = stack[depth - 1].node;
        if (parent->type == CONFIG_NODE_UNKNOWN) {
            parent->type = (*p == '-') ? CONFIG_NODE_SEQUENCE : CONFIG_NODE_MAP;
        }

        if (*p == '-') {
            p = trim_left(p + 1);
            if (parent->type != CONFIG_NODE_SEQUENCE) {
                set_error(err, line_number, indent + 1, "Sequence item in non-sequence");
                return 0;
            }

            ConfigNode *item = yaml_node_new(arena, CONFIG_NODE_UNKNOWN, line_number);
            if (!item || !yaml_sequence_append(arena, parent, item)) {
                return 0;
            }

            char *colon = strchr(p, ':');
            if (colon) {
                item->type = CONFIG_NODE_MAP;
                const char *key_start = p;
                const char *key_end = colon;
                while (key_end > key_start && isspace((unsigned char)*(key_end - 1))) --key_end;
                
                char *key = dup_range(arena, key_start, key_end);
                char *value_text = NULL;
                const char *value_start = colon + 1;
                
                stack[depth++] = (SimpleYamlContext){indent, item};

                if (*value_start) {
                    if (!parse_scalar_value(arena, value_start, &value_text)) {
                        return 0;
                    }
                    ConfigNode *scalar_node = yaml_node_new(arena, CONFIG_NODE_SCALAR, line_number);
                    scalar_node->scalar = value_text;
                    yaml_pair_append(arena, item, key, scalar_node);
                } else {
                    ConfigNode *child = yaml_node_new(arena, CONFIG_NODE_UNKNOWN, line_number);
                    yaml_pair_append(arena, item, key, child);
                    
                    int key_indent = (int)(key_start - line);
                    stack[depth++] = (SimpleYamlContext){key_indent, child};
                }
            } else if (*p) {
                char *value_text = NULL;
                if (parse_scalar_value(arena, p, &value_text)) {
                    item->type = CONFIG_NODE_SCALAR;
                    item->scalar = value_text;
                }
                stack[depth++] = (SimpleYamlContext){indent, item};
            } else {
                stack[depth++] = (SimpleYamlContext){indent, item};
            }
        } else {
            if (parent->type != CONFIG_NODE_MAP) {
                set_error(err, line_number, indent + 1, "Mapping entry in non-map");
                return 0;
            }

            char *colon = strchr(p, ':');
            if (!colon) {
                set_error(err, line_number, indent + 1, "Missing ':' in mapping entry");
                return 0;
            }
            const char *key_start = p;
            const char *key_end = colon;
            while (key_end > key_start && isspace((unsigned char)*(key_end - 1))) --key_end;
            
            char *key = dup_range(arena, key_start, key_end);
            const char *value_start = colon + 1;

            char *value_text = NULL;
            if (*value_start) {
                if (!parse_scalar_value(arena, value_start, &value_text)) {
                    return 0;
                }
                ConfigNode *scalar = yaml_node_new(arena, CONFIG_NODE_SCALAR, line_number);
                scalar->scalar = value_text;
                yaml_pair_append(arena, parent, key, scalar);
                stack[depth++] = (SimpleYamlContext){indent, scalar};
            } else {
                ConfigNode *child = yaml_node_new(arena, CONFIG_NODE_UNKNOWN, line_number);
                yaml_pair_append(arena, parent, key, child);
                stack[depth++] = (SimpleYamlContext){indent, child};
            }
        }
    }

    *out_root = root;
    return 1;
}


==================================================
FILE START: src/foundation/config/simple_yaml.h
==================================================
#ifndef SIMPLE_YAML_H
#define SIMPLE_YAML_H

#include "config_types.h"

// Parser specifically for YAML, produces a generic ConfigNode tree
int simple_yaml_parse(MemoryArena* arena, const char *text, ConfigNode **out_root, ConfigError *err);

#endif // SIMPLE_YAML_H


==================================================
FILE START: src/foundation/image/image.c
==================================================
#include "image.h"
#include "foundation/logger/logger.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image_write.h"

bool image_write_png(const char* path, int width, int height, int channels, const void* data, int stride_bytes) {
    if (!path || !data) return false;
    
    // stbi_write_png returns 0 on failure, non-zero on success
    int res = stbi_write_png(path, width, height, channels, data, stride_bytes);
    
    if (res == 0) {
        LOG_ERROR("Failed to write PNG to %s", path);
        return false;
    }
    
    return true;
}

void image_swizzle_bgra_to_rgba(uint8_t* data, int pixel_count) {
    if (!data) return;
    for (int i = 0; i < pixel_count; i++) {
        uint8_t b = data[i * 4 + 0];
        uint8_t r = data[i * 4 + 2];
        data[i * 4 + 0] = r;
        data[i * 4 + 2] = b;
    }
}


==================================================
FILE START: src/foundation/image/image.h
==================================================
#ifndef FOUNDATION_IMAGE_H
#define FOUNDATION_IMAGE_H

#include <stdbool.h>
#include <stdint.h>

/**
 * @brief Writes raw image data to a PNG file.
 * 
 * @param path The output file path.
 * @param width Image width in pixels.
 * @param height Image height in pixels.
 * @param channels Number of channels (1=Grey, 3=RGB, 4=RGBA).
 * @param data Pointer to the raw image data.
 * @param stride_bytes Row stride in bytes. 0 for tightly packed (width * channels).
 * @return true if successful, false otherwise.
 */
bool image_write_png(const char* path, int width, int height, int channels, const void* data, int stride_bytes);

/**
 * @brief Swizzles BGRA data to RGBA in place.
 * 
 * @param data Pointer to the raw image data (4 channels per pixel assumed).
 * @param pixel_count Total number of pixels to process.
 */
void image_swizzle_bgra_to_rgba(uint8_t* data, int pixel_count);

#endif // FOUNDATION_IMAGE_H


==================================================
FILE START: src/foundation/logger/logger.c
==================================================
#if !defined(_WIN32) && !defined(_POSIX_C_SOURCE)
#define _POSIX_C_SOURCE 200809L // NOLINT: For localtime_r on Linux
#endif

#include "logger.h"
#include "foundation/thread/thread.h"
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <stdarg.h>
#include <stdbool.h>

#ifdef _WIN32
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include <direct.h>
    
    static void safe_localtime(const time_t* timep, struct tm* result) {
        localtime_s(result, timep);
    }

    static void safe_mkdir(const char* path) {
        _mkdir(path);
    }
#else
    #include <sys/stat.h>
    #include <sys/types.h> // NOLINT

    static void safe_localtime(const time_t* timep, struct tm* result) {
        localtime_r(timep, result);
    }

    static void safe_mkdir(const char* path) {
        mkdir(path, 0755);
    }
#endif

static Mutex* g_log_lock = NULL;

static void lock_mutex(void) { 
    if (g_log_lock) mutex_lock(g_log_lock); 
}

static void unlock_mutex(void) { 
    if (g_log_lock) mutex_unlock(g_log_lock); 
}

static LogLevel g_console_level = LOG_LEVEL_INFO;
static LogLevel g_file_level = LOG_LEVEL_TRACE;

static FILE* g_log_file = NULL;
static bool g_initialized = false;

static const char* level_strings[] = {
    "TRACE", "DEBUG", "INFO ", "WARN ", "ERROR", "FATAL"
};

// ANSI colors are supported in Win10/11 console now, but we might want to strip them for file
static const char* level_colors[] = {
    "\033[90m", // TRACE - Gray
    "\033[36m", // DEBUG - Cyan
    "\033[32m", // INFO  - Green
    "\033[33m", // WARN  - Yellow
    "\033[31m", // ERROR - Red
    "\033[41m"  // FATAL - Red Background
};

static const char* reset_color = "\033[0m";

static void create_dir_if_needed(const char* path) {
    char temp[256];
    char* p = NULL;
    size_t len;

    if (!path) return;
    
    // Copy path to temp
    len = strlen(path);
    if (len >= sizeof(temp)) return; // Too long
    snprintf(temp, sizeof(temp), "%s", path);
    // temp is already null-terminated by snprintf

    // Remove file name
    p = strrchr(temp, '/');
    if (!p) p = strrchr(temp, '\\'); // Check both separators
    if (p) {
        *p = 0; // Truncate to directory
    } else {
        return; // No directory part
    }

    // Attempt create
    safe_mkdir(temp);
}

void logger_init(const char* log_file_path) {
    // Note: We assume logger_init is called from the main thread at startup.
    // If we wanted to be strictly thread-safe here, we'd need a spinlock or atomic check,
    // but Mutex creation itself needs to happen once.
    if (g_initialized) {
        return;
    }
    
    g_log_lock = mutex_create();

    lock_mutex();

    if (log_file_path) {
        create_dir_if_needed(log_file_path);
        g_log_file = fopen(log_file_path, "w");
        if (!g_log_file) {
            fprintf(stderr, "Logger: Failed to open log file '%s'\n", log_file_path);
        }
    }

    g_initialized = true;
    unlock_mutex();
}

void logger_shutdown(void) {
    lock_mutex();
    if (g_log_file) {
        fclose(g_log_file);
        g_log_file = NULL;
    }
    g_initialized = false;
    unlock_mutex();
    
    mutex_destroy(g_log_lock);
    g_log_lock = NULL;
}

void logger_set_console_level(LogLevel level) {
    g_console_level = level;
}

void logger_set_file_level(LogLevel level) {
    g_file_level = level;
}

LogLevel logger_get_level(void) {
    return g_console_level;
}

static double g_trace_interval = 5.0; // Default 5s

void logger_set_trace_interval(double seconds) {
    g_trace_interval = seconds;
}

double logger_get_trace_interval(void) {
    return g_trace_interval;
}

void logger_log(LogLevel level, const char* file, int line, const char* fmt, ...) {
    // Quick check before lock (optimization)
    // Note: Technically racy but harmless for logging levels
    if (level < g_console_level && level < g_file_level) {
        return;
    }

    // Get time
    time_t now = time(NULL);
    struct tm t;
    safe_localtime(&now, &t);
    
    char time_short[16];
    char time_long[32];
    strftime(time_short, sizeof(time_short), "%H:%M:%S", &t);
    strftime(time_long, sizeof(time_long), "%Y-%m-%d %H:%M:%S", &t);

    // Simplify file path
    const char* short_file = strrchr(file, '/');
    if (!short_file) short_file = strrchr(file, '\\'); // Win path support
    
    if (short_file) {
        short_file++; 
    } else {
        short_file = file; 
    }

    lock_mutex();

    // Console Output
    if (level >= g_console_level) {
        FILE* out = (level >= LOG_LEVEL_ERROR) ? stderr : stdout;
        fprintf(out, "%s[%s] [%s]%s %s:%d: ", 
            level_colors[level], 
            time_short, 
            level_strings[level],
            reset_color, 
            short_file, 
            line);
        
        va_list args;
        va_start(args, fmt);
        vfprintf(out, fmt, args);
        va_end(args);
        fprintf(out, "\n");
        fflush(out); // Ensure console is snappy
    }

    // File Output
    if (g_log_file && level >= g_file_level) {
        fprintf(g_log_file, "[%s] [%s] %s:%d: ", 
            time_long, 
            level_strings[level], 
            short_file, 
            line);
        
        va_list args;
        va_start(args, fmt);
        vfprintf(g_log_file, fmt, args);
        va_end(args);
        fprintf(g_log_file, "\n");
        fflush(g_log_file); // Flush file to ensure logs are saved on crash
    }

    unlock_mutex();

    if (level == LOG_LEVEL_FATAL) {
        logger_shutdown(); // Close file properly
        exit(1);
    }
}


==================================================
FILE START: src/foundation/logger/logger.h
==================================================
#ifndef LOGGER_H
#define LOGGER_H

typedef enum LogLevel {
    LOG_LEVEL_TRACE, // Ultra-verbose, per-frame, variable tracing
    LOG_LEVEL_DEBUG, // Diagnostic information for developers
    LOG_LEVEL_INFO,  // Significant events (init, state changes)
    LOG_LEVEL_WARN,  // Potential issues that don't stop execution
    LOG_LEVEL_ERROR, // Errors that might impact functionality
    LOG_LEVEL_FATAL  // Critical errors causing shutdown
} LogLevel;

// Lifecycle
void logger_init(const char* log_file_path);
void logger_shutdown(void);

// Configuration
void logger_set_console_level(LogLevel level);
void logger_set_file_level(LogLevel level);
void logger_set_trace_interval(double seconds);
double logger_get_trace_interval(void);

LogLevel logger_get_level(void); // Gets Console Level

// Core logging function
void logger_log(LogLevel level, const char* file, int line, const char* fmt, ...);

// Macros for convenience
#define LOG_TRACE(...) logger_log(LOG_LEVEL_TRACE, __FILE__, __LINE__, __VA_ARGS__)
#define LOG_DEBUG(...) logger_log(LOG_LEVEL_DEBUG, __FILE__, __LINE__, __VA_ARGS__)
#define LOG_INFO(...)  logger_log(LOG_LEVEL_INFO,  __FILE__, __LINE__, __VA_ARGS__)
#define LOG_WARN(...)  logger_log(LOG_LEVEL_WARN,  __FILE__, __LINE__, __VA_ARGS__)
#define LOG_ERROR(...) logger_log(LOG_LEVEL_ERROR, __FILE__, __LINE__, __VA_ARGS__)
#define LOG_FATAL(...) logger_log(LOG_LEVEL_FATAL, __FILE__, __LINE__, __VA_ARGS__)

#endif // LOGGER_H


==================================================
FILE START: src/foundation/math/coordinate_systems.c
==================================================
#include "coordinate_systems.h"

#include <math.h>
#include <string.h>

static Mat4 mat4_rotation_z(float radians)
{
    float c = cosf(radians);
    float s = sinf(radians);
    Mat4 m = mat4_identity();
    m.m[0] = c;
    m.m[1] = s;
    m.m[4] = -s;
    m.m[5] = c;
    return m;
}

void transform2d_build_matrices(const Transform2D *transform, Mat4 *local_to_world, Mat4 *world_to_local)
{
    Transform2D safe = *transform;
    if (safe.scale.x == 0.0f) safe.scale.x = 1.0f;
    if (safe.scale.y == 0.0f) safe.scale.y = 1.0f;

    Mat4 t = mat4_translation((Vec3){safe.translation.x, safe.translation.y, 0.0f});
    Mat4 r = mat4_rotation_z(safe.rotation_radians);
    Mat4 s = mat4_scale((Vec3){safe.scale.x, safe.scale.y, 1.0f});

    Mat4 rs = mat4_multiply(&r, &s);
    Mat4 trs = mat4_multiply(&t, &rs);
    if (local_to_world) *local_to_world = trs;

    Mat4 inv_s = mat4_scale((Vec3){1.0f / safe.scale.x, 1.0f / safe.scale.y, 1.0f});
    Mat4 inv_r = mat4_rotation_z(-safe.rotation_radians);
    Mat4 inv_t = mat4_translation((Vec3){-safe.translation.x, -safe.translation.y, 0.0f});
    Mat4 inv_rt = mat4_multiply(&inv_r, &inv_t);
    Mat4 inv = mat4_multiply(&inv_s, &inv_rt);
    if (world_to_local) *world_to_local = inv;
}

void transform3d_build_matrices(const Transform3D *transform, Mat4 *local_to_world, Mat4 *world_to_local)
{
    Transform3D safe = *transform;
    if (safe.scale.x == 0.0f) safe.scale.x = 1.0f;
    if (safe.scale.y == 0.0f) safe.scale.y = 1.0f;
    if (safe.scale.z == 0.0f) safe.scale.z = 1.0f;

    Mat4 t = mat4_translation(safe.translation);
    Mat4 r = mat4_rotation_quat(safe.rotation);
    Mat4 s = mat4_scale(safe.scale);

    Mat4 rs = mat4_multiply(&r, &s);
    Mat4 trs = mat4_multiply(&t, &rs);
    if (local_to_world) *local_to_world = trs;

    Mat4 inv_s = mat4_scale((Vec3){1.0f / safe.scale.x, 1.0f / safe.scale.y, 1.0f / safe.scale.z});
    Mat4 inv_r = mat4_rotation_quat(quat_conjugate(safe.rotation));
    Mat4 inv_t = mat4_translation((Vec3){-safe.translation.x, -safe.translation.y, -safe.translation.z});
    Mat4 inv_rt = mat4_multiply(&inv_r, &inv_t);
    Mat4 inv = mat4_multiply(&inv_s, &inv_rt);
    if (world_to_local) *world_to_local = inv;
}

void coordinate_system2d_init(CoordinateSystem2D *system, float dpi_scale, float ui_scale, Vec2 viewport_size)
{
    if (!system) return;
    system->dpi_scale = dpi_scale;
    system->ui_scale = ui_scale;
    system->viewport_size = viewport_size;

    Mat4 world_to_logical = mat4_scale((Vec3){ui_scale, ui_scale, 1.0f});
    Mat4 logical_to_world = mat4_scale((Vec3){ui_scale != 0.0f ? 1.0f / ui_scale : 1.0f, ui_scale != 0.0f ? 1.0f / ui_scale : 1.0f, 1.0f});
    Mat4 logical_to_screen = mat4_scale((Vec3){dpi_scale, dpi_scale, 1.0f});
    Mat4 screen_to_logical = mat4_scale((Vec3){dpi_scale != 0.0f ? 1.0f / dpi_scale : 1.0f, dpi_scale != 0.0f ? 1.0f / dpi_scale : 1.0f, 1.0f});

    system->world_to_logical = world_to_logical;
    system->logical_to_world = logical_to_world;
    system->logical_to_screen = logical_to_screen;
    system->screen_to_logical = screen_to_logical;
    system->world_to_screen = mat4_multiply(&logical_to_screen, &world_to_logical);
    system->screen_to_world = mat4_multiply(&logical_to_world, &screen_to_logical);
}

static Vec2 mat4_apply_to_vec2(const Mat4 *m, Vec2 p)
{
    Vec3 r = mat4_transform_point(m, (Vec3){p.x, p.y, 0.0f});
    return (Vec2){r.x, r.y};
}

Vec2 coordinate_space_convert_2d(const CoordinateSystem2D *system, CoordinateSpace from, CoordinateSpace to, Vec2 value)
{
    if (!system) return value;
    if (from == to) return value;

    const Mat4 *forward = NULL;

    if (from == COORDINATE_SPACE_WORLD && to == COORDINATE_SPACE_LOGICAL) forward = &system->world_to_logical;
    if (from == COORDINATE_SPACE_LOGICAL && to == COORDINATE_SPACE_WORLD) forward = &system->logical_to_world;
    if (from == COORDINATE_SPACE_LOGICAL && to == COORDINATE_SPACE_SCREEN) forward = &system->logical_to_screen;
    if (from == COORDINATE_SPACE_SCREEN && to == COORDINATE_SPACE_LOGICAL) forward = &system->screen_to_logical;
    if (from == COORDINATE_SPACE_WORLD && to == COORDINATE_SPACE_SCREEN) forward = &system->world_to_screen;
    if (from == COORDINATE_SPACE_SCREEN && to == COORDINATE_SPACE_WORLD) forward = &system->screen_to_world;

    if (forward) {
        return mat4_apply_to_vec2(forward, value);
    }
    return value;
}

Vec2 coordinate_screen_to_logical(const CoordinateSystem2D *system, Vec2 screen)
{
    return coordinate_space_convert_2d(system, COORDINATE_SPACE_SCREEN, COORDINATE_SPACE_LOGICAL, screen);
}

Vec2 coordinate_logical_to_screen(const CoordinateSystem2D *system, Vec2 logical)
{
    return coordinate_space_convert_2d(system, COORDINATE_SPACE_LOGICAL, COORDINATE_SPACE_SCREEN, logical);
}

Vec2 coordinate_world_to_logical(const CoordinateSystem2D *system, Vec2 world)
{
    return coordinate_space_convert_2d(system, COORDINATE_SPACE_WORLD, COORDINATE_SPACE_LOGICAL, world);
}

Vec2 coordinate_logical_to_world(const CoordinateSystem2D *system, Vec2 logical)
{
    return coordinate_space_convert_2d(system, COORDINATE_SPACE_LOGICAL, COORDINATE_SPACE_WORLD, logical);
}

Vec2 coordinate_world_to_screen(const CoordinateSystem2D *system, Vec2 world)
{
    return coordinate_space_convert_2d(system, COORDINATE_SPACE_WORLD, COORDINATE_SPACE_SCREEN, world);
}

Vec2 coordinate_screen_to_world(const CoordinateSystem2D *system, Vec2 screen)
{
    return coordinate_space_convert_2d(system, COORDINATE_SPACE_SCREEN, COORDINATE_SPACE_WORLD, screen);
}

Vec2 coordinate_local_to_world_2d(const Transform2D *local, Vec2 p)
{
    Mat4 l2w;
    transform2d_build_matrices(local, &l2w, NULL);
    return mat4_apply_to_vec2(&l2w, p);
}

Vec2 coordinate_world_to_local_2d(const Transform2D *local, Vec2 p)
{
    Mat4 w2l;
    transform2d_build_matrices(local, NULL, &w2l);
    return mat4_apply_to_vec2(&w2l, p);
}

Vec3 coordinate_local_to_world_3d(const Transform3D *local, Vec3 p)
{
    Mat4 l2w;
    transform3d_build_matrices(local, &l2w, NULL);
    return mat4_transform_point(&l2w, p);
}

Vec3 coordinate_world_to_local_3d(const Transform3D *local, Vec3 p)
{
    Mat4 w2l;
    transform3d_build_matrices(local, NULL, &w2l);
    return mat4_transform_point(&w2l, p);
}

void render_context_init(RenderContext *ctx, const CoordinateSystem2D *coordinates, const Mat4 *projection)
{
    if (!ctx || !coordinates) return;
    ctx->coordinates = *coordinates;
    if (projection) {
        ctx->projection = *projection;
    } else {
        ctx->projection = mat4_identity();
    }
}

void projection3d_init(Projection3D *projection, const Mat4 *view, const Mat4 *projection_matrix)
{
    if (!projection || !view || !projection_matrix) return;
    projection->view = *view;
    projection->projection = *projection_matrix;
    projection->view_projection = mat4_multiply(projection_matrix, view);
    projection->inverse_view = mat4_inverse(view);
    projection->inverse_projection = mat4_inverse(projection_matrix);
}

Vec3 coordinate_world_to_clip(const Projection3D *projection, Vec3 world)
{
    if (!projection) return world;
    return mat4_transform_point(&projection->view_projection, world);
}

Vec3 coordinate_clip_to_world(const Projection3D *projection, Vec3 clip)
{
    if (!projection) return clip;
    Mat4 inv_vp = mat4_multiply(&projection->inverse_view, &projection->inverse_projection);
    Vec3 world = mat4_transform_point(&inv_vp, clip);
    return world;
}


==================================================
FILE START: src/foundation/math/coordinate_systems.h
==================================================
#ifndef COORDINATE_SYSTEMS_H
#define COORDINATE_SYSTEMS_H

#include "math_types.h"
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef enum CoordinateSpace {
    COORDINATE_SPACE_LOCAL = 0,
    COORDINATE_SPACE_WORLD = 1,
    COORDINATE_SPACE_LOGICAL = 2,
    COORDINATE_SPACE_SCREEN = 3,
} CoordinateSpace;

typedef struct Transform2D {
    Vec2 translation;
    float rotation_radians;
    Vec2 scale;
} Transform2D;

typedef struct Transform3D {
    Vec3 translation;
    Vec3 scale;
    Quat rotation;
} Transform3D;

typedef struct CoordinateSystem2D {
    float dpi_scale;
    float ui_scale;
    Vec2 viewport_size;
    Mat4 world_to_logical;
    Mat4 logical_to_world;
    Mat4 logical_to_screen;
    Mat4 screen_to_logical;
    Mat4 world_to_screen;
    Mat4 screen_to_world;
} CoordinateSystem2D;

typedef struct RenderContext {
    Mat4 projection;
    CoordinateSystem2D coordinates;
} RenderContext;

typedef struct Projection3D {
    Mat4 view;
    Mat4 projection;
    Mat4 view_projection;
    Mat4 inverse_view;
    Mat4 inverse_projection;
} Projection3D;

void transform2d_build_matrices(const Transform2D *transform, Mat4 *local_to_world, Mat4 *world_to_local);
void transform3d_build_matrices(const Transform3D *transform, Mat4 *local_to_world, Mat4 *world_to_local);

void coordinate_system2d_init(CoordinateSystem2D *system, float dpi_scale, float ui_scale, Vec2 viewport_size);
Vec2 coordinate_space_convert_2d(const CoordinateSystem2D *system, CoordinateSpace from, CoordinateSpace to, Vec2 value);
Vec2 coordinate_screen_to_logical(const CoordinateSystem2D *system, Vec2 screen);
Vec2 coordinate_logical_to_screen(const CoordinateSystem2D *system, Vec2 logical);
Vec2 coordinate_world_to_logical(const CoordinateSystem2D *system, Vec2 world);
Vec2 coordinate_logical_to_world(const CoordinateSystem2D *system, Vec2 logical);
Vec2 coordinate_world_to_screen(const CoordinateSystem2D *system, Vec2 world);
Vec2 coordinate_screen_to_world(const CoordinateSystem2D *system, Vec2 screen);
void render_context_init(RenderContext *ctx, const CoordinateSystem2D *coordinates, const Mat4 *projection);

Vec2 coordinate_local_to_world_2d(const Transform2D *local, Vec2 p);
Vec2 coordinate_world_to_local_2d(const Transform2D *local, Vec2 p);
Vec3 coordinate_local_to_world_3d(const Transform3D *local, Vec3 p);
Vec3 coordinate_world_to_local_3d(const Transform3D *local, Vec3 p);

void projection3d_init(Projection3D *projection, const Mat4 *view, const Mat4 *projection_matrix);
Vec3 coordinate_world_to_clip(const Projection3D *projection, Vec3 world);
Vec3 coordinate_clip_to_world(const Projection3D *projection, Vec3 clip);

#ifdef __cplusplus
}
#endif

#endif // COORDINATE_SYSTEMS_H


==================================================
FILE START: src/foundation/math/math_types.c
==================================================
#include "math_types.h"
#include <math.h>

Mat4 mat4_identity(void)
{
    Mat4 m = {0};
    m.m[0] = m.m[5] = m.m[10] = m.m[15] = 1.0f;
    return m;
}

Mat4 mat4_translation(Vec3 t)
{
    Mat4 m = mat4_identity();
    m.m[12] = t.x;
    m.m[13] = t.y;
    m.m[14] = t.z;
    return m;
}

Mat4 mat4_scale(Vec3 s)
{
    Mat4 m = {0};
    m.m[0] = s.x;
    m.m[5] = s.y;
    m.m[10] = s.z;
    m.m[15] = 1.0f;
    return m;
}

Quat quat_normalize(Quat q)
{
    float len = sqrtf(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);
    if (len <= 0.0f) {
        return (Quat){0.0f, 0.0f, 0.0f, 1.0f};
    }
    float inv = 1.0f / len;
    return (Quat){q.x * inv, q.y * inv, q.z * inv, q.w * inv};
}

Quat quat_conjugate(Quat q)
{
    return (Quat){-q.x, -q.y, -q.z, q.w};
}

Quat quat_from_euler(EulerAngles euler)
{
    float cy = cosf(euler.yaw * 0.5f);
    float sy = sinf(euler.yaw * 0.5f);
    float cp = cosf(euler.pitch * 0.5f);
    float sp = sinf(euler.pitch * 0.5f);
    float cr = cosf(euler.roll * 0.5f);
    float sr = sinf(euler.roll * 0.5f);

    Quat q;
    q.w = cr * cp * cy + sr * sp * sy;
    q.x = sr * cp * cy - cr * sp * sy;
    q.y = cr * sp * cy + sr * cp * sy;
    q.z = cr * cp * sy - sr * sp * cy;
    return quat_normalize(q);
}

Mat4 mat4_rotation_quat(Quat q)
{
    q = quat_normalize(q);
    float xx = q.x * q.x;
    float yy = q.y * q.y;
    float zz = q.z * q.z;
    float xy = q.x * q.y;
    float xz = q.x * q.z;
    float yz = q.y * q.z;
    float wx = q.w * q.x;
    float wy = q.w * q.y;
    float wz = q.w * q.z;

    Mat4 m = mat4_identity();
    m.m[0] = 1.0f - 2.0f * (yy + zz);
    m.m[4] = 2.0f * (xy + wz);
    m.m[8] = 2.0f * (xz - wy);

    m.m[1] = 2.0f * (xy - wz);
    m.m[5] = 1.0f - 2.0f * (xx + zz);
    m.m[9] = 2.0f * (yz + wx);

    m.m[2] = 2.0f * (xz + wy);
    m.m[6] = 2.0f * (yz - wx);
    m.m[10] = 1.0f - 2.0f * (xx + yy);

    return m;
}

Mat4 mat4_rotation_euler(EulerAngles euler)
{
    return mat4_rotation_quat(quat_from_euler(euler));
}

Mat4 mat4_multiply(const Mat4 *a, const Mat4 *b)
{
    Mat4 r = {0};
    for (int row = 0; row < 4; ++row) {
        for (int col = 0; col < 4; ++col) {
            r.m[col * 4 + row] = a->m[0 * 4 + row] * b->m[col * 4 + 0] +
                                 a->m[1 * 4 + row] * b->m[col * 4 + 1] +
                                 a->m[2 * 4 + row] * b->m[col * 4 + 2] +
                                 a->m[3 * 4 + row] * b->m[col * 4 + 3];
        }
    }
    return r;
}

static float mat4_det3x3(float a1, float a2, float a3, float b1, float b2, float b3, float c1, float c2, float c3)
{
    return a1 * (b2 * c3 - b3 * c2) - a2 * (b1 * c3 - b3 * c1) + a3 * (b1 * c2 - b2 * c1);
}

Mat4 mat4_inverse(const Mat4 *m)
{
    Mat4 inv;
    float det;
    float inv_det;

    inv.m[0] = mat4_det3x3(m->m[5], m->m[6], m->m[7], m->m[9], m->m[10], m->m[11], m->m[13], m->m[14], m->m[15]);
    inv.m[1] = -mat4_det3x3(m->m[1], m->m[2], m->m[3], m->m[9], m->m[10], m->m[11], m->m[13], m->m[14], m->m[15]);
    inv.m[2] = mat4_det3x3(m->m[1], m->m[2], m->m[3], m->m[5], m->m[6], m->m[7], m->m[13], m->m[14], m->m[15]);
    inv.m[3] = -mat4_det3x3(m->m[1], m->m[2], m->m[3], m->m[5], m->m[6], m->m[7], m->m[9], m->m[10], m->m[11]);

    inv.m[4] = -mat4_det3x3(m->m[4], m->m[6], m->m[7], m->m[8], m->m[10], m->m[11], m->m[12], m->m[14], m->m[15]);
    inv.m[5] = mat4_det3x3(m->m[0], m->m[2], m->m[3], m->m[8], m->m[10], m->m[11], m->m[12], m->m[14], m->m[15]);
    inv.m[6] = -mat4_det3x3(m->m[0], m->m[2], m->m[3], m->m[4], m->m[6], m->m[7], m->m[12], m->m[14], m->m[15]);
    inv.m[7] = mat4_det3x3(m->m[0], m->m[2], m->m[3], m->m[4], m->m[6], m->m[7], m->m[8], m->m[10], m->m[11]);

    inv.m[8] = mat4_det3x3(m->m[4], m->m[5], m->m[7], m->m[8], m->m[9], m->m[11], m->m[12], m->m[13], m->m[15]);
    inv.m[9] = -mat4_det3x3(m->m[0], m->m[1], m->m[3], m->m[8], m->m[9], m->m[11], m->m[12], m->m[13], m->m[15]);
    inv.m[10] = mat4_det3x3(m->m[0], m->m[1], m->m[3], m->m[4], m->m[5], m->m[7], m->m[12], m->m[13], m->m[15]);
    inv.m[11] = -mat4_det3x3(m->m[0], m->m[1], m->m[3], m->m[4], m->m[5], m->m[7], m->m[8], m->m[9], m->m[11]);

    inv.m[12] = -mat4_det3x3(m->m[4], m->m[5], m->m[6], m->m[8], m->m[9], m->m[10], m->m[12], m->m[13], m->m[14]);
    inv.m[13] = mat4_det3x3(m->m[0], m->m[1], m->m[2], m->m[8], m->m[9], m->m[10], m->m[12], m->m[13], m->m[14]);
    inv.m[14] = -mat4_det3x3(m->m[0], m->m[1], m->m[2], m->m[4], m->m[5], m->m[6], m->m[12], m->m[13], m->m[14]);
    inv.m[15] = mat4_det3x3(m->m[0], m->m[1], m->m[2], m->m[4], m->m[5], m->m[6], m->m[8], m->m[9], m->m[10]);

    det = m->m[0] * inv.m[0] + m->m[1] * inv.m[4] + m->m[2] * inv.m[8] + m->m[3] * inv.m[12];
    if (fabsf(det) < 1e-6f) {
        return mat4_identity();
    }
    inv_det = 1.0f / det;
    for (int i = 0; i < 16; ++i) {
        inv.m[i] *= inv_det;
    }
    return inv;
}

Mat4 mat4_perspective(float fov_y_radians, float aspect, float near_z, float far_z)
{
    float f = 1.0f / tanf(fov_y_radians * 0.5f);
    Mat4 m = {0};
    m.m[0] = f / aspect;
    m.m[5] = f;
    m.m[10] = (far_z + near_z) / (near_z - far_z);
    m.m[11] = -1.0f;
    m.m[14] = (2.0f * far_z * near_z) / (near_z - far_z);
    return m;
}

Mat4 mat4_orthographic(float left, float right, float bottom, float top, float near_z, float far_z)
{
    Mat4 m = mat4_identity();
    m.m[0] = 2.0f / (right - left);
    m.m[5] = 2.0f / (top - bottom);
    m.m[10] = -2.0f / (far_z - near_z);
    m.m[12] = -(right + left) / (right - left);
    m.m[13] = -(top + bottom) / (top - bottom);
    m.m[14] = -(far_z + near_z) / (far_z - near_z);
    return m;
}

Vec3 mat4_transform_point(const Mat4 *m, Vec3 p)
{
    float x = p.x * m->m[0] + p.y * m->m[4] + p.z * m->m[8] + m->m[12];
    float y = p.x * m->m[1] + p.y * m->m[5] + p.z * m->m[9] + m->m[13];
    float z = p.x * m->m[2] + p.y * m->m[6] + p.z * m->m[10] + m->m[14];
    float w = p.x * m->m[3] + p.y * m->m[7] + p.z * m->m[11] + m->m[15];
    if (fabsf(w) > 1e-6f) {
        float inv_w = 1.0f / w;
        x *= inv_w;
        y *= inv_w;
        z *= inv_w;
    }
    return (Vec3){x, y, z};
}

Vec3 mat4_transform_direction(const Mat4 *m, Vec3 v)
{
    float x = v.x * m->m[0] + v.y * m->m[4] + v.z * m->m[8];
    float y = v.x * m->m[1] + v.y * m->m[5] + v.z * m->m[9];
    float z = v.x * m->m[2] + v.y * m->m[6] + v.z * m->m[10];
    return (Vec3){x, y, z};
}


==================================================
FILE START: src/foundation/math/math_types.h
==================================================
#ifndef MATH_TYPES_H
#define MATH_TYPES_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct Vec2 {
    float x;
    float y;
} Vec2;

typedef struct Vec3 {
    float x;
    float y;
    float z;
} Vec3;

typedef struct Vec4 {
    float x; // REFLECT
    float y; // REFLECT
    float z; // REFLECT
    float w; // REFLECT
} Vec4;

typedef struct Rect {
    float x;
    float y;
    float w;
    float h;
} Rect;

typedef struct Quat {
    float x;
    float y;
    float z;
    float w;
} Quat;

typedef struct EulerAngles {
    float pitch;
    float yaw;
    float roll;
} EulerAngles;

typedef struct Mat4 {
    float m[16];
} Mat4;

Mat4 mat4_identity(void);
Mat4 mat4_translation(Vec3 t);
Mat4 mat4_scale(Vec3 s);
Mat4 mat4_rotation_quat(Quat q);
Mat4 mat4_rotation_euler(EulerAngles euler);
Mat4 mat4_multiply(const Mat4 *a, const Mat4 *b);
Mat4 mat4_inverse(const Mat4 *m);
Mat4 mat4_perspective(float fov_y_radians, float aspect, float near_z, float far_z);
Mat4 mat4_orthographic(float left, float right, float bottom, float top, float near_z, float far_z);
Vec3 mat4_transform_point(const Mat4 *m, Vec3 p);
Vec3 mat4_transform_direction(const Mat4 *m, Vec3 v);

Quat quat_from_euler(EulerAngles euler);
Quat quat_conjugate(Quat q);
Quat quat_normalize(Quat q);

#ifdef __cplusplus
}
#endif

#endif // MATH_TYPES_H


==================================================
FILE START: src/foundation/memory/arena.c
==================================================
#include "foundation/memory/arena.h"
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>

#define DEFAULT_ALIGNMENT 8

static uintptr_t align_forward(uintptr_t ptr, size_t align) {
    uintptr_t p, a, modulo;
    if ((align & (align - 1)) != 0) {
        return 0; // Error: alignment not power of 2
    }
    p = ptr;
    a = (uintptr_t)align;
    modulo = p & (a - 1);
    if (modulo != 0) {
        p += a - modulo;
    }
    return p;
}

bool arena_init(MemoryArena* arena, size_t size) {
    if (!arena) return false;
    arena->base = (uint8_t*)malloc(size);
    if (!arena->base) return false;
    arena->size = size;
    arena->offset = 0;
    arena->committed = size;
    return true;
}

void arena_destroy(MemoryArena* arena) {
    if (arena && arena->base) {
        free(arena->base);
        arena->base = NULL;
        arena->size = 0;
        arena->offset = 0;
    }
}

void arena_reset(MemoryArena* arena) {
    if (arena) arena->offset = 0;
}

void* arena_alloc(MemoryArena* arena, size_t size) {
    if (!arena || size == 0) return NULL;
    
    // Align current offset
    uintptr_t current_ptr = (uintptr_t)(arena->base + arena->offset);
    uintptr_t offset = align_forward(current_ptr, DEFAULT_ALIGNMENT);
    offset -= (uintptr_t)arena->base; // Convert back to relative offset

    if (offset + size > arena->size) {
        return NULL; // Out of memory
    }

    void* ptr = arena->base + offset;
    arena->offset = offset + size;
    return ptr;
}

void* arena_alloc_zero(MemoryArena* arena, size_t size) {
    void* ptr = arena_alloc(arena, size);
    if (ptr) {
        memset(ptr, 0, size);
    }
    return ptr;
}

char* arena_push_string(MemoryArena* arena, const char* str) {
    if (!str) return NULL;
    size_t len = strlen(str);
    return arena_push_string_n(arena, str, len);
}

char* arena_push_string_n(MemoryArena* arena, const char* str, size_t n) {
    if (!arena || !str) return NULL;
    char* data = (char*)arena_alloc(arena, n + 1);
    if (data) {
        memcpy(data, str, n);
        data[n] = '\0';
    }
    return data;
}

char* arena_sprintf(MemoryArena* arena, const char* fmt, ...) {
    if (!arena || !fmt) return NULL;
    
    va_list args;
    va_start(args, fmt);
    int len = vsnprintf(NULL, 0, fmt, args);
    va_end(args);

    if (len < 0) return NULL;

    char* data = (char*)arena_alloc(arena, len + 1);
    if (!data) return NULL;

    va_start(args, fmt);
    vsnprintf(data, len + 1, fmt, args);
    va_end(args);
    
    return data;
}

char* arena_printf(MemoryArena* arena, const char* fmt, ...) {
    if (!arena || !fmt) return NULL;
    
    va_list args;
    va_start(args, fmt);
    // Determine needed size
    va_list args_copy;
    va_copy(args_copy, args);
    int len = vsnprintf(NULL, 0, fmt, args_copy);
    va_end(args_copy);

    if (len < 0) {
        va_end(args);
        return NULL;
    }

    // Check capacity
    if (arena->offset + len + 1 > arena->size) {
        va_end(args);
        return NULL;
    }
    
    // Write directly to current offset
    char* ptr = (char*)(arena->base + arena->offset);
    // Note: vsnprintf writes the null terminator, so we will overwrite it on next call if we backup?
    // Actually, for a string builder, we usually want to overwrite the previous null terminator.
    // But `arena` logic is append-only.
    // Let's just write. The user will have a bunch of null-terminated strings one after another.
    // Wait, for Transpiler we want ONE big string.
    // So `arena_printf` is NOT suitable for building a single string unless we manually manage the null terminator.
    
    // Better approach for Transpiler: Use `arena` as the backing buffer for a custom StringBuilder.
    // But let's keep it simple.
    
    vsnprintf(ptr, len + 1, fmt, args);
    arena->offset += len; // We advance by len, NOT len+1, to effectively overwrite the null terminator next time? 
                          // No, `vsnprintf` always writes \0.
                          // If we want to concatenate, we should probably backup 1 byte if the previous alloc was a string?
                          // Too complex for generic arena.
                          
    // Let's just advance full length including \0.
    // If the user wants to concatenate, they should use a specific StringBuilder logic.
    // BUT, for this task, I will implement a `ArenaStringBuilder` in transpiler.c that uses the arena.
    
    arena->offset += (len + 1);
    
    va_end(args);
    return ptr;
}


==================================================
FILE START: src/foundation/memory/arena.h
==================================================
#ifndef ARENA_H
#define ARENA_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

typedef struct MemoryArena {
    uint8_t* base;
    size_t size;
    size_t offset;
    size_t committed; // For future virtual memory support
} MemoryArena;

// Initialize an arena with a fixed size block allocated from heap
bool arena_init(MemoryArena* arena, size_t size);

// Free the underlying memory
void arena_destroy(MemoryArena* arena);

// Reset the offset to 0 (does not free memory)
void arena_reset(MemoryArena* arena);

// Allocate 'size' bytes from the arena. Returns NULL if out of memory.
void* arena_alloc(MemoryArena* arena, size_t size);

// Allocate and zero-initialize
void* arena_alloc_zero(MemoryArena* arena, size_t size);

// Utilities
char* arena_push_string(MemoryArena* arena, const char* str);
char* arena_push_string_n(MemoryArena* arena, const char* str, size_t n);
char* arena_sprintf(MemoryArena* arena, const char* fmt, ...);

// Prints formatted string into the arena, advancing the offset. Returns ptr to start of printed string.
char* arena_printf(MemoryArena* arena, const char* fmt, ...);

#endif // ARENA_H


==================================================
FILE START: src/foundation/memory/pool.c
==================================================
#include "pool.h"
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

// --- Internal Types ---

typedef struct PoolBlock {
    void* memory;               // The raw memory chunk
    struct PoolBlock* next;     // Next block in chain
} PoolBlock;

struct MemoryPool {
    size_t item_size;
    size_t block_capacity;
    size_t block_bytes;         // Precomputed: item_size * block_capacity
    
    PoolBlock* head_block;      // Linked list of allocated blocks
    
    void* free_list;            // Head of the free list (points to a free slot)
};

// --- Implementation ---

MemoryPool* pool_create(size_t item_size, size_t block_capacity) {
    if (item_size == 0 || block_capacity == 0) return NULL;
    
    // Ensure item_size is at least large enough to hold a pointer (for the free list)
    if (item_size < sizeof(void*)) {
        item_size = sizeof(void*);
    }
    
    MemoryPool* pool = (MemoryPool*)malloc(sizeof(MemoryPool));
    if (!pool) return NULL;
    
    pool->item_size = item_size;
    pool->block_capacity = block_capacity;
    pool->block_bytes = item_size * block_capacity;
    pool->head_block = NULL;
    pool->free_list = NULL;
    
    return pool;
}

static void pool_add_block(MemoryPool* pool) {
    // 1. Allocate block metadata
    PoolBlock* block = (PoolBlock*)malloc(sizeof(PoolBlock));
    if (!block) return;
    
    // 2. Allocate data memory
    block->memory = malloc(pool->block_bytes);
    if (!block->memory) {
        free(block);
        return;
    }
    
    // 3. Link block
    block->next = pool->head_block;
    pool->head_block = block;
    
    // 4. Initialize free list inside the new block
    // We link all new slots together.
    uint8_t* ptr = (uint8_t*)block->memory;
    for (size_t i = 0; i < pool->block_capacity - 1; ++i) {
        void* current = ptr + (i * pool->item_size);
        void* next = ptr + ((i + 1) * pool->item_size);
        *(void**)current = next; // Store pointer to next
    }
    
    // Last item points to the *existing* free list (growing the stack)
    void* last = ptr + ((pool->block_capacity - 1) * pool->item_size);
    *(void**)last = pool->free_list;
    
    // Update head
    pool->free_list = ptr; // Start of this new block is the new free head
}

void pool_destroy(MemoryPool* pool) {
    if (!pool) return;
    
    PoolBlock* current = pool->head_block;
    while (current) {
        PoolBlock* next = current->next;
        free(current->memory);
        free(current);
        current = next;
    }
    
    free(pool);
}

void* pool_alloc(MemoryPool* pool) {
    if (!pool) return NULL;
    
    if (!pool->free_list) {
        pool_add_block(pool);
    }
    
    // Still empty? OOM.
    if (!pool->free_list) return NULL;
    
    // Pop from free list
    void* slot = pool->free_list;
    pool->free_list = *(void**)slot; // Next free slot is stored inside
    
    // Zero memory for safety (optional, but good for "Professional" reliability)
    memset(slot, 0, pool->item_size);
    
    return slot;
}

void pool_free(MemoryPool* pool, void* ptr) {
    if (!pool || !ptr) return;
    
    // Push back to free list
    *(void**)ptr = pool->free_list;
    pool->free_list = ptr;
}

void pool_clear(MemoryPool* pool) {
    if (!pool) return;
    
    // We need to rebuild the free list across ALL blocks.
    pool->free_list = NULL;
    
    PoolBlock* block = pool->head_block;
    while (block) {
        uint8_t* ptr = (uint8_t*)block->memory;
        
        // Link internal items
        for (size_t i = 0; i < pool->block_capacity - 1; ++i) {
            void* current = ptr + (i * pool->item_size);
            void* next = ptr + ((i + 1) * pool->item_size);
            *(void**)current = next;
        }
        
        // Last item links to current global free list
        void* last = ptr + ((pool->block_capacity - 1) * pool->item_size);
        *(void**)last = pool->free_list;
        
        // Update global head to start of this block
        pool->free_list = ptr;
        
        block = block->next;
    }
}


==================================================
FILE START: src/foundation/memory/pool.h
==================================================
#ifndef MEMORY_POOL_H
#define MEMORY_POOL_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

// --- Opaque Handle ---
// A pool manages objects of a FIXED size.
// It grows dynamically by allocating "blocks" (pages) from the system/arena.
typedef struct MemoryPool MemoryPool;

// --- API ---

// Create a new pool.
// item_size: Size of each element in bytes.
// block_capacity: How many items to store per block allocation (e.g., 256).
MemoryPool* pool_create(size_t item_size, size_t block_capacity);

// Destroy the pool and free all blocks.
void pool_destroy(MemoryPool* pool);

// Allocate one slot. Returns a pointer to zeroed memory.
// Returns NULL on system OOM.
void* pool_alloc(MemoryPool* pool);

// Return a slot to the pool.
void pool_free(MemoryPool* pool, void* ptr);

// Reset the pool (free all items, but keep blocks allocated for reuse).
// Ideally, this just resets the free list logic.
void pool_clear(MemoryPool* pool);

// Iterator support (Simple linear scan is tricky in pools without a dense index).
// For now, we assume the user maintains pointers or handles to active objects.

#endif // MEMORY_POOL_H


==================================================
FILE START: src/foundation/meta/reflection.c
==================================================
#include "reflection.h"
#include "foundation/string/string_id.h"
#include "foundation/math/math_types.h"
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

static bool parse_vec_from_string(const char* str, float* out, int count) {
    if (!str || !out || count < 1 || count > 4) return false;
    
    // Hex Color support (only for Vec3 and Vec4)
    if (str[0] == '#') {
        size_t len = strlen(str);
        if (len == 7 || len == 9) { // #RRGGBB or #RRGGBBAA
            char hex[9];
            strncpy(hex, str + 1, 8);
            hex[8] = '\0';
            
            unsigned long val = strtoul(hex, NULL, 16);
            
            float r, g, b, a = 1.0f;
            
            if (len == 7) { // RRGGBB
                r = ((val >> 16) & 0xFF) / 255.0f;
                g = ((val >> 8) & 0xFF) / 255.0f;
                b = (val & 0xFF) / 255.0f;
            } else { // RRGGBBAA
                r = ((val >> 24) & 0xFF) / 255.0f;
                g = ((val >> 16) & 0xFF) / 255.0f;
                b = ((val >> 8) & 0xFF) / 255.0f;
                a = (val & 0xFF) / 255.0f;
            }

            if (count >= 1) out[0] = r;
            if (count >= 2) out[1] = g;
            if (count >= 3) out[2] = b;
            if (count >= 4) out[3] = a;
            return true;
        }
        return false;
    }

    // Space separated floats
    // Simple scan logic
    int scanned = 0;
    if (count == 2) scanned = sscanf(str, "%f %f", &out[0], &out[1]);
    else if (count == 3) scanned = sscanf(str, "%f %f %f", &out[0], &out[1], &out[2]);
    else if (count == 4) scanned = sscanf(str, "%f %f %f %f", &out[0], &out[1], &out[2], &out[3]);
    
    // Allow implicit W=1.0 for Vec4 if only 3 components provided
    if (count == 4 && scanned == 3) {
        out[3] = 1.0f;
        return true;
    }
    
    return scanned == count;
}

void* meta_get_field_ptr(void* instance, const MetaField* field) {
    if (!instance || !field) return NULL;
    return (char*)instance + field->offset;
}

int meta_get_int(const void* instance, const MetaField* field) {
    if (!instance || !field || field->type != META_TYPE_INT) return 0;
    return *(int*)((char*)instance + field->offset);
}

float meta_get_float(const void* instance, const MetaField* field) {
    if (!instance || !field || field->type != META_TYPE_FLOAT) return 0.0f;
    return *(float*)((char*)instance + field->offset);
}

const char* meta_get_string(const void* instance, const MetaField* field) {
    if (!instance || !field) return NULL;
    if (field->type == META_TYPE_STRING) {
        return *(char**)((char*)instance + field->offset);
    } else if (field->type == META_TYPE_STRING_ARRAY) {
        return (char*)instance + field->offset;
    }
    return NULL;
}

bool meta_get_bool(const void* instance, const MetaField* field) {
    if (!instance || !field || field->type != META_TYPE_BOOL) return false;
    return *(bool*)((char*)instance + field->offset);
}

void meta_set_int(void* instance, const MetaField* field, int value) {
    if (!instance || !field || (field->type != META_TYPE_INT && field->type != META_TYPE_ENUM)) return;
    *(int*)((char*)instance + field->offset) = value;
}

void meta_set_float(void* instance, const MetaField* field, float value) {
    if (!instance || !field || field->type != META_TYPE_FLOAT) return;
    *(float*)((char*)instance + field->offset) = value;
}

void meta_set_string(void* instance, const MetaField* field, const char* value) {
    if (!instance || !field) return;
    
    if (field->type == META_TYPE_STRING) {
        char** ptr = (char**)((char*)instance + field->offset);
        // if (*ptr) free(*ptr); // FIXME: Deliberate leak! Do not free as it might be Arena memory.
        if (value) {
            size_t len = strlen(value);
            *ptr = (char*)malloc(len + 1);
            if (*ptr) memcpy(*ptr, value, len + 1);
        } else {
            *ptr = NULL;
        }
    } else if (field->type == META_TYPE_STRING_ARRAY) {
        char* ptr = (char*)instance + field->offset;
        if (value) {
            // Using a safe default limit since MetaField doesn't store array size yet.
            // Assuming 256 is enough for most names/paths in this engine.
            strncpy(ptr, value, 255);
            ptr[255] = '\0';
        } else {
            ptr[0] = '\0';
        }
    }
}

void meta_set_bool(void* instance, const MetaField* field, bool value) {
    if (!instance || !field || field->type != META_TYPE_BOOL) return;
    *(bool*)((char*)instance + field->offset) = value;
}

const MetaField* meta_find_field(const MetaStruct* meta, const char* field_name) {
    if (!meta || !field_name) return NULL;
    for (size_t i = 0; i < meta->field_count; ++i) {
        if (strcmp(meta->fields[i].name, field_name) == 0) {
            return &meta->fields[i];
        }
    }
    return NULL;
}

const char* meta_enum_get_name(const MetaEnum* meta_enum, int value) {
    if (!meta_enum) return NULL;
    for (size_t i = 0; i < meta_enum->count; ++i) {
        if (meta_enum->values[i].value == value) {
            return meta_enum->values[i].name;
        }
    }
    return NULL;
}

const MetaField* meta_find_field_by_path(const MetaStruct* root_meta, const char* path, size_t* out_offset) {
    if (!root_meta || !path || !out_offset) return NULL;
    
    *out_offset = 0;
    const MetaStruct* current_meta = root_meta;
    const MetaField* current_field = NULL;
    
    char buffer[256];
    strncpy(buffer, path, 255);
    buffer[255] = '\0';
    
    char* token = strtok(buffer, ".");
    while (token) {
        if (!current_meta) return NULL; // Cannot traverse into non-struct
        
        current_field = meta_find_field(current_meta, token);
        if (!current_field) return NULL;
        
        *out_offset += current_field->offset;
        
        // Prepare for next iteration
        token = strtok(NULL, ".");
        if (token) {
            // Must be a struct to continue
            if (current_field->type == META_TYPE_STRUCT) {
                current_meta = meta_get_struct(current_field->type_name);
            } else {
                return NULL; // Path continues but type is not struct
            }
        }
    }
    
    return current_field;
}

bool meta_set_from_string(void* instance, const MetaField* field, const char* value_str) {
    if (!instance || !field || !value_str) return false;

    switch (field->type) {
        case META_TYPE_INT: {
            meta_set_int(instance, field, atoi(value_str));
            return true;
        }
        case META_TYPE_FLOAT: {
            meta_set_float(instance, field, (float)atof(value_str));
            return true;
        }
        case META_TYPE_BOOL: {
            bool val = (strcmp(value_str, "true") == 0 || strcmp(value_str, "1") == 0);
            meta_set_bool(instance, field, val);
            return true;
        }
        case META_TYPE_STRING:
        case META_TYPE_STRING_ARRAY: {
            meta_set_string(instance, field, value_str);
            return true;
        }
        case META_TYPE_ENUM: {
            const MetaEnum* e = meta_get_enum(field->type_name);
            int enum_val = 0;
            if (e && meta_enum_get_value(e, value_str, &enum_val)) {
                // Assuming enums are stored as ints
                *(int*)((char*)instance + field->offset) = enum_val;
                return true;
            }
            return false;
        }
        case META_TYPE_STRING_ID: {
            StringId id = str_id(value_str);
            // StringId is uint32_t
            *(uint32_t*)((char*)instance + field->offset) = id;
            return true;
        }
        case META_TYPE_VEC2: {
            return parse_vec_from_string(value_str, (float*)((char*)instance + field->offset), 2);
        }
        case META_TYPE_VEC3: {
            return parse_vec_from_string(value_str, (float*)((char*)instance + field->offset), 3);
        }
        case META_TYPE_VEC4: {
            return parse_vec_from_string(value_str, (float*)((char*)instance + field->offset), 4);
        }
        case META_TYPE_FLAGS: {
            const MetaEnum* e = meta_get_enum(field->type_name);
            if (!e) return false;

            uint32_t final_mask = 0;
            
            // Work on a copy
            char buf[256];
            strncpy(buf, value_str, 255);
            buf[255] = '\0';
            
            char* start = buf;
            while (*start) {
                // 1. Skip leading spaces
                while (*start == ' ' || *start == '\t') start++;
                if (*start == '\0') break;

                // 2. Find end of token
                char* end = start;
                while (*end && *end != '|') end++;

                // 3. Trim trailing spaces
                char* token_end = end;
                while (token_end > start && (*(token_end - 1) == ' ' || *(token_end - 1) == '\t')) {
                    token_end--;
                }
                
                // Temporarily null-terminate to lookup
                char saved = *token_end;
                *token_end = '\0';
                
                int enum_val = 0;
                if (meta_enum_get_value(e, start, &enum_val)) {
                    final_mask |= (uint32_t)enum_val;
                }
                
                // Restore if needed (though we move past it anyway)
                *token_end = saved;

                // 4. Advance
                if (*end == '|') start = end + 1;
                else start = end;
            }
            
            *(uint32_t*)((char*)instance + field->offset) = final_mask;
            return true;
        }
        default:
            return false;
    }
}


==================================================
FILE START: src/foundation/meta/reflection.h
==================================================
#ifndef FOUNDATION_META_REFLECTION_H
#define FOUNDATION_META_REFLECTION_H

#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

// Ğ¢Ğ¸Ğ¿Ñ‹ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ĞµÑ‚ Ğ½Ğ°ÑˆĞ° ÑĞ¸ÑÑ‚ĞµĞ¼Ğ° Ñ€ĞµÑ„Ğ»ĞµĞºÑĞ¸Ğ¸
typedef enum MetaType {
    META_TYPE_INT,
    META_TYPE_FLOAT,
    META_TYPE_STRING,        // char* (pointer)
    META_TYPE_STRING_ARRAY,  // char[N] (inline buffer)
    META_TYPE_BOOL,
    META_TYPE_STRUCT,
    META_TYPE_ENUM,
    META_TYPE_POINTER,
    META_TYPE_POINTER_ARRAY, // e.g. MathNode**
    META_TYPE_STRING_ID,      // StringId (uint32_t hash)
    META_TYPE_FLAGS,          // Bitmask of Enum values
    META_TYPE_VEC2,
    META_TYPE_VEC3,
    META_TYPE_VEC4
} MetaType;
// ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ñ enum (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: "UI_LAYOUT_ROW" -> 1)
typedef struct MetaEnumValue {
    const char* name;
    int value;
} MetaEnumValue;

// ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ñ‚Ğ¸Ğ¿Ğ° Enum
typedef struct MetaEnum {
    const char* name;
    const MetaEnumValue* values;
    size_t count;
} MetaEnum;

// ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ¿Ğ¾Ğ»Ñ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹
typedef struct MetaField {
    const char* name;
    MetaType type;
    size_t offset;         
    const char* type_name; // Ğ˜Ğ¼Ñ Ñ‚Ğ¸Ğ¿Ğ° (Ğ´Ğ»Ñ STRUCT/ENUM)
} MetaField;

// ĞĞ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğµ Ğ²ÑĞµĞ¹ ÑÑ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ñ‹
typedef struct MetaStruct {
    const char* name;      
    size_t size;           
    const MetaField* fields;
    size_t field_count;
} MetaStruct;

// Ğ ĞµĞµÑÑ‚Ñ€ Ñ‚Ğ¸Ğ¿Ğ¾Ğ²
const MetaStruct* meta_get_struct(const char* name);
const MetaEnum* meta_get_enum(const char* name);

// Ğ¥ĞµĞ»Ğ¿ĞµÑ€Ñ‹
void* meta_get_field_ptr(void* instance, const MetaField* field);
int meta_get_int(const void* instance, const MetaField* field);
float meta_get_float(const void* instance, const MetaField* field);
const char* meta_get_string(const void* instance, const MetaField* field);
bool meta_get_bool(const void* instance, const MetaField* field);
void meta_set_int(void* instance, const MetaField* field, int value);
void meta_set_float(void* instance, const MetaField* field, float value);
void meta_set_string(void* instance, const MetaField* field, const char* value);
void meta_set_bool(void* instance, const MetaField* field, bool value);

// Helper to find a field by name in a struct definition
const MetaField* meta_find_field(const MetaStruct* meta, const char* field_name);
// Helper to find enum value by string name (returns true if found)
bool meta_enum_get_value(const MetaEnum* meta_enum, const char* name_str, int* out_value);

// Helper to find enum name by value
const char* meta_enum_get_name(const MetaEnum* meta_enum, int value);

// Helper to find a field by dot-notation path (e.g. "transform.position.x")
// Returns the final field and writes the total byte offset from the root instance to *out_offset.
const MetaField* meta_find_field_by_path(const MetaStruct* root_meta, const char* path, size_t* out_offset);

// Sets a field value parsing it from a string representation.
// Returns true if parsing/setting was successful.
bool meta_set_from_string(void* instance, const MetaField* field, const char* value_str);

#endif // FOUNDATION_META_REFLECTION_H


==================================================
FILE START: src/foundation/platform/fs.c
==================================================
#include "foundation/platform/fs.h"
#include "foundation/platform/platform.h"
#include "foundation/memory/arena.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef _WIN32
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#else
#include <dirent.h>
#include <sys/stat.h>
#include <unistd.h>
#endif

char* platform_strdup(const char* src) {
    if (!src) return NULL;
    size_t len = strlen(src) + 1;
    char* dest = (char*)malloc(len);
    if (dest) {
        memcpy(dest, src, len);
    }
    return dest;
}

void platform_strncpy(char* dest, const char* src, size_t count) {
    if (!dest) return;
    // Standard strncpy behavior: copy up to count, pad with nulls
    size_t i;
    for (i = 0; i < count && src[i] != '\0'; i++) {
        dest[i] = src[i];
    }
    for (; i < count; i++) {
        dest[i] = '\0';
    }
}

FILE* platform_fopen(const char* filename, const char* mode) {
#ifdef _MSC_VER
    FILE* f = NULL;
    if (fopen_s(&f, filename, mode) != 0) return NULL;
    return f;
#else
    return fopen(filename, mode);
#endif
}

char* fs_read_text(MemoryArena* arena, const char* path) {
    if (!path) return NULL;
    FILE *f = platform_fopen(path, "rb");
    if (!f) return NULL;
    fseek(f, 0, SEEK_END);
    long len = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    char *text = NULL;
    if (arena) {
        text = (char*)arena_alloc(arena, (size_t)len + 1);
    } else {
        text = (char*)malloc((size_t)len + 1);
    }

    if (!text) {
        fclose(f);
        return NULL;
    }
    fread(text, 1, (size_t)len, f);
    text[len] = 0;
    fclose(f);
    return text;
}

struct PlatformDir {
#ifdef _WIN32
    HANDLE handle;
    WIN32_FIND_DATAA first_data;
    int has_first;
#else
    DIR* dir;
#endif
    char* base_path;
};

static char* join_path(const char* dir, const char* leaf) {
    if (!dir || !leaf) return NULL;
    size_t dir_len = strlen(dir);
    while (dir_len > 0 && (dir[dir_len - 1] == '/' || dir[dir_len - 1] == '\\')) dir_len--;
    size_t leaf_len = strlen(leaf);
    size_t total = dir_len + 1 + leaf_len + 1;
    char* out = (char*)malloc(total);
    if (!out) return NULL;
    memcpy(out, dir, dir_len);
    out[dir_len] = '/';
    memcpy(out + dir_len + 1, leaf, leaf_len);
    out[total - 1] = 0;
    return out;
}

PlatformDir* platform_dir_open(const char* path) {
    if (!path) return NULL;
    PlatformDir* dir = (PlatformDir*)calloc(1, sizeof(PlatformDir));
    if (!dir) return NULL;
    dir->base_path = strdup(path);
    if (!dir->base_path) {
        free(dir);
        return NULL;
    }
#ifdef _WIN32
    size_t base_len = strlen(path);
    while (base_len > 0 && (path[base_len - 1] == '/' || path[base_len - 1] == '\\')) base_len--;
    size_t pattern_len = base_len + 3;
    char* pattern = (char*)malloc(pattern_len);
    if (!pattern) {
        free(dir->base_path);
        free(dir);
        return NULL;
    }
    memcpy(pattern, path, base_len);
    pattern[base_len] = '\\';
    pattern[base_len + 1] = '*';
    pattern[base_len + 2] = 0;

    dir->handle = FindFirstFileA(pattern, &dir->first_data);
    free(pattern);
    if (dir->handle == INVALID_HANDLE_VALUE) {
        free(dir->base_path);
        free(dir);
        return NULL;
    }
    dir->has_first = 1;
#else
    dir->dir = opendir(path);
    if (!dir->dir) {
        free(dir->base_path);
        free(dir);
        return NULL;
    }
#endif
    return dir;
}

static bool populate_entry(const char* name, bool is_dir, PlatformDirEntry* out_entry) {
    if (!out_entry) return false;
    out_entry->name = strdup(name);
    if (!out_entry->name) return false;
    out_entry->is_dir = is_dir;
    return true;
}

bool platform_dir_read(PlatformDir* dir, PlatformDirEntry* out_entry) {
    if (!dir || !out_entry) return false;
#ifdef _WIN32
    WIN32_FIND_DATAA data;
    int has_data = 0;
    if (dir->has_first) {
        data = dir->first_data;
        dir->has_first = 0;
        has_data = 1;
    }
    while (!has_data && FindNextFileA(dir->handle, &data)) {
        has_data = 1;
    }
    if (!has_data) return false;
    const char* name = data.cFileName;
    if (strcmp(name, ".") == 0 || strcmp(name, "..") == 0) return platform_dir_read(dir, out_entry);
    bool is_dir = (data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;
    if (!populate_entry(name, is_dir, out_entry)) return false;
    return true;
#else
    struct dirent* ent = NULL;
    while ((ent = readdir(dir->dir)) != NULL) {
        if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0) continue;
        bool is_dir = ent->d_type == DT_DIR;
        if (ent->d_type == DT_UNKNOWN) {
            char* full = join_path(dir->base_path, ent->d_name);
            if (full) {
                struct stat st;
                if (stat(full, &st) == 0) is_dir = S_ISDIR(st.st_mode);
                free(full);
            }
        }
        if (populate_entry(ent->d_name, is_dir, out_entry)) return true;
        return false;
    }
    return false;
#endif
}

void platform_dir_close(PlatformDir* dir) {
    if (!dir) return;
#ifdef _WIN32
    if (dir->handle != INVALID_HANDLE_VALUE) FindClose(dir->handle);
#else
    if (dir->dir) closedir(dir->dir);
#endif
    free(dir->base_path);
    free(dir);
}

bool platform_mkdir(const char* path) {
    if (!path) return false;
#ifdef _WIN32
    return CreateDirectoryA(path, NULL) != 0 || GetLastError() == ERROR_ALREADY_EXISTS;
#else
    struct stat st = {0};
    if (stat(path, &st) == -1) {
        return mkdir(path, 0700) == 0;
    }
    return S_ISDIR(st.st_mode);
#endif
}

bool platform_remove_file(const char* path) {
    if (!path) return false;
#ifdef _WIN32
    return DeleteFileA(path) != 0;
#else
    return unlink(path) == 0;
#endif
}

void* fs_read_bin(MemoryArena* arena, const char* path, size_t* out_size) {
    if (!path) return NULL;
    FILE* f = platform_fopen(path, "rb");
    if (!f) return NULL;

    fseek(f, 0, SEEK_END);
    long len = ftell(f);
    fseek(f, 0, SEEK_SET);

    if (len < 0) {
        fclose(f);
        return NULL;
    }

    void* data = NULL;
    if (arena) {
        data = arena_alloc(arena, (size_t)len);
    } else {
        data = malloc((size_t)len);
    }

    if (!data) {
        fclose(f);
        return NULL;
    }

    size_t read = fread(data, 1, (size_t)len, f);
    fclose(f);

    if (read != (size_t)len) {
        if (!arena) free(data);
        return NULL;
    }

    if (out_size) *out_size = (size_t)len;
    return data;
}


==================================================
FILE START: src/foundation/platform/fs.h
==================================================
#ifndef PLATFORM_FS_H
#define PLATFORM_FS_H

#include "foundation/memory/arena.h"
#include <stdbool.h>

typedef struct PlatformDir PlatformDir;

typedef struct PlatformDirEntry {
    char* name;
    bool is_dir;
} PlatformDirEntry;

char* fs_read_text(MemoryArena* arena, const char* path);

PlatformDir* platform_dir_open(const char* path);
bool platform_dir_read(PlatformDir* dir, PlatformDirEntry* out_entry);
void platform_dir_close(PlatformDir* dir);

bool platform_mkdir(const char* path);
bool platform_remove_file(const char* path);

// Reads a binary file into a raw buffer allocated from the arena (or heap if arena is NULL).
// If arena is NULL, the caller must free() the result.
// Returns NULL on failure.
void* fs_read_bin(MemoryArena* arena, const char* path, size_t* out_size);

#endif // PLATFORM_FS_H


==================================================
FILE START: src/foundation/platform/glfw_platform.c
==================================================
#include "platform.h"
#include "foundation/logger/logger.h"
#include <stdio.h>

#define GLFW_INCLUDE_VULKAN
#include <GLFW/glfw3.h>
#include <stdlib.h>

typedef struct PlatformWindowCallbacks {
    PlatformFramebufferSizeCallback framebuffer_size;
    PlatformScrollCallback scroll;
    PlatformMouseButtonCallback mouse_button;
    PlatformKeyCallback key;
    PlatformCharCallback character;
    PlatformCursorPosCallback cursor_pos;
    void* user_data;
} PlatformWindowCallbacks;

struct PlatformWindow {
    GLFWwindow* handle;
    PlatformWindowCallbacks callbacks;
    void* user_pointer;
};

static void glfw_error_callback(int error, const char* description) {
    LOG_ERROR("GLFW Error %d: %s", error, description);
}

static void on_glfw_framebuffer_size(GLFWwindow* window, int width, int height) {
    PlatformWindow* platform_window = (PlatformWindow*)glfwGetWindowUserPointer(window);
    if (!platform_window || !platform_window->callbacks.framebuffer_size) return;
    platform_window->callbacks.framebuffer_size(platform_window, width, height, platform_window->callbacks.user_data);
}

static void on_glfw_scroll(GLFWwindow* window, double xoff, double yoff) {
    PlatformWindow* platform_window = (PlatformWindow*)glfwGetWindowUserPointer(window);
    if (!platform_window || !platform_window->callbacks.scroll) return;
    platform_window->callbacks.scroll(platform_window, xoff, yoff, platform_window->callbacks.user_data);
}

static void on_glfw_mouse_button(GLFWwindow* window, int button, int action, int mods) {
    PlatformWindow* platform_window = (PlatformWindow*)glfwGetWindowUserPointer(window);
    if (!platform_window || !platform_window->callbacks.mouse_button) return;
    platform_window->callbacks.mouse_button(platform_window, (PlatformMouseButton)button, (PlatformInputAction)action, mods,
                                           platform_window->callbacks.user_data);
}

static void on_glfw_key(GLFWwindow* window, int key, int scancode, int action, int mods) {
    PlatformWindow* platform_window = (PlatformWindow*)glfwGetWindowUserPointer(window);
    if (!platform_window || !platform_window->callbacks.key) return;
    platform_window->callbacks.key(platform_window, key, scancode, (PlatformInputAction)action, mods,
                                    platform_window->callbacks.user_data);
}

static void on_glfw_char(GLFWwindow* window, unsigned int codepoint) {
    PlatformWindow* platform_window = (PlatformWindow*)glfwGetWindowUserPointer(window);
    if (!platform_window || !platform_window->callbacks.character) return;
    platform_window->callbacks.character(platform_window, codepoint, platform_window->callbacks.user_data);
}

static void on_glfw_cursor_pos(GLFWwindow* window, double x, double y) {
    PlatformWindow* platform_window = (PlatformWindow*)glfwGetWindowUserPointer(window);
    if (!platform_window || !platform_window->callbacks.cursor_pos) return;
    platform_window->callbacks.cursor_pos(platform_window, x, y, platform_window->callbacks.user_data);
}

bool platform_layer_init(void) {
    glfwSetErrorCallback(glfw_error_callback); // Set the error callback
    if (!glfwInit()) {
        LOG_FATAL("Failed to initialize GLFW");
        return false;
    }
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    return true;
}

void platform_layer_shutdown(void) { glfwTerminate(); }

bool platform_vulkan_supported(void) { return glfwVulkanSupported() == GLFW_TRUE; }

PlatformWindow* platform_create_window(int width, int height, const char* title) {
    PlatformWindow* window = (PlatformWindow*)calloc(1, sizeof(PlatformWindow));
    if (!window) return NULL;

    window->handle = glfwCreateWindow(width, height, title, NULL, NULL);
    if (!window->handle) {
        LOG_FATAL("Failed to create GLFW window");
        free(window);
        return NULL;
    }

    glfwSetWindowUserPointer(window->handle, window);
    glfwSetFramebufferSizeCallback(window->handle, on_glfw_framebuffer_size);
    glfwSetScrollCallback(window->handle, on_glfw_scroll);
    glfwSetMouseButtonCallback(window->handle, on_glfw_mouse_button);
    glfwSetKeyCallback(window->handle, on_glfw_key);
    glfwSetCharCallback(window->handle, on_glfw_char);
    glfwSetCursorPosCallback(window->handle, on_glfw_cursor_pos);
    return window;
}

void platform_destroy_window(PlatformWindow* window) {
    if (!window) return;
    if (window->handle) {
        glfwDestroyWindow(window->handle);
    }
    free(window);
}

void platform_set_window_user_pointer(PlatformWindow* window, void* user_pointer) {
    if (!window) return;
    window->user_pointer = user_pointer;
}

void* platform_get_window_user_pointer(PlatformWindow* window) { return window ? window->user_pointer : NULL; }

PlatformWindowSize platform_get_window_size(PlatformWindow* window) {
    PlatformWindowSize size = {0};
    if (!window || !window->handle) return size;
    glfwGetWindowSize(window->handle, &size.width, &size.height);
    return size;
}

PlatformWindowSize platform_get_framebuffer_size(PlatformWindow* window) {
    PlatformWindowSize size = {0};
    if (!window || !window->handle) return size;
    glfwGetFramebufferSize(window->handle, &size.width, &size.height);
    return size;
}

PlatformDpiScale platform_get_window_dpi(PlatformWindow* window) {
    PlatformDpiScale scale = {.x_scale = 1.0f, .y_scale = 1.0f};
    if (!window || !window->handle) return scale;
    glfwGetWindowContentScale(window->handle, &scale.x_scale, &scale.y_scale);
    return scale;
}

void platform_get_cursor_pos(PlatformWindow* window, double* x, double* y) {
    if (!window || !window->handle) return;
    glfwGetCursorPos(window->handle, x, y);
}

bool platform_get_mouse_button(PlatformWindow* window, int button) {
    if (!window || !window->handle) return false;
    return glfwGetMouseButton(window->handle, button) == GLFW_PRESS;
}

bool platform_get_key(PlatformWindow* window, int key) {
    if (!window || !window->handle) return false;
    return glfwGetKey(window->handle, key) == GLFW_PRESS;
}

void platform_set_framebuffer_size_callback(PlatformWindow* window, PlatformFramebufferSizeCallback callback, 
                                            void* user_data) {
    if (!window) return;
    window->callbacks.framebuffer_size = callback;
    window->callbacks.user_data = user_data;
}

void platform_set_scroll_callback(PlatformWindow* window, PlatformScrollCallback callback, void* user_data) {
    if (!window) return;
    window->callbacks.scroll = callback;
    window->callbacks.user_data = user_data;
}

void platform_set_mouse_button_callback(PlatformWindow* window, PlatformMouseButtonCallback callback, void* user_data) {
    if (!window) return;
    window->callbacks.mouse_button = callback;
    window->callbacks.user_data = user_data;
}

void platform_set_key_callback(PlatformWindow* window, PlatformKeyCallback callback, void* user_data) {
    if (!window) return;
    window->callbacks.key = callback;
    window->callbacks.user_data = user_data;
}

void platform_set_char_callback(PlatformWindow* window, PlatformCharCallback callback, void* user_data) {
    if (!window) return;
    window->callbacks.character = callback;
    window->callbacks.user_data = user_data;
}

void platform_set_cursor_pos_callback(PlatformWindow* window, PlatformCursorPosCallback callback, void* user_data) {
    if (!window) return;
    window->callbacks.cursor_pos = callback;
    window->callbacks.user_data = user_data;
}

bool platform_window_should_close(PlatformWindow* window) {
    if (!window || !window->handle) return true;
    return glfwWindowShouldClose(window->handle) == GLFW_TRUE;
}

void platform_set_window_should_close(PlatformWindow* window, bool should_close) {
    if (!window || !window->handle) return;
    glfwSetWindowShouldClose(window->handle, should_close ? GLFW_TRUE : GLFW_FALSE);
}

void platform_poll_events(void) { glfwPollEvents(); }

void platform_wait_events(void) { glfwWaitEvents(); }

double platform_get_time_ms(void) { return glfwGetTime() * 1000.0; }

bool platform_get_required_extensions(const char*** names, uint32_t* count) {
    uint32_t ext_count = 0;
    const char** extensions = glfwGetRequiredInstanceExtensions(&ext_count);
    if (!extensions || ext_count == 0) return false;
    if (names) *names = extensions;
    if (count) *count = ext_count;
    return true;
}

bool platform_create_surface(PlatformWindow* window, void* instance, void* allocator,
                                    PlatformSurface* out_surface) {
    if (!window || !window->handle || !instance || !out_surface) return false;
    VkInstance vk_instance = (VkInstance)instance;
    const VkAllocationCallbacks* vk_alloc = (const VkAllocationCallbacks*)allocator;

    VkSurfaceKHR surface = VK_NULL_HANDLE;
    VkResult res = glfwCreateWindowSurface(vk_instance, window->handle, vk_alloc, &surface);
    if (res != VK_SUCCESS) return false;
    out_surface->handle = (void*)surface;
    return true;
}

void platform_destroy_surface(void* instance, void* allocator, PlatformSurface* surface) {
    if (!instance || !surface || !surface->handle) return;
    VkInstance vk_instance = (VkInstance)instance;
    const VkAllocationCallbacks* vk_alloc = (const VkAllocationCallbacks*)allocator;
    vkDestroySurfaceKHR(vk_instance, (VkSurfaceKHR)surface->handle, vk_alloc);
    surface->handle = NULL;
}


==================================================
FILE START: src/foundation/platform/platform.h
==================================================
#ifndef PLATFORM_H
#define PLATFORM_H

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>

typedef struct PlatformWindow PlatformWindow;

typedef struct PlatformWindowSize {
    int width;
    int height;
} PlatformWindowSize;

typedef struct PlatformDpiScale {
    float x_scale;
    float y_scale;
} PlatformDpiScale;

typedef struct PlatformSurface {
    void* handle;
} PlatformSurface;

typedef enum PlatformMouseButton {
    PLATFORM_MOUSE_BUTTON_LEFT = 0,
    PLATFORM_MOUSE_BUTTON_RIGHT = 1,
    PLATFORM_MOUSE_BUTTON_MIDDLE = 2,
} PlatformMouseButton;

typedef enum PlatformInputAction {
    PLATFORM_RELEASE = 0,
    PLATFORM_PRESS = 1,
    PLATFORM_REPEAT = 2,
} PlatformInputAction;

typedef void (*PlatformMouseButtonCallback)(PlatformWindow* window, PlatformMouseButton button, PlatformInputAction action,
                                            int mods, void* user_data);
typedef void (*PlatformKeyCallback)(PlatformWindow* window, int key, int scancode, PlatformInputAction action, int mods, void* user_data);
typedef void (*PlatformCharCallback)(PlatformWindow* window, unsigned int codepoint, void* user_data);
typedef void (*PlatformScrollCallback)(PlatformWindow* window, double xoff, double yoff, void* user_data);
typedef void (*PlatformCursorPosCallback)(PlatformWindow* window, double x, double y, void* user_data);
typedef void (*PlatformFramebufferSizeCallback)(PlatformWindow* window, int width, int height, void* user_data);

bool platform_layer_init(void);
void platform_layer_shutdown(void);

bool platform_vulkan_supported(void);

PlatformWindow* platform_create_window(int width, int height, const char* title);
void platform_destroy_window(PlatformWindow* window);

void platform_set_window_user_pointer(PlatformWindow* window, void* user_pointer);
void* platform_get_window_user_pointer(PlatformWindow* window);

PlatformWindowSize platform_get_window_size(PlatformWindow* window);
PlatformWindowSize platform_get_framebuffer_size(PlatformWindow* window);
PlatformDpiScale platform_get_window_dpi(PlatformWindow* window);
void platform_get_cursor_pos(PlatformWindow* window, double* x, double* y);
bool platform_get_mouse_button(PlatformWindow* window, int button);
bool platform_get_key(PlatformWindow* window, int key);

void platform_set_framebuffer_size_callback(PlatformWindow* window, PlatformFramebufferSizeCallback callback,
                                            void* user_data);
void platform_set_scroll_callback(PlatformWindow* window, PlatformScrollCallback callback, void* user_data);
void platform_set_mouse_button_callback(PlatformWindow* window, PlatformMouseButtonCallback callback,
                                        void* user_data);
void platform_set_key_callback(PlatformWindow* window, PlatformKeyCallback callback, void* user_data);
void platform_set_char_callback(PlatformWindow* window, PlatformCharCallback callback, void* user_data);
void platform_set_cursor_pos_callback(PlatformWindow* window, PlatformCursorPosCallback callback, void* user_data);

bool platform_window_should_close(PlatformWindow* window);
void platform_set_window_should_close(PlatformWindow* window, bool should_close);

void platform_poll_events(void);
void platform_wait_events(void);
double platform_get_time_ms(void);

// Graphics API Support
bool platform_get_required_extensions(const char*** names, uint32_t* count);
bool platform_create_surface(PlatformWindow* window, void* instance, void* allocator, PlatformSurface* out_surface);
void platform_destroy_surface(void* instance, void* allocator, PlatformSurface* surface);

// String utilities
char* platform_strdup(const char* src);
void platform_strncpy(char* dest, const char* src, size_t count);

// File utilities
#include <stdio.h>
FILE* platform_fopen(const char* filename, const char* mode);

#endif // PLATFORM_H


==================================================
FILE START: src/foundation/string/string_id.c
==================================================
#include "string_id.h"

#define FNV1A_OFFSET_32 2166136261u
#define FNV1A_PRIME_32 16777619u

// --- Debug String Registry ---
#ifndef NDEBUG
#include <stdlib.h>
#include <string.h>
#include <stdatomic.h>

typedef struct StringEntry {
    StringId id;
    char* str;
    struct StringEntry* next;
} StringEntry;

#define BUCKET_COUNT 4096
static StringEntry* g_buckets[BUCKET_COUNT] = {0};
static atomic_flag g_lock = ATOMIC_FLAG_INIT;

static void registry_add(StringId id, const char* str) {
    if (!str) return;

    size_t index = id % BUCKET_COUNT;

    // Spinlock
    while (atomic_flag_test_and_set(&g_lock)) {
        // busy wait
    }

    // Check if exists
    StringEntry* entry = g_buckets[index];
    while (entry) {
        if (entry->id == id) {
            atomic_flag_clear(&g_lock);
            return; // Already registered
        }
        entry = entry->next;
    }

    // Add new
    StringEntry* new_entry = (StringEntry*)malloc(sizeof(StringEntry));
    if (new_entry) {
        new_entry->id = id;
        new_entry->str =
#ifdef _WIN32
            _strdup(str);
#else
            strdup(str);
#endif
        new_entry->next = g_buckets[index];
        g_buckets[index] = new_entry;
    }

    atomic_flag_clear(&g_lock);
}

const char* str_id_lookup(StringId id) {
    size_t index = id % BUCKET_COUNT;

    // Spinlock for read safety
    while (atomic_flag_test_and_set(&g_lock)) {}

    StringEntry* entry = g_buckets[index];
    while (entry) {
        if (entry->id == id) {
            atomic_flag_clear(&g_lock);
            return entry->str;
        }
        entry = entry->next;
    }

    atomic_flag_clear(&g_lock);
    return "<UNKNOWN>";
}
#endif

StringId str_id(const char* str) {
    if (!str) return 0;
    
    StringId hash = FNV1A_OFFSET_32;
    const char* ptr = str;
    while (*ptr) {
        hash ^= (StringId)(*ptr++);
        hash *= FNV1A_PRIME_32;
    }

#ifndef NDEBUG
    registry_add(hash, str);
#endif

    return hash;
}


==================================================
FILE START: src/foundation/string/string_id.h
==================================================
#ifndef STRING_ID_H
#define STRING_ID_H

#include <stdint.h>

typedef uint32_t StringId;

// FNV-1a Hash
StringId str_id(const char* str);

#ifndef NDEBUG
/**
 * @brief (Debug Only) Retrieves the original string for a given StringId.
 * @param id The hash to look up.
 * @return The original string, or "<UNKNOWN>" if not found.
 */
const char* str_id_lookup(StringId id);
#endif

#endif // STRING_ID_H


==================================================
FILE START: src/foundation/thread/thread.c
==================================================
#if !defined(_WIN32) && !defined(_POSIX_C_SOURCE)
#define _POSIX_C_SOURCE 200809L // NOLINT(bugprone-reserved-identifier)
#endif

#include "thread.h"
#include <stdlib.h>
#include <stdint.h>

#ifdef _WIN32
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include <process.h>

    struct Mutex {
        SRWLOCK handle;
    };

    struct Thread {
        HANDLE handle;
        unsigned int id;
        int exit_code; // To store result if needed, though GetExitCodeThread works too
    };

    Mutex* mutex_create(void) {
        Mutex* m = (Mutex*)malloc(sizeof(Mutex));
        if (m) {
            InitializeSRWLock(&m->handle);
        }
        return m;
    }

    void mutex_destroy(Mutex* mutex) {
        if (mutex) {
            // SRW locks don't need explicit destruction in Win32
            free(mutex);
        }
    }

    void mutex_lock(Mutex* mutex) {
        if (mutex) {
            AcquireSRWLockExclusive(&mutex->handle);
        }
    }

    void mutex_unlock(Mutex* mutex) {
        if (mutex) {
            ReleaseSRWLockExclusive(&mutex->handle);
        }
    }

    // Thread wrapper to match signature
    typedef struct {
        ThreadFunction func;
        void* arg;
        Thread* thread_struct; // Back pointer if needed? Not strictly for now.
    } ThreadStartInfo;

    static unsigned __stdcall win32_thread_entry(void* arg) {
        ThreadStartInfo* info = (ThreadStartInfo*)arg;
        int result = info->func(info->arg);
        free(info);
        return (unsigned)result;
    }

    Thread* thread_create(ThreadFunction func, void* arg) {
        Thread* t = (Thread*)malloc(sizeof(Thread));
        if (!t) return NULL;

        ThreadStartInfo* info = (ThreadStartInfo*)malloc(sizeof(ThreadStartInfo));
        if (!info) {
            free(t);
            return NULL;
        }
        info->func = func;
        info->arg = arg;
        
        uintptr_t handle = _beginthreadex(NULL, 0, win32_thread_entry, info, 0, &t->id);
        if (handle == 0) {
            free(info);
            free(t);
            return NULL;
        }

        t->handle = (HANDLE)handle;
        return t;
    }

    void thread_detach(Thread* thread) {
        if (thread) {
            CloseHandle(thread->handle);
            free(thread);
        }
    }

    int thread_join(Thread* thread) {
        if (!thread) return 0;
        
        WaitForSingleObject(thread->handle, INFINITE);
        
        DWORD exit_code = 0;
        GetExitCodeThread(thread->handle, &exit_code);
        
        CloseHandle(thread->handle);
        free(thread);
        
        return (int)exit_code;
    }

    void thread_sleep(unsigned int milliseconds) {
        Sleep(milliseconds);
    }

    unsigned int thread_hardware_concurrency(void) {
        SYSTEM_INFO sysinfo;
        GetSystemInfo(&sysinfo);
        return sysinfo.dwNumberOfProcessors;
    }

#else
    #include <pthread.h>
    #include <unistd.h>
    #include <time.h>

    struct Mutex {
        pthread_mutex_t handle;
    };

    struct Thread {
        pthread_t handle;
    };

    // Pthread wrapper
    typedef struct {
        ThreadFunction func;
        void* arg;
    } ThreadStartInfo;

    static void* pthread_thread_entry(void* arg) {
        ThreadStartInfo* info = (ThreadStartInfo*)arg;
        ThreadFunction func = info->func;
        void* user_arg = info->arg;
        free(info);
        
        intptr_t result = func(user_arg);
        return (void*)result; // NOLINT(performance-no-int-to-ptr)
    }

    Mutex* mutex_create(void) {
        Mutex* m = (Mutex*)malloc(sizeof(Mutex));
        if (m) {
            pthread_mutex_init(&m->handle, NULL);
        }
        return m;
    }

    void mutex_destroy(Mutex* mutex) {
        if (mutex) {
            pthread_mutex_destroy(&mutex->handle);
            free(mutex);
        }
    }

    void mutex_lock(Mutex* mutex) {
        if (mutex) {
            pthread_mutex_lock(&mutex->handle);
        }
    }

    void mutex_unlock(Mutex* mutex) {
        if (mutex) {
            pthread_mutex_unlock(&mutex->handle);
        }
    }

    Thread* thread_create(ThreadFunction func, void* arg) {
        Thread* t = (Thread*)malloc(sizeof(Thread));
        if (!t) return NULL;

        ThreadStartInfo* info = (ThreadStartInfo*)malloc(sizeof(ThreadStartInfo));
        if (!info) {
            free(t);
            return NULL;
        }
        info->func = func;
        info->arg = arg;

        if (pthread_create(&t->handle, NULL, pthread_thread_entry, info) != 0) {
            free(info);
            free(t);
            return NULL;
        }

        return t;
    }

    void thread_detach(Thread* thread) {
        if (thread) {
            pthread_detach(thread->handle);
            free(thread);
        }
    }

    int thread_join(Thread* thread) {
        if (!thread) return 0;
        
        void* result = NULL;
        pthread_join(thread->handle, &result);
        
        free(thread);
        return (int)(intptr_t)result; // NOLINT(performance-no-int-to-ptr)
    }

    void thread_sleep(unsigned int milliseconds) {
        struct timespec ts;
        ts.tv_sec = milliseconds / 1000;
        ts.tv_nsec = (long)(milliseconds % 1000) * 1000000;
        nanosleep(&ts, NULL);
    }

    unsigned int thread_hardware_concurrency(void) {
        long nprocs = -1;
        #ifdef _SC_NPROCESSORS_ONLN
            nprocs = sysconf(_SC_NPROCESSORS_ONLN);
        #endif
        if (nprocs < 1) return 1;
        return (unsigned int)nprocs;
    }

#endif



==================================================
FILE START: src/foundation/thread/thread.h
==================================================
#ifndef THREAD_H
#define THREAD_H

#include <stdbool.h>

// Opaque handles
typedef struct Mutex Mutex;
typedef struct Thread Thread;

// --- Mutex ---
/**
 * @brief Creates a new mutex.
 * @return Pointer to the mutex, or NULL on failure.
 */
Mutex* mutex_create(void);

/**
 * @brief Destroys a mutex.
 * @param mutex The mutex to destroy.
 */
void mutex_destroy(Mutex* mutex);

/**
 * @brief Locks the mutex. Blocks until the lock is acquired.
 * @param mutex The mutex to lock.
 */
void mutex_lock(Mutex* mutex);

/**
 * @brief Unlocks the mutex.
 * @param mutex The mutex to unlock.
 */
void mutex_unlock(Mutex* mutex);

// --- Thread ---
typedef int (*ThreadFunction)(void* arg);

/**
 * @brief Creates and starts a new thread.
 * @param func The function to execute.
 * @param arg Argument to pass to the function.
 * @return Pointer to the thread, or NULL on failure.
 */
Thread* thread_create(ThreadFunction func, void* arg);

/**
 * @brief Detaches the thread, allowing it to run independently. 
 * Resources are released automatically when it exits.
 * @param thread The thread to detach.
 */
void thread_detach(Thread* thread);

/**
 * @brief Joins the thread, blocking until it exits.
 * @param thread The thread to join.
 * @return The exit code of the thread function.
 */
int thread_join(Thread* thread);

/**
 * @brief Sleeps the current thread.
 * @param milliseconds Time to sleep in milliseconds.
 */
void thread_sleep(unsigned int milliseconds);

/**
 * @brief Returns the number of concurrent threads supported by hardware.
 * @return Number of threads (e.g., cores).
 */
unsigned int thread_hardware_concurrency(void);

#endif // THREAD_H


==================================================
FILE START: tests/config_tests.c
==================================================
#include "test_framework.h"
#include "foundation/config/config_system.h"
#include "foundation/config/simple_yaml.h"
#include "foundation/memory/arena.h"
#include "foundation/meta/reflection.h"
#include "foundation/math/math_types.h"
#include "foundation/string/string_id.h"

// --- Mock Data ---

typedef struct TestNode {
    int id;
    float value;
    char* name;
    struct TestNode** children;
    size_t child_count;
} TestNode;

typedef struct TestColor {
    Vec4 color;
} TestColor;

static MetaField test_node_fields[] = {
    { "id", META_TYPE_INT, offsetof(TestNode, id), "int" },
    { "value", META_TYPE_FLOAT, offsetof(TestNode, value), "float" },
    { "name", META_TYPE_STRING, offsetof(TestNode, name), "string" },
    { "children", META_TYPE_POINTER_ARRAY, offsetof(TestNode, children), "TestNode" },
    { "child_count", META_TYPE_INT, offsetof(TestNode, child_count), "int" },
};

static MetaStruct test_node_meta = {
    "TestNode",
    sizeof(TestNode),
    test_node_fields,
    5
};

static MetaField test_color_fields[] = {
    { "color", META_TYPE_VEC4, offsetof(TestColor, color), "Vec4" },
};

static MetaStruct test_color_meta = {
    "TestColor",
    sizeof(TestColor),
    test_color_fields,
    1
};

// --- Mock Registry ---

const MetaStruct* meta_get_struct(const char* name) {
    if (strcmp(name, "TestNode") == 0) return &test_node_meta;
    if (strcmp(name, "TestColor") == 0) return &test_color_meta;
    return NULL;
}

const MetaEnum* meta_get_enum(const char* name) {
    (void)name;
    return NULL;
}

bool meta_enum_get_value(const MetaEnum* meta_enum, const char* name_str, int* out_value) {
    (void)meta_enum;
    (void)name_str;
    (void)out_value;
    return false;
}

// --- Tests ---

int test_simple_struct(void) {
    MemoryArena arena;
    arena_init(&arena, 1024);

    const char* yaml = 
        "id: 42\n"
        "value: 3.14\n"
        "name: \"Hello\"\n";
    
    ConfigNode* root;
    ConfigError err;
    int res = simple_yaml_parse(&arena, yaml, &root, &err);
    TEST_ASSERT(res);

    TestNode node = {0};
    bool ok = config_load_struct(root, &test_node_meta, &node, &arena);
    
    TEST_ASSERT(ok);
    ASSERT_EQ_INT(42, node.id);
    ASSERT_EQ_FLOAT(3.14f, node.value, 0.001f);
    ASSERT_STR_EQ("Hello", node.name);

    arena_destroy(&arena);
    return 1;
}

int test_nested_array(void) {
    MemoryArena arena;
    arena_init(&arena, 4096);

    const char* yaml = 
        "id: 1\n"
        "name: \"Root\"\n"
        "children:\n"
        "  - id: 2\n"
        "    name: \"Child A\"\n"
        "  - id: 3\n"
        "    name: \"Child B\"\n";
    
    ConfigNode* root;
    ConfigError err;
    int res = simple_yaml_parse(&arena, yaml, &root, &err);
    TEST_ASSERT(res);

    TestNode node = {0};
    bool ok = config_load_struct(root, &test_node_meta, &node, &arena);
    
    TEST_ASSERT(ok);
    ASSERT_EQ_INT(1, node.id);
    ASSERT_STR_EQ("Root", node.name);
    
    TEST_ASSERT(node.child_count == 2);
    TEST_ASSERT(node.children != NULL);
    
    TestNode* c1 = node.children[0];
    TestNode* c2 = node.children[1];
    
    TEST_ASSERT(c1 != NULL);
    TEST_ASSERT(c2 != NULL);
    
    ASSERT_EQ_INT(2, c1->id);
    ASSERT_STR_EQ("Child A", c1->name);
    
    ASSERT_EQ_INT(3, c2->id);
    ASSERT_STR_EQ("Child B", c2->name);

    arena_destroy(&arena);
    return 1;
}

int test_hex_color(void) {
    MemoryArena arena;
    arena_init(&arena, 1024);

    const char* yaml = "color: \"#FF0000FF\"\n"; // Red fully opaque
    
    ConfigNode* root;
    ConfigError err;
    int res = simple_yaml_parse(&arena, yaml, &root, &err);
    TEST_ASSERT(res);

    TestColor obj = {0};
    bool ok = config_load_struct(root, &test_color_meta, &obj, &arena);
    
    TEST_ASSERT(ok);
    // x=r, y=g, z=b, w=a
    ASSERT_EQ_FLOAT(1.0f, obj.color.x, 0.001f);
    ASSERT_EQ_FLOAT(0.0f, obj.color.y, 0.001f);
    ASSERT_EQ_FLOAT(0.0f, obj.color.z, 0.001f);
    ASSERT_EQ_FLOAT(1.0f, obj.color.w, 0.001f);

    arena_destroy(&arena);
    return 1;
}

int main(void) {
    TEST_INIT("Config Deserializer");
    TEST_RUN(test_simple_struct);
    TEST_RUN(test_nested_array);
    TEST_RUN(test_hex_color);
    TEST_REPORT();
}


==================================================
FILE START: tests/memory_tests.c
==================================================
#include "test_framework.h"
#include "foundation/memory/arena.h"
#include <string.h>

int test_arena_init_destroy(void) {
    MemoryArena arena;
    bool result = arena_init(&arena, 1024);
    ASSERT_TRUE(result);
    ASSERT_TRUE(arena.base != NULL);
    ASSERT_EQ_INT(arena.size, 1024);
    ASSERT_EQ_INT(arena.offset, 0);
    
    arena_destroy(&arena);
    ASSERT_TRUE(arena.base == NULL);
    ASSERT_EQ_INT(arena.size, 0);
    return 1;
}

int test_arena_alloc(void) {
    MemoryArena arena;
    arena_init(&arena, 128);

    void* p1 = arena_alloc(&arena, 64);
    ASSERT_TRUE(p1 != NULL);
    ASSERT_EQ_INT(arena.offset, 64);

    void* p2 = arena_alloc(&arena, 64);
    ASSERT_TRUE(p2 != NULL);
    ASSERT_EQ_INT(arena.offset, 128);

    // Should fail (OOM)
    void* p3 = arena_alloc(&arena, 1);
    ASSERT_TRUE(p3 == NULL);
    ASSERT_EQ_INT(arena.offset, 128);

    arena_destroy(&arena);
    return 1;
}

int test_arena_alloc_zero(void) {
    MemoryArena arena;
    arena_init(&arena, 128);

    int* ints = (int*)arena_alloc_zero(&arena, sizeof(int) * 10);
    for (int i = 0; i < 10; ++i) {
        ASSERT_EQ_INT(ints[i], 0);
    }

    arena_destroy(&arena);
    return 1;
}

int test_arena_reset(void) {
    MemoryArena arena;
    arena_init(&arena, 128);

    arena_alloc(&arena, 64);
    ASSERT_EQ_INT(arena.offset, 64);

    arena_reset(&arena);
    ASSERT_EQ_INT(arena.offset, 0);
    
    // Memory is still valid to alloc again
    void* p = arena_alloc(&arena, 128);
    ASSERT_TRUE(p != NULL);

    arena_destroy(&arena);
    return 1;
}

int test_arena_strings(void) {
    MemoryArena arena;
    arena_init(&arena, 256);

    const char* str = "Hello World";
    char* pushed = arena_push_string(&arena, str);
    ASSERT_TRUE(strcmp(pushed, str) == 0);
    ASSERT_EQ_INT(arena.offset, strlen(str) + 1);

    char* formatted = arena_sprintf(&arena, "Val: %d", 42);
    ASSERT_TRUE(strcmp(formatted, "Val: 42") == 0);

    arena_destroy(&arena);
    return 1;
}

int main(void) {
    TEST_INIT("Foundation Memory");
    
    TEST_RUN(test_arena_init_destroy);
    TEST_RUN(test_arena_alloc);
    TEST_RUN(test_arena_alloc_zero);
    TEST_RUN(test_arena_reset);
    TEST_RUN(test_arena_strings);
    
    TEST_REPORT();
    return 0;
}


==================================================
FILE START: tests/string_tests.c
==================================================
#include "test_framework.h"
#include "foundation/string/string_id.h"
#include <string.h>

int test_string_id_hash(void) {
    StringId id1 = str_id("test_string");
    StringId id2 = str_id("test_string");
    StringId id3 = str_id("other_string");

    ASSERT_TRUE(id1 == id2);
    ASSERT_TRUE(id1 != id3);
    return 1;
}

int test_string_id_lookup(void) {
#ifndef NDEBUG
    // Lookup only works in Debug builds where the registry is active
    const char* original = "lookup_test";
    StringId id = str_id(original);
    
    const char* recovered = str_id_lookup(id);
    ASSERT_TRUE(strcmp(recovered, original) == 0);

    StringId unknown = 123456; // Random unlikely ID
    // Assuming 123456 hasn't been hashed. If it has, this test is flaky.
    // Ideally we'd use a known unused ID or mock the registry.
    // For now, let's just check it doesn't crash.
    const char* recovered_unknown = str_id_lookup(unknown);
    ASSERT_TRUE(recovered_unknown != NULL); 
#endif
    return 1;
}

int main(void) {
    TEST_INIT("Foundation String");
    
    TEST_RUN(test_string_id_hash);
    TEST_RUN(test_string_id_lookup);
    
    TEST_REPORT();
    return 0;
}


==================================================
FILE START: tests/test_framework.h
==================================================
#ifndef TEST_FRAMEWORK_H
#define TEST_FRAMEWORK_H

#include <stdio.h>
#include <math.h>
#include <string.h>
#include <stdlib.h>

/* Colors for output */
#define TERM_RED     "\033[31m"
#define TERM_GREEN   "\033[32m"
#define TERM_RESET   "\033[0m"

static int g_tests_run = 0;
static int g_tests_failed = 0;

#define RUN_TEST(func) \
    do { \
        printf("[ RUN      ] %s\n", #func); \
        g_tests_run++; \
        if (func()) { \
            printf(TERM_GREEN "[       OK ]" TERM_RESET " %s\n", #func); \
        } else { \
            printf(TERM_RED   "[  FAILED  ]" TERM_RESET " %s\n", #func); \
            g_tests_failed++; \
        } \
    } while (0)

/* Assertions that return 0 on failure */

#define TEST_ASSERT(cond) \
    do { \
        if (!(cond)) { \
            fprintf(stderr, TERM_RED "  Assertion failed: %s:%d\n    Condition: %s\n" TERM_RESET, __FILE__, __LINE__, #cond); \
            return 0; \
        } \
    } while(0)

#define TEST_ASSERT_INT_EQ(expected, actual) \
    do { \
        int _e = (int)(expected); \
        int _a = (int)(actual); \
        if (_e != _a) { \
            fprintf(stderr, TERM_RED "  Assertion failed: %s:%d\n    Expected: %d\n    Actual:   %d\n" TERM_RESET, __FILE__, __LINE__, _e, _a); \
            return 0; \
        } \
    } while(0)

#define TEST_ASSERT_FLOAT_EQ(expected, actual, epsilon) \
    do { \
        float _e = (float)(expected); \
        float _a = (float)(actual); \
        if (fabsf(_e - _a) > (float)(epsilon)) { \
            fprintf(stderr, TERM_RED "  Assertion failed: %s:%d\n    Expected: %f\n    Actual:   %f\n    Diff:     %f\n" TERM_RESET, __FILE__, __LINE__, _e, _a, fabsf(_e - _a)); \
            return 0; \
        } \
    } while(0)

#define TEST_ASSERT_STR_EQ(expected, actual) \
    do { \
        const char* _e = (expected); \
        const char* _a = (actual); \
        if (strcmp(_e, _a) != 0) { \
            fprintf(stderr, TERM_RED "  Assertion failed: %s:%d\n    Expected: \"%s\"\n    Actual:   \"%s\"\n" TERM_RESET, __FILE__, __LINE__, _e, _a); \
            return 0; \
        } \
    } while(0)

/* Aliases and Test Runner Helpers */
#define ASSERT_TRUE(cond) TEST_ASSERT(cond)
#define ASSERT_EQ_INT(e, a) TEST_ASSERT_INT_EQ(e, a)
#define ASSERT_EQ_FLOAT(e, a, eps) TEST_ASSERT_FLOAT_EQ(e, a, eps)
#define ASSERT_STR_EQ(e, a) TEST_ASSERT_STR_EQ(e, a)

#define TEST_INIT(name) printf("Running Test Suite: " name "\n")
#define TEST_RUN(func) RUN_TEST(func)
#define TEST_REPORT() do { \
    printf("--------------------------------------------------\n"); \
    printf("Tests Run: %d, Failed: %d\n", g_tests_run, g_tests_failed); \
    if (g_tests_failed > 0) { \
        printf(TERM_RED "SOME TESTS FAILED\n" TERM_RESET); \
        return 1; \
    } else { \
        printf(TERM_GREEN "ALL TESTS PASSED\n" TERM_RESET); \
        return 0; \
    } \
} while(0)

#endif // TEST_FRAMEWORK_H


==================================================
FILE START: tests/transform_tests.c
==================================================
#include <math.h>
#include <stdio.h>

#include "test_framework.h"

#include "foundation/math/coordinate_systems.h"

static int test_coordinate_round_trip(void) {
    CoordinateSystem2D system;
    coordinate_system2d_init(&system, 2.0f, 1.5f, (Vec2){300.0f, 200.0f});

    Vec2 world = {10.0f, 20.0f};
    Vec2 logical = coordinate_world_to_logical(&system, world);
    Vec2 screen = coordinate_world_to_screen(&system, world);

    TEST_ASSERT_FLOAT_EQ(15.0f, logical.x, 0.0001f);
    TEST_ASSERT_FLOAT_EQ(30.0f, logical.y, 0.0001f);
    TEST_ASSERT_FLOAT_EQ(30.0f, screen.x, 0.0001f);
    TEST_ASSERT_FLOAT_EQ(60.0f, screen.y, 0.0001f);

    Vec2 roundtrip_world = coordinate_screen_to_world(&system, screen);
    TEST_ASSERT_FLOAT_EQ(world.x, roundtrip_world.x, 0.0001f);
    TEST_ASSERT_FLOAT_EQ(world.y, roundtrip_world.y, 0.0001f);

    return 1;
}

static int test_local_to_world(void) {
    Transform2D local = {
        .translation = {2.0f, -1.0f},
        .rotation_radians = 0.25f,
        .scale = {2.0f, 0.5f},
    };
    Vec2 local_point = {1.0f, 1.0f};
    Vec2 world = coordinate_local_to_world_2d(&local, local_point);
    Vec2 back = coordinate_world_to_local_2d(&local, world);
    TEST_ASSERT_FLOAT_EQ(local_point.x, back.x, 0.0001f);
    TEST_ASSERT_FLOAT_EQ(local_point.y, back.y, 0.0001f);
    return 1;
}

static int test_3d_projection(void) {
    Transform3D local = {
        .translation = {1.0f, 2.0f, -3.0f},
        .scale = {1.0f, 2.0f, 1.0f},
        .rotation = quat_from_euler((EulerAngles){0.0f, 0.25f, 0.0f}),
    };
    Vec3 local_point = {0.5f, -0.25f, 1.0f};
    Vec3 world = coordinate_local_to_world_3d(&local, local_point);
    Vec3 back = coordinate_world_to_local_3d(&local, world);
    TEST_ASSERT_FLOAT_EQ(local_point.x, back.x, 0.0001f);
    TEST_ASSERT_FLOAT_EQ(local_point.y, back.y, 0.0001f);
    TEST_ASSERT_FLOAT_EQ(local_point.z, back.z, 0.0001f);

    Mat4 view = mat4_identity();
    Mat4 projection = mat4_orthographic(-2.0f, 2.0f, -2.0f, 2.0f, 0.1f, 10.0f);
    Projection3D clipper;
    projection3d_init(&clipper, &view, &projection);
    Vec3 clip = coordinate_world_to_clip(&clipper, world);
    Vec3 restored = coordinate_clip_to_world(&clipper, clip);
    TEST_ASSERT_FLOAT_EQ(world.x, restored.x, 0.0001f);
    TEST_ASSERT_FLOAT_EQ(world.y, restored.y, 0.0001f);
    TEST_ASSERT_FLOAT_EQ(world.z, restored.z, 0.0001f);
    return 1;
}

int main(void) {
    RUN_TEST(test_coordinate_round_trip);
    RUN_TEST(test_local_to_world);
    RUN_TEST(test_3d_projection);
    
    printf("Tests Run: %d, Failed: %d\n", g_tests_run, g_tests_failed);
    return g_tests_failed > 0 ? 1 : 0;
}


==================================================
FILE START: tests/transpiler_tests.c
==================================================
#include "test_framework.h"
#include "features/math_engine/math_graph.h"
#include "features/math_engine/internal/transpiler.h"
#include "foundation/memory/arena.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int test_transpiler_simple_add(void) {
    MemoryArena arena;
    arena_init(&arena, 1024 * 1024);
    
    MathGraph* graph = math_graph_create(&arena);
    TEST_ASSERT(graph != NULL);
    
    // Create nodes: 3.0 + 5.0
    MathNodeId id1 = math_graph_add_node(graph, MATH_NODE_VALUE);
    math_graph_set_value(graph, id1, 3.0f);
    
    MathNodeId id2 = math_graph_add_node(graph, MATH_NODE_VALUE);
    math_graph_set_value(graph, id2, 5.0f);
    
    MathNodeId id_add = math_graph_add_node(graph, MATH_NODE_ADD);
    
    math_graph_connect(graph, id_add, 0, id1);
    math_graph_connect(graph, id_add, 1, id2);
    
    // Transpile
    char* glsl = math_graph_transpile(graph, TRANSPILE_MODE_BUFFER_1D, SHADER_TARGET_GLSL_VULKAN);
    TEST_ASSERT(glsl != NULL);
    
    printf("\n--- Generated GLSL ---\n%s\n----------------------\n", glsl);
    
    // Basic checks
    char buf[128];
    snprintf(buf, 128, "float v_%d = 3.000000;", id1);
    TEST_ASSERT(strstr(glsl, buf) != NULL);
    
    snprintf(buf, 128, "float v_%d = 5.000000;", id2);
    TEST_ASSERT(strstr(glsl, buf) != NULL);
    
    snprintf(buf, 128, "float v_%d = v_%d + v_%d;", id_add, id1, id2);
    TEST_ASSERT(strstr(glsl, buf) != NULL);
    
    snprintf(buf, 128, "b_out.result = v_%d;", id_add);
    TEST_ASSERT(strstr(glsl, buf) != NULL);
    
    free(glsl);
    
    math_graph_destroy(graph);
    arena_destroy(&arena);
    return 1;
}

int main(void) {
    printf("Running Transpiler Tests...\n");
    RUN_TEST(test_transpiler_simple_add);
    
    if (g_tests_failed > 0) {
        printf(TERM_RED "\n%d tests failed!\n" TERM_RESET, g_tests_failed);
        return 1;
    } else {
        printf(TERM_GREEN "\nAll tests passed!\n" TERM_RESET);
        return 0;
    }
}


==================================================
FILE START: tests/ui_tests.c
==================================================
#include "test_framework.h"
#include "engine/ui/internal/ui_internal.h"
#include "foundation/memory/arena.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// --- Helper: Build Def Tree first ---
static SceneNodeSpec* create_node(SceneAsset* asset, SceneLayoutStrategy layout, float w, float h, const char* id) {
    SceneNodeSpec* spec = scene_asset_push_node(asset);
    if (!spec) return NULL;
    spec->layout.type = layout;
    spec->layout.width = w;
    spec->layout.height = h;
    spec->id = str_id(id ? id : "node");
    return spec;
}

static void add_child_spec(SceneAsset* asset, SceneNodeSpec* parent, SceneNodeSpec* child) {
    parent->child_count++;
    SceneNodeSpec** new_children = (SceneNodeSpec**)arena_alloc(&asset->arena, parent->child_count * sizeof(SceneNodeSpec*));
    if (parent->children) {
        memcpy((void*)new_children, (const void*)parent->children, (parent->child_count - 1) * sizeof(SceneNodeSpec*));
    }
    new_children[parent->child_count - 1] = child;
    parent->children = new_children;
}

// --- TESTS ---

int test_column_layout(void) {
    SceneAsset* asset = scene_asset_create(4096);

    SceneNodeSpec* root = create_node(asset, SCENE_LAYOUT_FLEX_COLUMN, 100.0f, 200.0f, "root");
    root->layout.spacing = 10.0f;
    root->layout.padding = 5.0f;
    
    SceneNodeSpec* c1 = create_node(asset, SCENE_LAYOUT_FLEX_COLUMN, 50.0f, 50.0f, "c1");
    SceneNodeSpec* c2 = create_node(asset, SCENE_LAYOUT_FLEX_COLUMN, 50.0f, 50.0f, "c2");
    
    add_child_spec(asset, root, c1);
    add_child_spec(asset, root, c2);
    
    SceneTree* instance = scene_tree_create(asset, 4096);

    SceneNode* el = scene_node_create(instance, root, NULL, NULL);
    instance->root = el;
    ui_system_layout(instance, 800, 600, 0, NULL, NULL);

    TEST_ASSERT_FLOAT_EQ(el->rect.w, 100.0f, 0.1f);
    TEST_ASSERT_FLOAT_EQ(el->rect.h, 200.0f, 0.1f);

    SceneNode* v1 = el->first_child;
    SceneNode* v2 = el->first_child->next_sibling;

    TEST_ASSERT_FLOAT_EQ(v1->rect.x, 5.0f, 0.1f);
    TEST_ASSERT_FLOAT_EQ(v1->rect.y, 5.0f, 0.1f);
    
    TEST_ASSERT_FLOAT_EQ(v2->rect.x, 5.0f, 0.1f);
    TEST_ASSERT_FLOAT_EQ(v2->rect.y, 65.0f, 0.1f);

    scene_tree_destroy(instance);
    scene_asset_destroy(asset);
    return 1;
}

int main(void) {
    printf("--- Running UI Tests ---\n");
    RUN_TEST(test_column_layout);
    
    if (g_tests_failed > 0) {
        printf(TERM_RED "\n%dTESTS FAILED\n" TERM_RESET, g_tests_failed);
        return 1;
    }
    printf(TERM_GREEN "\nALL TESTS PASSED\n" TERM_RESET);
    return 0;
}


==================================================
FILE START: tools/build_shaders.py
==================================================
import os
import subprocess
import sys
import platform
import shutil

def find_glslc():
    # 1. Check VULKAN_SDK environment variable
    sdk_path = os.environ.get("VULKAN_SDK")
    exe_name = "glslc.exe" if platform.system() == "Windows" else "glslc"

    if sdk_path:
        # Check standard layout
        candidate = os.path.join(sdk_path, "bin", exe_name)
        if os.path.exists(candidate):
            return candidate
        
        # Check Windows layout (sometimes Bin is capitalized)
        candidate = os.path.join(sdk_path, "Bin", exe_name)
        if os.path.exists(candidate):
            return candidate

    # 2. Check PATH
    if shutil.which("glslc"):
        return "glslc"

    return None

def main():
    root_dir = os.getcwd()
    # Ensure we are in the project root
    if not os.path.exists(os.path.join(root_dir, "assets")):
        # Try to find it relative to the script if run from tools/
        script_dir = os.path.dirname(os.path.abspath(__file__))
        potential_root = os.path.dirname(script_dir)
        if os.path.exists(os.path.join(potential_root, "assets")):
            root_dir = potential_root
            os.chdir(root_dir)
    
    shader_dir = os.path.join(root_dir, "assets", "shaders")
    if not os.path.exists(shader_dir):
        print(f"Warning: Shader directory not found at {shader_dir}")
        return

    glslc = find_glslc()
    if not glslc:
        print("Error: 'glslc' not found. Please install the Vulkan SDK and ensure VULKAN_SDK is set or glslc is in PATH.")
        sys.exit(1)

    print(f"Using shader compiler: {glslc}")

    extensions = {".vert", ".frag", ".comp"}
    count = 0

    for root, dirs, files in os.walk(shader_dir):
        for file in files:
            base, ext = os.path.splitext(file)
            if ext in extensions:
                input_path = os.path.join(root, file)
                output_path = input_path + ".spv"
                
                # Incremental Check
                should_compile = True
                if os.path.exists(output_path):
                    src_mtime = os.path.getmtime(input_path)
                    dst_mtime = os.path.getmtime(output_path)
                    if src_mtime <= dst_mtime:
                        should_compile = False
                
                if should_compile:
                    print(f"[Shader] Compiling {file} -> {file}.spv")
                    cmd = [glslc, input_path, "-o", output_path]
                    res = subprocess.run(cmd)
                    if res.returncode != 0:
                        print(f"Error compiling {file}")
                        sys.exit(1)
                    count += 1
                
    if count == 0:
        print("Shaders are up to date.")
    else:
        print(f"Compiled {count} shaders.")

if __name__ == "__main__":
    main()


==================================================
FILE START: tools/codegen.py
==================================================
import os
import re
import sys

# Regex Patterns
ENUM_PATTERN = re.compile(r'typedef\s+enum\s*\w*\s*\{([^}]*)\}\s*(\w+);\s*//\s*REFLECT', re.MULTILINE | re.DOTALL)
STRUCT_PATTERN = re.compile(r'(typedef\s+)?struct\s*(\w*)\s*\{([^}]*)\}\s*(\w+)?\s*;', re.MULTILINE | re.DOTALL)
REFLECT_PATTERN = re.compile(r'^\s*(.+?);\s*//\s*REFLECT(.*)', re.MULTILINE)

BASE_TYPES = {
    'int': 'META_TYPE_INT',
    'float': 'META_TYPE_FLOAT',
    'bool': 'META_TYPE_BOOL',
    'char*': 'META_TYPE_STRING',
    'const char*': 'META_TYPE_STRING',
    'size_t': 'META_TYPE_INT',
    'uint32_t': 'META_TYPE_INT',
    'int32_t': 'META_TYPE_INT',
    'uint8_t': 'META_TYPE_INT',
    'int8_t': 'META_TYPE_INT',
    'uint16_t': 'META_TYPE_INT',
    'int16_t': 'META_TYPE_INT',
    'uint64_t': 'META_TYPE_INT',
    'int64_t': 'META_TYPE_INT',
    'f32': 'META_TYPE_FLOAT',
    'f64': 'META_TYPE_FLOAT',
    'b8': 'META_TYPE_BOOL',
    'b32': 'META_TYPE_BOOL',
    'StringId': 'META_TYPE_STRING_ID',
    'Vec2': 'META_TYPE_VEC2',
    'Vec3': 'META_TYPE_VEC3',
    'Vec4': 'META_TYPE_VEC4',
}

def parse_enum_body(body_text):
    entries = []
    lines = body_text.split('\n')
    clean_text = ""
    for line in lines:
        if '//' in line:
            line = line.split('//')[0]
        clean_text += line + " "
    
    parts = clean_text.split(',')
    for part in parts:
        part = part.strip()
        if not part: continue
        if '=' in part:
            name = part.split('=')[0].strip()
        else:
            name = part
        if name:
            entries.append(name)
    return entries

def parse_struct_field(decl_str):
    decl_str = decl_str.strip()
    is_array = False
    if ']' in decl_str:
        match = re.search(r'\[(.*?)\]', decl_str)
        if match:
            is_array = True
            decl_str = re.sub(r'\[.*?\]', '', decl_str).strip()

    ptr_count = decl_str.count('*')
    is_pointer = ptr_count > 0
    clean_decl = decl_str.replace('*', ' ').strip()
    
    tokens = clean_decl.split()
    if not tokens:
        return None
        
    var_name = tokens[-1]
    type_tokens = tokens[:-1]
    type_name = " ".join(type_tokens)
    
    full_type_str = type_name
    if ptr_count > 0:
        full_type_str += "*" * ptr_count

    return {
        'name': var_name,
        'type': full_type_str,
        'base_type': type_name,
        'is_pointer': is_pointer,
        'ptr_count': ptr_count,
        'is_array': is_array
    }

def scan_files(src_dir):
    enums = {}
    structs = {}
    headers = []
    
    for root, _, files in os.walk(src_dir):
        root = root.replace('\\', '/')
        if 'backend' in root or 'generated' in root:
            continue

        for file in files:
            if file.endswith('.h'):
                path = os.path.join(root, file).replace('\\', '/')
                with open(path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                has_reflection = False

                for match in ENUM_PATTERN.finditer(content):
                    body = match.group(1)
                    name = match.group(2)
                    values = parse_enum_body(body)
                    if values:
                        enums[name] = values
                        has_reflection = True

                for match in STRUCT_PATTERN.finditer(content):
                    name_tag = match.group(2)
                    body = match.group(3)
                    name_typedef = match.group(4)
                    
                    name = name_typedef if name_typedef else name_tag
                    if not name: continue

                    fields = []
                    for f_match in REFLECT_PATTERN.finditer(body):
                        decl = f_match.group(1).strip()
                        parsed = parse_struct_field(decl)
                        if parsed:
                            fields.append(parsed)
                    
                    if fields:
                        structs[name] = fields
                        has_reflection = True
                
                if has_reflection:
                    headers.append(path)
                    
    return enums, structs, headers

def generate_code(enums, structs, headers, output_path):
    lines = []
    lines.append('// GENERATED FILE - DO NOT EDIT\n')
    lines.append('// Generated by tools/codegen.py\n\n')
    lines.append('#include "foundation/meta/reflection.h"\n')
    lines.append('#include <string.h>\n')
    lines.append('#include <strings.h>\n')
    lines.append('#include <stddef.h>\n')
    lines.append('#include <stdbool.h>\n')
    lines.append('\n#ifdef _MSC_VER\n')
    lines.append('#define strcasecmp _stricmp\n')
    lines.append('#endif\n\n')
    
    for h in headers:
        if '/src/' in h:
            include_path = h.split('/src/')[1]
            lines.append(f'#include "{include_path}"\n')
        else:
            lines.append(f'#include "{h}"\n')
    lines.append('\n')

    lines.append('// --- ENUMS ---\n\n')
    for name, values in enums.items():
        lines.append(f'static const MetaEnumValue values_{name}[] = {{\n')
        for v in values:
            lines.append(f'    {{ "{v}", {v} }},\n')
        lines.append('};\n\n')

    lines.append('// --- STRUCTS ---\n\n')
    for s_name, fields in structs.items():
        lines.append(f'static const MetaField fields_{s_name}[] = {{\n')
        for field in fields:
            f_name = field['name']
            f_type = field['type']
            f_base = field['base_type']
            is_ptr = field['is_pointer']
            is_arr = field['is_array']
            
            meta_kind = 'META_TYPE_STRUCT'
            type_name_str = f'"{f_type}"'
            
            if f_type in BASE_TYPES:
                meta_kind = BASE_TYPES[f_type]
                type_name_str = "NULL"
            elif f_base == 'char' and is_ptr:
                meta_kind = 'META_TYPE_STRING'
                type_name_str = "NULL"
            elif f_base == 'char' and is_arr:
                meta_kind = 'META_TYPE_STRING_ARRAY'
                type_name_str = "NULL"
            elif f_type in enums:
                meta_kind = 'META_TYPE_ENUM'
                type_name_str = f'"{f_type}"'
            elif f_type in structs and not is_ptr:
                meta_kind = 'META_TYPE_STRUCT'
                type_name_str = f'"{f_type}"'
            elif is_ptr:
                if field['ptr_count'] == 2:
                    meta_kind = 'META_TYPE_POINTER_ARRAY'
                else:
                    meta_kind = 'META_TYPE_POINTER'
                type_name_str = f'"{f_base}"'
                
            lines.append(f'    {{ "{f_name}", {meta_kind}, offsetof({s_name}, {f_name}), {type_name_str} }},\n')
        lines.append('};\n\n')

    lines.append('// --- REGISTRY---\n\n')
    lines.append('static const MetaEnum enum_registry[] = {\n')
    for name, values in enums.items():
            lines.append(f'    {{ "{name}", values_{name}, {len(values)} }},\n')
    lines.append('    { NULL, NULL, 0 }\n')
    lines.append('};\n\n')
    
    lines.append('static const MetaStruct struct_registry[] = {\n')
    for name, fields in structs.items():
        lines.append(f'    {{ "{name}", sizeof({name}), fields_{name}, {len(fields)} }},\n')
    lines.append('    { NULL, 0, NULL, 0 }\n')
    lines.append('};\n\n')

    lines.append('const MetaStruct* meta_get_struct(const char* name) {\n')
    lines.append('    if (!name) return NULL;\n')
    lines.append('    for (const MetaStruct* s = struct_registry; s->name; ++s) {\n')
    lines.append('        if (strcmp(s->name, name) == 0) return s;\n')
    lines.append('    }\n')
    lines.append('    return NULL;\n')
    lines.append('}\n\n')

    lines.append('const MetaEnum* meta_get_enum(const char* name) {\n')
    lines.append('    if (!name) return NULL;\n')
    lines.append('    for (const MetaEnum* e = enum_registry; e->name; ++e) {\n')
    lines.append('        if (strcmp(e->name, name) == 0) return e;\n')
    lines.append('    }\n')
    lines.append('    return NULL;\n')
    lines.append('}\n\n')

    lines.append('bool meta_enum_get_value(const MetaEnum* meta_enum, const char* name_str, int* out_value) {\n')
    lines.append('    if (!meta_enum || !name_str) return false;\n')
    lines.append('    for (size_t i = 0; i < meta_enum->count; ++i) {\n')
    lines.append('        if (strcasecmp(meta_enum->values[i].name, name_str) == 0) {\n')
    lines.append('            if (out_value) *out_value = meta_enum->values[i].value;\n')
    lines.append('            return true;\n')
    lines.append('        }\n')
    lines.append('    }\n')
    lines.append('    size_t n_len = strlen(name_str);\n')
    lines.append('    for (size_t i = 0; i < meta_enum->count; ++i) {\n')
    lines.append('        const char* val_name = meta_enum->values[i].name;\n')
    lines.append('        size_t v_len = strlen(val_name);\n')
    lines.append('        if (v_len > n_len) {\n')
    lines.append('            if (strcasecmp(val_name + (v_len - n_len), name_str) == 0) {\n')
    lines.append('                 if (out_value) *out_value = meta_enum->values[i].value;\n')
    lines.append('                 return true;\n')
    lines.append('            }\n')
    lines.append('        }\n')
    lines.append('    }\n')
    lines.append('    return false;\n')
    lines.append('}\n')

    content = "".join(lines)
    
    # Check if file exists and content matches
    if os.path.exists(output_path):
        with open(output_path, 'r', encoding='utf-8') as f:
            existing = f.read()
        if existing == content:
            print(f"Skipping {output_path} (no changes)")
            return

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)
    print(f"Wrote {output_path}")

if __name__ == '__main__':
    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    src_dir = os.path.join(project_root, 'src')
    output_dir = os.path.join(src_dir, 'generated')
    output_path = os.path.join(output_dir, 'reflection_registry.c')
    
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        
    print(f"Scanning {src_dir}...")
    enums, structs, headers = scan_files(src_dir)
    print(f"Found {len(enums)} enums and {len(structs)} structs.")
    
    print(f"Generating {output_path}...")
    generate_code(enums, structs, headers, output_path)
    print("Done.")


==================================================
FILE START: vcpkg-configuration.json
==================================================
{
  "default-registry": {
    "kind": "git",
    "baseline": "4f8fe05871555c1798dbcb1957d0d595e94f7b57",
    "repository": "https://github.com/microsoft/vcpkg"
  },
  "registries": [
    {
      "kind": "artifact",
      "location": "https://github.com/microsoft/vcpkg-ce-catalog/archive/refs/heads/main.zip",
      "name": "microsoft"
    }
  ]
}


==================================================
FILE START: vcpkg.json
==================================================
{
  "dependencies": [
    "glfw3",
    "vulkan-headers",
    "vulkan-loader",
    "stb"
  ]
}
