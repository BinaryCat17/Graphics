import os
import re
import sys

# Regex Patterns
ENUM_PATTERN = re.compile(r'typedef\s+enum\s*\w*\s*\{([^}]*)\}\s*(\w+);\s*//\s*REFLECT', re.MULTILINE | re.DOTALL)
STRUCT_PATTERN = re.compile(r'(typedef\s+)?struct\s*(\w*)\s*\{([^}]*)\}\s*(\w+)?\s*;', re.MULTILINE | re.DOTALL)
REFLECT_PATTERN = re.compile(r'^\s*(.+?);\s*//\s*REFLECT(.*)', re.MULTILINE)

BASE_TYPES = {
    'int': 'META_TYPE_INT',
    'float': 'META_TYPE_FLOAT',
    'bool': 'META_TYPE_BOOL',
    'char*': 'META_TYPE_STRING',
    'const char*': 'META_TYPE_STRING',
    'size_t': 'META_TYPE_INT',
    'uint32_t': 'META_TYPE_INT',
    'int32_t': 'META_TYPE_INT',
    'uint8_t': 'META_TYPE_INT',
    'int8_t': 'META_TYPE_INT',
    'uint16_t': 'META_TYPE_INT',
    'int16_t': 'META_TYPE_INT',
    'uint64_t': 'META_TYPE_INT',
    'int64_t': 'META_TYPE_INT',
    'f32': 'META_TYPE_FLOAT',
    'f64': 'META_TYPE_FLOAT',
    'b8': 'META_TYPE_BOOL',
    'b32': 'META_TYPE_BOOL',
    'StringId': 'META_TYPE_STRING_ID',
    'Vec2': 'META_TYPE_VEC2',
    'Vec3': 'META_TYPE_VEC3',
    'Vec4': 'META_TYPE_VEC4',
}

def parse_enum_body(body_text):
    entries = []
    lines = body_text.split('\n')
    clean_text = ""
    for line in lines:
        if '//' in line:
            line = line.split('//')[0]
        clean_text += line + " "
    
    parts = clean_text.split(',')
    for part in parts:
        part = part.strip()
        if not part: continue
        if '=' in part:
            name = part.split('=')[0].strip()
        else:
            name = part
        if name:
            entries.append(name)
    return entries

def parse_struct_field(decl_str):
    decl_str = decl_str.strip()
    is_array = False
    if ']' in decl_str:
        match = re.search(r'\[(.*?)\]', decl_str)
        if match:
            is_array = True
            decl_str = re.sub(r'\[.*?\]', '', decl_str).strip()

    ptr_count = decl_str.count('*')
    is_pointer = ptr_count > 0
    clean_decl = decl_str.replace('*', ' ').strip()
    
    tokens = clean_decl.split()
    if not tokens:
        return None
        
    var_name = tokens[-1]
    type_tokens = tokens[:-1]
    type_name = " ".join(type_tokens)
    
    full_type_str = type_name
    if ptr_count > 0:
        full_type_str += "*" * ptr_count

    return {
        'name': var_name,
        'type': full_type_str,
        'base_type': type_name,
        'is_pointer': is_pointer,
        'ptr_count': ptr_count,
        'is_array': is_array
    }

def scan_files(src_dir):
    enums = {}
    structs = {}
    headers = []
    
    for root, _, files in os.walk(src_dir):
        root = root.replace('\\', '/')
        if 'backend' in root or 'generated' in root:
            continue

        for file in files:
            if file.endswith('.h'):
                path = os.path.join(root, file).replace('\\', '/')
                with open(path, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                has_reflection = False

                for match in ENUM_PATTERN.finditer(content):
                    body = match.group(1)
                    name = match.group(2)
                    values = parse_enum_body(body)
                    if values:
                        enums[name] = values
                        has_reflection = True

                for match in STRUCT_PATTERN.finditer(content):
                    name_tag = match.group(2)
                    body = match.group(3)
                    name_typedef = match.group(4)
                    
                    name = name_typedef if name_typedef else name_tag
                    if not name: continue

                    fields = []
                    for f_match in REFLECT_PATTERN.finditer(body):
                        decl = f_match.group(1).strip()
                        parsed = parse_struct_field(decl)
                        if parsed:
                            fields.append(parsed)
                    
                    if fields:
                        structs[name] = fields
                        has_reflection = True
                
                if has_reflection:
                    headers.append(path)
                    
    return enums, structs, headers

def generate_code(enums, structs, headers, output_path):
    lines = []
    lines.append('// GENERATED FILE - DO NOT EDIT\n')
    lines.append('// Generated by tools/codegen.py\n\n')
    lines.append('#include "foundation/meta/reflection.h"\n')
    lines.append('#include <string.h>\n')
    lines.append('#include <strings.h>\n')
    lines.append('#include <stddef.h>\n')
    lines.append('#include <stdbool.h>\n')
    lines.append('\n#ifdef _MSC_VER\n')
    lines.append('#define strcasecmp _stricmp\n')
    lines.append('#endif\n\n')
    
    for h in headers:
        if '/src/' in h:
            include_path = h.split('/src/')[1]
            lines.append(f'#include "{include_path}"\n')
        else:
            lines.append(f'#include "{h}"\n')
    lines.append('\n')

    lines.append('// --- ENUMS ---\n\n')
    for name, values in enums.items():
        lines.append(f'static const MetaEnumValue values_{name}[] = {{\n')
        for v in values:
            lines.append(f'    {{ "{v}", {v} }},\n')
        lines.append('};\n\n')

    lines.append('// --- STRUCTS ---\n\n')
    for s_name, fields in structs.items():
        lines.append(f'static const MetaField fields_{s_name}[] = {{\n')
        for field in fields:
            f_name = field['name']
            f_type = field['type']
            f_base = field['base_type']
            is_ptr = field['is_pointer']
            is_arr = field['is_array']
            
            meta_kind = 'META_TYPE_STRUCT'
            type_name_str = f'"{f_type}"'
            
            if f_type in BASE_TYPES:
                meta_kind = BASE_TYPES[f_type]
                type_name_str = "NULL"
            elif f_base == 'char' and is_ptr:
                meta_kind = 'META_TYPE_STRING'
                type_name_str = "NULL"
            elif f_base == 'char' and is_arr:
                meta_kind = 'META_TYPE_STRING_ARRAY'
                type_name_str = "NULL"
            elif f_type in enums:
                meta_kind = 'META_TYPE_ENUM'
                type_name_str = f'"{f_type}"'
            elif f_type in structs and not is_ptr:
                meta_kind = 'META_TYPE_STRUCT'
                type_name_str = f'"{f_type}"'
            elif is_ptr:
                if field['ptr_count'] == 2:
                    meta_kind = 'META_TYPE_POINTER_ARRAY'
                else:
                    meta_kind = 'META_TYPE_POINTER'
                type_name_str = f'"{f_base}"'
                
            lines.append(f'    {{ "{f_name}", {meta_kind}, offsetof({s_name}, {f_name}), {type_name_str} }},\n')
        lines.append('};\n\n')

    lines.append('// --- REGISTRY---\n\n')
    lines.append('static const MetaEnum enum_registry[] = {\n')
    for name, values in enums.items():
            lines.append(f'    {{ "{name}", values_{name}, {len(values)} }},\n')
    lines.append('    { NULL, NULL, 0 }\n')
    lines.append('};\n\n')
    
    lines.append('static const MetaStruct struct_registry[] = {\n')
    for name, fields in structs.items():
        lines.append(f'    {{ "{name}", sizeof({name}), fields_{name}, {len(fields)} }},\n')
    lines.append('    { NULL, 0, NULL, 0 }\n')
    lines.append('};\n\n')

    lines.append('const MetaStruct* meta_get_struct(const char* name) {\n')
    lines.append('    if (!name) return NULL;\n')
    lines.append('    for (const MetaStruct* s = struct_registry; s->name; ++s) {\n')
    lines.append('        if (strcmp(s->name, name) == 0) return s;\n')
    lines.append('    }\n')
    lines.append('    return NULL;\n')
    lines.append('}\n\n')

    lines.append('const MetaEnum* meta_get_enum(const char* name) {\n')
    lines.append('    if (!name) return NULL;\n')
    lines.append('    for (const MetaEnum* e = enum_registry; e->name; ++e) {\n')
    lines.append('        if (strcmp(e->name, name) == 0) return e;\n')
    lines.append('    }\n')
    lines.append('    return NULL;\n')
    lines.append('}\n\n')

    lines.append('bool meta_enum_get_value(const MetaEnum* meta_enum, const char* name_str, int* out_value) {\n')
    lines.append('    if (!meta_enum || !name_str) return false;\n')
    lines.append('    for (size_t i = 0; i < meta_enum->count; ++i) {\n')
    lines.append('        if (strcasecmp(meta_enum->values[i].name, name_str) == 0) {\n')
    lines.append('            if (out_value) *out_value = meta_enum->values[i].value;\n')
    lines.append('            return true;\n')
    lines.append('        }\n')
    lines.append('    }\n')
    lines.append('    size_t n_len = strlen(name_str);\n')
    lines.append('    for (size_t i = 0; i < meta_enum->count; ++i) {\n')
    lines.append('        const char* val_name = meta_enum->values[i].name;\n')
    lines.append('        size_t v_len = strlen(val_name);\n')
    lines.append('        if (v_len > n_len) {\n')
    lines.append('            if (strcasecmp(val_name + (v_len - n_len), name_str) == 0) {\n')
    lines.append('                 if (out_value) *out_value = meta_enum->values[i].value;\n')
    lines.append('                 return true;\n')
    lines.append('            }\n')
    lines.append('        }\n')
    lines.append('    }\n')
    lines.append('    return false;\n')
    lines.append('}\n')

    content = "".join(lines)
    
    # Check if file exists and content matches
    if os.path.exists(output_path):
        with open(output_path, 'r', encoding='utf-8') as f:
            existing = f.read()
        if existing == content:
            print(f"Skipping {output_path} (no changes)")
            return

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)
    print(f"Wrote {output_path}")

if __name__ == '__main__':
    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    src_dir = os.path.join(project_root, 'src')
    output_dir = os.path.join(src_dir, 'generated')
    output_path = os.path.join(output_dir, 'reflection_registry.c')
    
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
        
    print(f"Scanning {src_dir}...")
    enums, structs, headers = scan_files(src_dir)
    print(f"Found {len(enums)} enums and {len(structs)} structs.")
    
    print(f"Generating {output_path}...")
    generate_code(enums, structs, headers, output_path)
    print("Done.")
